<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>闪聚支付项目-项目总结</title>
    <link href="/2022/05/08/%E9%97%AA%E8%81%9A%E6%94%AF%E4%BB%98%E9%A1%B9%E7%9B%AE-%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <url>/2022/05/08/%E9%97%AA%E8%81%9A%E6%94%AF%E4%BB%98%E9%A1%B9%E7%9B%AE-%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h4 id="闪聚支付是个什么样的项目？"><a href="#闪聚支付是个什么样的项目？" class="headerlink" title="闪聚支付是个什么样的项目？"></a>闪聚支付是个什么样的项目？</h4><p><strong>项目背景</strong></p><p>随着移动支付的盛行，商业银行、第三方支付公司、其它清算机构、消费金融公司等众多类型的机构，都在为商户提供网络（移动）支付解决方案。另一方面，用户的支付需求繁多，支付渠道已呈“碎片化”状态，并且“碎片化”程度将逐渐加深。聚合支付顾名思义就是将目前主流的支付进行整合，形成第三方支付的聚合通道，也被称为“第四方支付”。</p><p>下图是聚合支付的产业结构：</p><p><img src="https://img-blog.csdnimg.cn/20200807174552351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk1MDk4Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>聚合支付不进行资金清算，因此无需支付牌照，其只是完成支付环节的信息流转和商户运营的承载，其在<a href="https://so.csdn.net/so/search?q=%E9%9B%86%E5%90%88&spm=1001.2101.3001.7020">集合</a>银联、支付宝、微信等主流支付方式的基础上，帮助商户降低接入成本，提高运营效率，具有中立性、灵活性、便捷性等特点。</p><p>下图是商户通过聚合支付平台完成支付业务：</p><p><img src="https://img-blog.csdnimg.cn/2020080717463898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk1MDk4Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="项目的功能模块"><a href="#项目的功能模块" class="headerlink" title="项目的功能模块"></a>项目的功能模块</h5><p>平台主要包括三个模块：官网&amp;开放平台、商户平台、运营平台，详细功能如下：</p><p><img src="https://img-blog.csdnimg.cn/20200807174701961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk1MDk4Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><table><thead><tr><th align="center"><strong>功能模块名称</strong></th><th align="center"><strong>功能说明</strong></th></tr></thead><tbody><tr><td align="center">官网&amp;开放平台</td><td align="center">产品展示、功能介绍、帮助中心和开发者中心</td></tr><tr><td align="center">商户平台-首页</td><td align="center">提供商户注册、登录、基本信息查看、数据看板</td></tr><tr><td align="center">商户平台-账户管理</td><td align="center">提供商户企业资质认证、企业信息查看和套餐购买</td></tr><tr><td align="center">商户平台-支付管理</td><td align="center">为商户提供应用创建、渠道参数配置、交易总览和开启支付(生成二维码)等</td></tr><tr><td align="center">商户平台-门店管理</td><td align="center">为商户提供新增门店、店长分配、门店导入等</td></tr><tr><td align="center">商户平台-员工管理</td><td align="center">为商户提供新增员工、定义角色、分配角色等</td></tr><tr><td align="center">商户平台-优惠管理</td><td align="center">为商户提供优惠券管理、活动统计等</td></tr><tr><td align="center">运营平台-商户管理</td><td align="center">对商户进行检索、审核和订单统计</td></tr><tr><td align="center">运营平台-优惠管理</td><td align="center">为商户设置优惠策略和优惠券发送</td></tr><tr><td align="center">运营平台-管理员管理</td><td align="center">为平台提供新增管理员、定义角色和分配角色等</td></tr></tbody></table><h5 id="项目的技术架构"><a href="#项目的技术架构" class="headerlink" title="项目的技术架构"></a>项目的技术架构</h5><p>见问题2</p><h4 id="项目采用什么技术架构？"><a href="#项目采用什么技术架构？" class="headerlink" title="项目采用什么技术架构？"></a>项目采用什么技术架构？</h4><p>闪聚支付采用当前流行的前后端分离架构开发，由用户层、UI层、微服务层、数据层等部分组成，为PC、H5等客户端用户提供服务。下图是系统的技术架构图：</p><p><img src="https://img-blog.csdnimg.cn/20200807175154998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk1MDk4Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>业务流程举例：</p><ol><li>用户可以通过PC、手机等客户端访问闪聚支付。</li><li>系统应用CDN技术，对一些图片、CSS、视频等资源从CDN调度访问。</li><li>所有的请求全部经过负载均衡器。</li><li>首先请求UI层，渲染用户界面。</li><li>商户通过平台进行注册和企业认证，UI层通过网关请求服务层，服务层完成业务处理后将数据持久化到数据层。</li><li>平台运营人员对商户信息进行审核，其系统执行流程和商户注册过程一致，UI层请求服务层业务处理，服务层通过数据层将数据持久化到数据库。</li></ol><p>各模块说明如下：</p><table><thead><tr><th align="center"><strong>名称</strong></th><th align="center"><strong>功能描述</strong></th></tr></thead><tbody><tr><td align="center">用户层</td><td align="center">用户层描述了本系统所支持的用户类型包括：pc用户、app用户、h5用户。<br/>pc用户通过浏览器访问系统、app用户通过android、ios手机访问系统，H5用户通过h5页面访问系统。</td></tr><tr><td align="center">CDN</td><td align="center">CDN全称Content Delivery Network，即内容分发网络，本系统所有静态资源全部通过CDN加速来提高访问速度。<br/>系统静态资源包括：html页面、js文件、css文件、image图片、pdf和ppt及doc教学文档、video视频等。</td></tr><tr><td align="center">负载均衡</td><td align="center">系统的CDN层、UI层、服务层及数据层均设置了负载均衡服务，上图仅在UI层前边标注了负载均衡。<br/>每一层的负载均衡会根据系统的需求来确定负载均衡器的类型，<br/>系统支持4层负载均衡+7层负载均衡结合的方式，<br/>4层负载均衡是指在网络传输层进行流程转发，根据IP和端口进行转发，<br/>7层负载均衡完成HTTP协议负载均衡及反向代理的功能，根据url进行请求转发。<br/></td></tr><tr><td align="center">UI层</td><td align="center">UI层描述了系统向pc用户、app用户、h5用户提供的产品界面。根据系统功能模块特点确定了UI层包括如下产品界面类型：<br/>1）面向商户的闪聚支付商户平台。<br/>2）面向平台运营人员的闪聚支付运营平台。</td></tr><tr><td align="center">微服务层</td><td align="center">微服务层将系统服务分类两类：业务微服务、基础微服务。<br/>业务微服务：主要为商户和运营人员提供业务服务，包括统一认证、商户服务、交易服务等。<br/>基础微服务：为系统级的公共服务，不涉及具体的业务，包括文件服务、配置服务、验证码服务、调度服务等。</td></tr><tr><td align="center">数据层</td><td align="center">数据层描述了系统的数据存储的内容类型，持久化的业务数据使用MySQL。<br/>消息队列：存储系统服务间通信的消息，本身提供消息存取服务，与微服务层的系统服务连接。<br/>缓存：作为系统的缓存服务，存储商户信息、验证码信息、用户信息等，与微服务层的所有服务连接。<br/>文件存储：提供系统静态资源文件的分布式存储服务，文件存储服务器作为CDN服务器的数据来源，<br/>CDN上的静态资源将最终在文件存储服务器上保存多份。<br/></td></tr><tr><td align="center">外部系统接口</td><td align="center">1）支付宝、微信支付接口，本系统提供支付宝、微信两种支付接口。<br/>2）短信接口，本系统与第三方平台对接短信发送接口。<br/>3）文件存储 ，静态资源文件的存储采用第三方文件服务方式，本系统采用七牛云文件存储。<br/>4）CDN，本系统与第三方CDN服务对接，使用CDN加速服务来提高本系统的访问速度。<br/></td></tr></tbody></table><h5 id="微服务技术栈"><a href="#微服务技术栈" class="headerlink" title="微服务技术栈"></a>微服务技术栈</h5><p>所有微服务基于 <strong><code>Spring Boot</code></strong> 、**<code>Spring Cloud Alibaba</code>** 构建。</p><h5 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h5><p><strong><code>Spring MVC</code></strong> 、**<code>Swagger</code>**</p><h5 id="业务层"><a href="#业务层" class="headerlink" title="业务层"></a>业务层</h5><ul><li>事务控制：**<code>Spring</code>**</li><li>数据缓存：**<code>Spring Data Redis</code>**</li><li>消息队列：**<code>Spring RocketTemplate</code>**</li></ul><h5 id="持久层"><a href="#持久层" class="headerlink" title="持久层"></a>持久层</h5><ul><li><strong><code>MySQL</code></strong> 数据库</li><li><strong><code>MyBatisPlus</code></strong> 持久层框架</li><li>连接池 <strong><code>com.alibaba.druid</code></strong> （采用 <strong><code>druid-spring-boot-starter</code></strong> ）</li><li><strong><code>ShardingJdbc</code></strong> 分库分表技术</li></ul><p>项目技术栈如下：</p><p><img src="https://img-blog.csdnimg.cn/20200807180227983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk1MDk4Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>闪聚支付服务端基于 <strong><code>Spring Boot</code></strong> 构建，采用 <strong><code>Spring Cloud Alibaba</code></strong> 微服务架构。</p><p> <strong>1、基础设施</strong></p><p>业务数据持久化采用 <strong><code>MySQL</code></strong> ，数据缓存采用 <strong><code>Redis</code></strong> ，采用 <strong><code>RocketMQ</code></strong> 的事务消息机制完成部分场景下的分布式事务控制，采用第三方云平台完成文件上传与分布式存储。</p><p><strong>2、组件</strong></p><p>系统微服务基于 SpringBoot 开发，服务层基于 Dubbo Spring Cloud 构建，数据库连接池采用 Druid ，POJO构建采用 Lombok ，日志系统采用 Log4j2 ，Mybatis Plus 持久层接口实现，Sharding-jdbc 分库分表组件，Swagger 接口规范组件，XXL-job 分布式任务调度组件，Sentinel 限流组件等。</p><p><strong>3、接入</strong></p><p>Zuul 网关完成客户端认证、路由转发等功能，JWT 提供前后端令牌管理方案。</p><p><strong>4、视图</strong></p><p>平台支持H5、PC等各种前端。</p><p><strong>接口定义规范</strong></p><p>1、项目面向前端的Http接口使用 swagger 文档描述接口的内容</p><p>2、面向前端的Http接口定义规范如下：</p><p>1）请求</p><p>Get 请求时，前端请求key/value串，SpringMVC采用基本数据类型（String、Integer等）接收参数，特殊情况使用自定义对象接收。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation(value = &quot;根据id查询商户信息&quot;)</span><br><span class="hljs-meta">@GetMapping(&quot;/merchants/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> MerchantDTO <span class="hljs-title function_">queryMerchantById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span><br><br><span class="hljs-meta">@ApiOperation(&quot;根据应用和服务类型和支付渠道获取单个支付渠道参数&quot;)</span><br><span class="hljs-meta">@GetMapping(value = &quot;/my/pay-channel‐params/apps/&#123;appId&#125;/platform‐channels/&#123;platformChannel&#125;/pay-channels/&#123;payChannel&#125;&quot;)</span><br><span class="hljs-keyword">public</span> PayChannelParamDTO <span class="hljs-title function_">queryPayChannelParam</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;appId&quot;)</span> String appId, <span class="hljs-meta">@PathVariable(&quot;platformChannel&quot;)</span> String platformChannel, <span class="hljs-meta">@PathVariable(&quot;payChannel&quot;)</span> String payChannel)</span><br></code></pre></td></tr></table></figure><p>Post请求时，前端请Form表单数据（ application/x-www-form-urlencoded ）和Json数据( ContentType=application/json )、多部件类型数据（ multipart/form-data ），SpringMVC采用基本类型及自定义对象接收，对于Json数据SpringMVC使用 @RequestBody 注解解析请求的json数据。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/merchants/register&quot;)</span><br><span class="hljs-keyword">public</span> MerchantRegisterVO <span class="hljs-title function_">registerMerchant</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> MerchantRegisterVO merchantRegisterVO)</span><br><br><span class="hljs-meta">@PostMapping(&quot;/upload&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">upload</span><span class="hljs-params">(<span class="hljs-meta">@ApiParam(value = &quot;证件照&quot;, required = true)</span> <span class="hljs-meta">@RequestParam(&quot;file&quot;)</span> MultipartFile multipartFile)</span> <span class="hljs-keyword">throws</span> IOException<br><br><span class="hljs-meta">@PostMapping(&quot;/createAliPayOrder&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createAlipayOrderForStore</span><span class="hljs-params">(OrderConfirmVO orderConfirmVO, HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> BusinessException, IOException<br></code></pre></td></tr></table></figure><p>2）响应</p><p>响应结果统一信息为：是否成功、操作代码、提示信息及自定义数据。</p><p>响应结果统一格式为json，扫码类接口为text/html。</p><h5 id="Swagger如何使用？"><a href="#Swagger如何使用？" class="headerlink" title="Swagger如何使用？"></a>Swagger如何使用？</h5><p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务(<a href="https://swagger.io/)%E3%80%82">https://swagger.io/)。</a> 它的主要作用是：</p><p>1、使得前后端分离开发更加方便，有利于团队协作</p><p>2、接口的文档在线自动生成，降低后端开发人员编写接口文档的负担</p><p>3、如何使用？</p><p>项目中SpringBoot集成Swagger，Spring已经将Swagger纳入自身的标准，建立了Spring-swagger项目，现在叫Springfox。通过在项目中引入Springfox ，即可非常简单快捷的使用Swagger。</p><p>在Controller接口方法上使用注解描述接口内容，Swagger常用注解如下：</p><ul><li><strong><code>@Api</code></strong> ：修饰整个类，描述Controller的作用</li><li><strong><code>@ApiOperation</code></strong> ：描述一个类的一个方法，或者说一个接口</li><li><strong><code>@ApiParam</code></strong> ：单个参数的描述信息</li><li><strong><code>@ApiModel</code></strong> ：用对象来接收参数</li><li><strong><code>@ApiModelProperty</code></strong> ：用对象接收参数时，描述对象的一个字段</li><li><strong><code>@ApiResponse</code></strong> ：HTTP响应其中1个描述</li><li><strong><code>@ApiResponses</code></strong> ：HTTP响应整体描述</li><li><strong><code>@ApiIgnore</code></strong> ：使用该注解忽略这个API</li><li><strong><code>@ApiError</code></strong> ：发生错误返回的信息</li><li><strong><code>@ApiImplicitParam</code></strong> ：一个请求参数</li><li><strong><code>@ApiImplicitParams</code></strong> ：多个请求参数的描述信息</li></ul><h5 id="注册中心-amp-服务发现"><a href="#注册中心-amp-服务发现" class="headerlink" title="注册中心&amp;服务发现"></a>注册中心&amp;服务发现</h5><p>项目采用 <strong><code>Nacos</code></strong> 作为注册中心，注册中心也叫服务发现中心，服务发现就是服务消费方通过服务发现中心智能发现服务提供方，从而进行远程调用的过程。</p><p>下图是服务发现的流程：</p><p><img src="https://img-blog.csdnimg.cn/20200807181352314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk1MDk4Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>上图中服务实例本身并不记录服务生产方的网络地址，所有服务实例内部都会包含<strong>服务发现客户端。</strong></p><p>（1）在每个服务启动时会向<strong>服务发现中心</strong>上报自己的网络位置。这样，在服务发现中心内部会形成一个<strong>服务注册表，服务注册表</strong>是服务发现的核心部分，是包含所有服务实例的网络地址的数据库。</p><p>（2）<strong>服务发现客户端</strong>会定期从<strong>服务发现中心</strong>同步<strong>服务注册表</strong> ，并缓存在客户端。</p><p>（3）当需要对某服务进行请求时，服务实例通过该注册表，定位目标服务网络地址。若目标服务存在多个网络地址，则使用负载均衡算法从多个服务实例中选择出一个，然后发出请求。</p><h5 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h5><p>项目采用 <strong><code>Nacos</code></strong> 作为配置中心，配置中心将配置从各应用中剥离出来，对配置进行统一管理，应用自身不需要自己去管理配置。<img src="https://img-blog.csdnimg.cn/20200807181558989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk1MDk4Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>配置中心的服务流程如下：</p><ol><li>用户在配置中心更新配置信息。</li><li>服务A和服务B及时得到配置更新通知，从配置中心获取配置。</li></ol><p><strong>总得来说，配置中心就是一种统一管理各种应用配置的基础服务组件。</strong></p><p>在 <strong><code>Nacos</code></strong> 中每个微服务对应一个主配置文件，配置文件的名称即服务名加文件扩展名。</p><p><img src="https://img-blog.csdnimg.cn/2020080718170079.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk1MDk4Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>主配置文件可以增加很多扩展配置文件，使用 <strong><code>ext-config</code></strong> 进行扩展：</p><p><img src="https://img-blog.csdnimg.cn/20200807181722239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk1MDk4Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><code>Nacos</code> 重要的概念：</p><p><code>Nacos</code> 抽象定义了 <code>Namespace</code> 、<code>Group</code> 、<code>Data ID</code> 的概念，具体这几个概念代表什么，取决于我们把它们看成什么，这里推荐给大家一种用法，如下图：</p><p><code>Namespace</code> ：代表不同环境，如开发、测试、生产环境。</p><p>项目的 <code>bootstrap.yml</code> 中别忘记配置 <code>Namespace</code>！！！</p><p><code>Group</code> ：代表某项目，如XX医疗项目、XX电商项目</p><p><code>Data ID </code>：每个项目下往往有若干个工程，每个配置集(<code> DataId</code> )是一个工程的主配置文件</p><p><img src="https://img-blog.csdnimg.cn/20200807181758982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk1MDk4Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h5><p>需要了解网关的作用：负载均衡、路由转发、请求过虑等。</p><p><img src="https://img-blog.csdnimg.cn/20200807182009235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk1MDk4Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="项目使用Spring了吗？用了它的哪些东西？"><a href="#项目使用Spring了吗？用了它的哪些东西？" class="headerlink" title="项目使用Spring了吗？用了它的哪些东西？"></a>项目使用Spring了吗？用了它的哪些东西？</h5><p>项目是基于Spring进行构建，每一层都需要Spring。</p><p>1、每个微服务工程是采用 <code>Spring Boot</code> 开发。</p><p>2、基于<code> Spring Cloud Alibaba</code> 实现微服务的配置、服务注册、<code>Dubbo</code> 接口。</p><p>其中，最重要的是实现了 <code>Dubbo</code> 接口与 <code>RESTful</code> 接口均可以注册至 <code>Nacos</code> 。</p><p>3、数据层使用 <code>MyBatis Plus</code> 、<code>Spring RocketMQ</code> 、<code>Spring Data redis</code> 。</p><p>4、业务层使用 <code>Spring</code> 来控制本地事务。</p><p>5、控制层使用<code> SpringMVC</code> 开发RESTful接口。</p><h5 id="Spring-Cloud-Alibaba是怎么使用的？"><a href="#Spring-Cloud-Alibaba是怎么使用的？" class="headerlink" title="Spring Cloud Alibaba是怎么使用的？"></a>Spring Cloud Alibaba是怎么使用的？</h5><p><strong><code>Spring Cloud Alibaba</code></strong> 是阿里巴巴公司基于Spring Cloud标准实现的一套微服务开发框架集合，它和Netflix一样都是Spring Cloud微服务开发实现方案。</p><p>项目地址：<a href="https://github.com/alibaba/spring-cloud-alibaba">https://github.com/alibaba/spring-cloud-alibaba</a></p><p>本项目基于 <strong><code>Spring Cloud Alibaba</code></strong> 框架构建系统架构，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200807182333692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk1MDk4Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>系统的微服务分为两类：应用层服务和业务层服务。</p><p>应用层服务对前端暴露RESTful接口，业务层服务供应用层调用，暴露Dubbo服务。</p><p>1、每个应用层服务使用Spring Boot开发，每个微服务工程包括了web、service、dao三层，这和开发一般的项目没有区别：</p><p>a、Web层使用Spring MVC实现，对外暴露RESTful接口供前端调用。</p><p>b、Service层就是根据业务逻辑编写JavaBean，并使用Spring的声明式事务控制方式来控制事务。</p><p>c、Dao层就是数据访问接口，使用MybatisPlus访问MySQL。</p><p>2、每个业务层服务通常只需要编写Service和Dao即可，Service暴露为Dubbo服务接口供应用层调用。（特殊情况除外，比如交易服务暴露支付入口HTTP接口）</p><p>Dubbo接口如何开发？</p><p>和开发一个普通的Service Bean一样，需要在Service类上使用 <strong><code>@org.apache.dubbo.config.annotation.Service</code></strong> 注解。</p><p>3、微服务开发完成要向Nacos注册中心注册，以便被其它微服务查找和访问。</p><p>4、微服务与微服务之间使用Dubbo来调用。只需要在调用方使用 <strong><code>@org.apache.dubbo.config.annotation.Reference</code></strong> 注解引入服务接口，通过生成代理对象发起远程调用。</p><p>5、前端访问微服务需要通过网关，网关使用Nginx和Zuul来实现，Nginx是最前边的负载均衡，通过Nginx之后便到达了Zuul，项目中Zuul的功能是过虑用户请求，判断用户身份，对于一些对外公开的微服务则需要经过Zuul，直接通过Nginx负载均衡即可访问。</p><h5 id="视图层用什么技术实现？"><a href="#视图层用什么技术实现？" class="headerlink" title="视图层用什么技术实现？"></a>视图层用什么技术实现？</h5><ol><li>从系统整体架构上来说，视图层包括前端视图和服务端视图。</li><li>前端视图采用 <strong><code>vue.js</code></strong> + <strong><code>elementUI</code></strong> 产品界面。</li><li>服务端提供给vue前端的都是暴露的RESTful接口，统一用JSON响应数据。</li><li>交易服务对外提供支付入口，使用Freemarker视图渲染技术生成HTML页面返回给浏览器。</li></ol><h5 id="接口是怎么定义的？采用什么数据格式？如何实现？"><a href="#接口是怎么定义的？采用什么数据格式？如何实现？" class="headerlink" title="接口是怎么定义的？采用什么数据格式？如何实现？"></a>接口是怎么定义的？采用什么数据格式？如何实现？</h5><p>接口分为面向前端的HTTP接口，和面向服务内部调用的Dubbo服务接口。</p><p>1、面向前端的RESTful接口</p><p>参考2.2 接口定义规范.</p><p>2、面向服务内部采用Dubbo服务接口</p><p>1）采用Dubbo协议具体使用Hessian2 二进制序列化协议。</p><p>2）编写Service类及方法，并使用 <strong><code>@org.apache.dubbo.config.annotation.Service</code></strong> 注解在类上标识。</p><p>3）Service类需要操作数据库时则通过调用Dao层的Mapper接口来完成。</p><p>4）Service与Service之间的调用分为本地调用和远程调用</p><p>本地调用是同一个工程的service之间的调用，只需要使用 <strong><code>@Autowired</code></strong> 或 <strong><code>@Resource</code></strong> 注入即可使用。</p><p>远程调用是跨服务（工程）的service之间的调用，需要在调用方使用 <strong><code>@org.apache.dubbo.config.annotation.Reference</code></strong> 注解引入服务接口，通过生成代理对象发起远程调用。</p><h5 id="项目中的代码是否自动生成？"><a href="#项目中的代码是否自动生成？" class="headerlink" title="项目中的代码是否自动生成？"></a>项目中的代码是否自动生成？</h5><p>项目中使用 <strong><code>Mybatis-Plus</code></strong> 提供的代码自动生成方法来生成代码。</p><p>自动生成的代码包括：**<code>entity</code>** 、**<code>DTO</code>** 、**<code>mapper</code>** （**<code>java</code>** 、**<code>xml</code>** ）等。</p><h5 id="前端采用什么技术栈？"><a href="#前端采用什么技术栈？" class="headerlink" title="前端采用什么技术栈？"></a>前端采用什么技术栈？</h5><p>前端工程大多为单页面应用（ <strong><code>SPA</code></strong> ），采用 <strong><code>vue.js</code></strong> 框架开发，搜索功能前端采用 <strong><code>nuxt.js</code></strong> 服务端渲染（ <strong><code>SSR</code></strong> ）框架开发。</p><p>技术栈包括：</p><ul><li><strong><code>node.js</code></strong></li><li><strong><code>vue.js</code></strong></li><li><strong><code>npm/cnpm</code></strong></li><li><strong><code>webpack</code></strong></li><li><strong><code>axios</code></strong></li><li><strong><code>nuxt.js</code></strong></li></ul><h4 id="前后端开发时具体流程是什么？"><a href="#前后端开发时具体流程是什么？" class="headerlink" title="前后端开发时具体流程是什么？"></a>前后端开发时具体流程是什么？</h4><p>前后端分离开发模式在互联网公司最常见，特别是一些大型的互联网公司，但是一些传统的软件开发企业仍然是采用传统开发模式，此问题被问及是考察你有没有真正体会前端开发的好处。</p><p>1、前端与后端开发人员讨论确定接口。</p><p>接口讨论通过，形成接口文档 。</p><p>本项目专门设立一个api工程，在此工程定义接口，**<code>Spring Boot</code>** 集成 **<code>Swagger</code>**，生成 <strong><code>Swagger</code></strong> 接口，前后端 开发人员通过html查看接口文档的内容。</p><p>2、前端与后端开发人员按照接口文档进行开发。</p><p>开发过程中各自进行单元测试。</p><p>前端人员怎么进行单元测试？</p><p>前端人员可以通过mock平台生成一些模拟数据，比如：**<code>EasyMock</code>** 。</p><p>3、双方功能开发完成进行前后端联调。</p><h4 id="商户平台"><a href="#商户平台" class="headerlink" title="商户平台"></a>商户平台</h4><p>商户平台是提供商户使用的进行应用管理、支付渠道参数配置、门店管理、员工管理等商户管理的业务操作。</p><p>包括 如下功能：</p><ol><li>商户注册 ，资质申请</li><li>支付渠道参数配置。</li><li>门店管理，二维码生成。</li><li>员工管理。</li></ol><h5 id="商户注册流程"><a href="#商户注册流程" class="headerlink" title="商户注册流程"></a>商户注册流程</h5><p>商户注册交互流程如下：</p><p><img src="https://img-blog.csdnimg.cn/20200807183514800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk1MDk4Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="云平台的使用"><a href="#云平台的使用" class="headerlink" title="云平台的使用"></a>云平台的使用</h5><p>1、短信验证码</p><p>使用腾讯云</p><p>2、上传商户资质证件</p><p>使用七牛云</p><p>如何使用云平台？</p><p>1）详细阅读云平台的具体业务接口，比如文件上传、文件下载接口。</p><p>2）下载云平台的sdk（开发工具包）</p><p>3）将sdk依赖引入工程，编写独立的工具类调用云平台的接口。</p><h5 id="SaaS平台是如何实现"><a href="#SaaS平台是如何实现" class="headerlink" title="SaaS平台是如何实现"></a>SaaS平台是如何实现</h5><p>1、理解多租户的概念</p><p>当一个使用SaaS模式部署的软件同时有多个企业用户租用时，每一个企业都是独立的租用者，我们通常称他为：租户(tenant)；同时有多个租用者，那就是多租户(multi-tenant)。多租户（Multi-tenant)是SaaS最重要的核心概念和关键技术。</p><p><img src="https://img-blog.csdnimg.cn/20200807183611159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk1MDk4Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>2、如何实现SaaS？</p><p>本项目使用公司现成的SaaS系统，实现租户管理、用户管理、角色及权限管理和统一认证的功能。</p><p>闪聚支付平台在注册商户时向SaaS系统写入租户信息完成对接 。</p><h5 id="项目中OAuth2-0怎么使用？"><a href="#项目中OAuth2-0怎么使用？" class="headerlink" title="项目中OAuth2.0怎么使用？"></a>项目中OAuth2.0怎么使用？</h5><p>1、**<code>OAuth2.0</code>** 是什么？</p><p>OAuth（开放授权）是一个开放标准，允许用户授权第三方应用访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方应用或分享他们数据的所有内容。</p><p>认证流程：</p><p><img src="https://img-blog.csdnimg.cn/20200807183711171.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk1MDk4Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>OAauth2.0包括以下角色：</p><p>1）客户端</p><p>本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源，比如：Android客户端、Web客户端（浏览器端）、微信客户端等。</p><p>2）资源拥有者</p><p>通常为用户，也可以是应用程序，即该资源的拥有者。</p><p>3）授权服务器（也称认证服务器）</p><p>用于服务提供商对资源拥有的身份进行认证、对访问资源进行授权，认证成功后会给客户端发放令牌（access_token），作为客户端访问资源服务器的凭据。本例为微信的认证服务器。</p><p>4）资源服务器</p><p>存储资源的服务器，本例子为微信存储的用户信息。</p><p>2、**<code>OAuth2.0</code>**怎么使用？</p><p>OAuth2.0提供了四种授权(获取令牌)方式：</p><p>1）授权码模式：这种模式是四种模式中最安全的一种模式。一般用于Web服务器端应用或第三方的原生App调用资源服务的时候。场景：使用微信登录其它网站。</p><p>2）密码模式：适应于第一方的单页面应用以及第一方的原生App，本项目用户认证使用密码模式。</p><p>3）客户端模式：适应于没有用户参与的，完全信任的一方或合作方服务器端程序接入。</p><p>4）简化模式：适用于第三方单页面应用接入OAuth2.0认证服务。</p><h4 id="交易管理"><a href="#交易管理" class="headerlink" title="交易管理"></a>交易管理</h4><p>平台订单相关的管理由交易服务负责。</p><h5 id="C扫B的实现流程是什么？"><a href="#C扫B的实现流程是什么？" class="headerlink" title="C扫B的实现流程是什么？"></a>C扫B的实现流程是什么？</h5><p><img src="https://img-blog.csdnimg.cn/20200807183840341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk1MDk4Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>C扫B即买方（顾客）扫商户的二维码完成支付的过程。</p><ol><li>用户向商户发起支付请求</li><li>商户店员使用闪聚支付平台请求获取二维码</li><li>平台请求商户平台应用统一下单接口</li><li>商户平台应用调用交易服务生成支付信息</li><li>商户平台应用根据返回的信息生成二维码返回给前端</li><li>商户店员展示二维码给用户</li><li>用户使用微信或支付宝扫描二维码</li><li>交易服务根据请求类型和支付渠道生成支付确认页面返回给前端</li><li>用户输入金额并点击确认支付</li><li>交易服务收到请求后，保存订单信息并向支付渠道代理服务发起支付请求</li><li>支付渠道代理服务生成渠道支付参数，向微信或支付宝发起支付请求</li><li>根据返回的结果发送支付结果查询消息</li><li>第三方支付生成支付凭据返回给用户的支付客户端</li><li>支付渠道代理服务消费支付结果查询消息</li><li>根据消息内容查询订单支付结果，并发送支付结果消息</li><li>交易服务消费支付结果消息</li><li>根据消息内容更新数据库中的订单支付结果</li></ol><h5 id="二维码如何生成？"><a href="#二维码如何生成？" class="headerlink" title="二维码如何生成？"></a>二维码如何生成？</h5><p>使用 <strong><code>ZXing</code></strong> 一个开源项目完成二维码的生成，ZXing是用Java编写的多格式的1D / 2D条码图像处理库，使用ZXing可以生成、识别 **<code>QR Code</code>**（二维码）。</p><h5 id="都对接了哪些支付接口？"><a href="#都对接了哪些支付接口？" class="headerlink" title="都对接了哪些支付接口？"></a>都对接了哪些支付接口？</h5><p>闪聚支付平台提供C扫B和B扫C的支付服务。</p><p>1、C扫B对接接口如下</p><p>微信：JSAPI（下单、查询订单等）</p><p>支付宝：手机网站支付ALIPAY_WAP（下单、查询订单等）</p><p>2、B扫C对接接口如下</p><p>微信：付款码支付产品</p><p>支付宝：当面付条码支付。</p><p>3、微信JSAPI接口交互流程</p><p><img src="https://img-blog.csdnimg.cn/20200807183958770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk1MDk4Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>4、支付接口交互流程</p><p><img src="https://img-blog.csdnimg.cn/20200807184011203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk1MDk4Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="如何获取支付结果？"><a href="#如何获取支付结果？" class="headerlink" title="如何获取支付结果？"></a>如何获取支付结果？</h5><p>第三方支付系统提供异步通知支付结果和主动查询支付结果两种方式：</p><p>异步通知支付结果：第三方支付系统调用闪聚支付平台通知支付结果。当通知累积一定次数无法到达，第三方支付系统将不再通知。</p><p>主动查询支付结果：闪聚支付平台主动调用第三方支付系统查询支付结果。</p><p>本项目采用MQ完成主动查询支付结果实现。</p><h5 id="项目中MQ如何使用？"><a href="#项目中MQ如何使用？" class="headerlink" title="项目中MQ如何使用？"></a>项目中MQ如何使用？</h5><p>目使用消息队列RocketMQ完成支付渠道代理服务与交易服务之间的通信，并且用到的RocketMQ 的延迟消息，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200807184525276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk1MDk4Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>1、支付渠道代理服务调用第三方支付下单接口。（此时顾客开始输入密码进行支付）</p><p>2、支付渠道代理向消息队列发送一条延迟消息，消费方仍是支付渠道代理服务。</p><p>3、支付渠道代理调用支付宝接口查询支付结果，如果支付成功将支付结果发送至MQ，消费方是交易服务。</p><p>4、交易服务接收到支付结果消息，更新订单状态。</p><h5 id="项目中Redis如何使用？"><a href="#项目中Redis如何使用？" class="headerlink" title="项目中Redis如何使用？"></a>项目中Redis如何使用？</h5><p>渠道参数查询频繁，每一次支付都会查询渠道参数，为提供查询性能这里我们将渠道参数缓存到redis中，缓存流程如下：</p><p>1、保存渠道参数添加缓存</p><p>保存渠道参数成功，同时将渠道参数保存在Redis中。</p><p>2、查询渠道参数缓存</p><p>查询渠道参数，先从Redis查询，如果Redis存在则返回渠道参数，否则从数据库查询同时将查询到的渠道参数存储在Redis中。</p><h4 id="数据库分库分表是如何实现的？"><a href="#数据库分库分表是如何实现的？" class="headerlink" title="数据库分库分表是如何实现的？"></a>数据库分库分表是如何实现的？</h4><p>项目采用微服务架构，每个微服务使用一个数据库，在系统设计上就已经分库了。</p><p>针对订单数据量大的特点，为提高系统的性能使用Sharding-JDBC对订单表进行分库分表。</p><p>方案如下：</p><p>对交易数据库进行分库，对订单表进行分表。</p><p>分库规则：分片键为商户ID，表达式ds$-&gt;{MERCHANT_ID % 2}</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">sharding‐column</span>: <span class="hljs-string">MERCHANT_ID</span><br><span class="hljs-attr">algorithm‐expression</span>: <span class="hljs-string">ds$‐&gt;&#123;MERCHANT_ID % 2&#125; #商户ID%2</span><br></code></pre></td></tr></table></figure><p>分表规则：分片键订单表主键，表达式pay_order_$-&gt;{ID % 2}</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">sharding‐column</span>: <span class="hljs-string">ID</span><br><span class="hljs-attr">algorithm‐expression</span>: <span class="hljs-string">pay_order_$‐&gt;&#123;ID % 2&#125; #订单ID%2</span><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200807184832946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk1MDk4Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="项目用到枚举类型了吗？"><a href="#项目用到枚举类型了吗？" class="headerlink" title="项目用到枚举类型了吗？"></a>项目用到枚举类型了吗？</h4><p>项目用到了枚举类型，以下地方用到枚举：</p><p>1、支付入口 根据客户端类型判断下一步的走向，客户端类型为枚举类型。</p><p><img src="https://img-blog.csdnimg.cn/20200807184858946.png" alt="在这里插入图片描述"></p><p>2、支付状态使用枚举类型，系统对每个第三方支付系统的支付结果统一格式为系统枚举类型。</p><p><img src="https://img-blog.csdnimg.cn/2020080718491057.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk1MDk4Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>3、异常代码</p><p><img src="https://img-blog.csdnimg.cn/20200807184928433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk1MDk4Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="项目用的日志技术是什么？"><a href="#项目用的日志技术是什么？" class="headerlink" title="项目用的日志技术是什么？"></a>项目用的日志技术是什么？</h4><p>项目记录日志采用 <strong><code>log4j2</code></strong> 。</p><p>log4j2是log4j 1.x 的升级版，通过与logback对比分析，log4j2的性能更好，项目组采用log4j2。</p><p>常见的日志框架有哪些？</p><p>log4j是apache实现的一个开源日志组件</p><p>logback同样是由log4j的作者设计完成的，拥有更好的特性，是slf4j的原生实现。</p><p>log4j2是log4j 1.x和logback的改进版，采用了一些新技术使得日志的吞吐量、性能比log4j 1.x提高10倍，并解决了一些死锁的bug，而且配置更加简单灵活。</p><h4 id="一个接口出现Bug你是怎么调试的？"><a href="#一个接口出现Bug你是怎么调试的？" class="headerlink" title="一个接口出现Bug你是怎么调试的？"></a>一个接口出现Bug你是怎么调试的？</h4><p>1、接口的开发需要前端和服务端共同调试，要仔细阅读测试人员反映的bug信息，判断这个bug是服务端的bug是前端的bug。</p><p>服务接口开发完成会使用postman工具进行测试，测试没有问题再提交到Git或SVN。</p><p>前端通常在 mock环境调试接口，不依赖服务端接口，在前后端集成调试时才需要前端连上服务端集成调试。</p><p>2、找到bug的出错点就可以修改Bug。</p><p>如何找bug的出错点？</p><p>根据异常信息，通常有错误代码行的大概位置，再加断点调试及日志跟踪。</p><p>对于生产环境通常跟踪系统日志，通过日志定位bug，所以在编写代码时关键地方一定要加日志。</p><p>3、修改完成需要前后端再次连调测试，按照测试人员提交的测试流程重新进行测试，测试通过将此bug置为已解决。</p><h4 id="系统的异常是怎么处理的？"><a href="#系统的异常是怎么处理的？" class="headerlink" title="系统的异常是怎么处理的？"></a>系统的异常是怎么处理的？</h4><p>系统对异常的处理使用统一的异常处理流程。</p><p><img src="https://img-blog.csdnimg.cn/20200807185218259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk1MDk4Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>1、在服务层抛出自定义异常类型及不可预知异常类型。</p><p>上图中 <strong><code>BusinessException</code></strong> 为系统的自定义异常类型，程序中在代码显示抛出该异常，此类异常是程序员可预知的。</p><p>另一部分是系统无法预知的异常，如：数据库无法连接，服务器宕机等场景下所抛出的异常，此类异常是程序员无法预知的异常。</p><p>2、应用层接收到服务层抛出异常继续向上抛出，应用层自己也可以抛出自定义异常类型及不可预知异常类型。</p><p>3、统一异常处理器捕获到异常进行解析。</p><p>判断如果为自定义异常则直接取出错误代码及错误信息，因为程序员在抛出自定义异常时已将错误代码和异常信息指定。</p><p>如果为不可预知的异常则统一定义为99999异常代码。</p><p>4、统一异常处理器将异常信息格式为前端要求的格式响应给前端。</p><p>服务端统一将异常信息封装在下边的Json格式中返回：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span> <br><span class="hljs-attr">&quot;errCode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;000000&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;errMessage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;错误说明&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot面试题</title>
    <link href="/2022/05/07/SpringBoot%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/05/07/SpringBoot%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是-Spring-Boot？"><a href="#什么是-Spring-Boot？" class="headerlink" title="什么是 Spring Boot？"></a>什么是 Spring Boot？</h3><p>Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。</p><h3 id="Spring-Boot-有哪些优点？"><a href="#Spring-Boot-有哪些优点？" class="headerlink" title="Spring Boot 有哪些优点？"></a>Spring Boot 有哪些优点？</h3><p>Spring Boot 主要有如下优点：</p><ol><li>容易上手，提升开发效率，为 Spring 开发提供一个更快、更广泛的入门体验。</li><li>开箱即用，远离繁琐的配置。</li><li>提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。</li><li>没有代码生成，也不需要XML配置。</li><li>避免大量的 Maven 导入和各种版本冲突。</li></ol><h3 id="Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？"><a href="#Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？" class="headerlink" title="Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？"></a>Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</h3><p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：</p><p>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</p><p>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。</p><p>@ComponentScan：Spring组件扫描。</p><h3 id="什么是-JavaConfig？"><a href="#什么是-JavaConfig？" class="headerlink" title="什么是 JavaConfig？"></a>什么是 JavaConfig？</h3><p>Spring JavaConfig 是 Spring 社区的产品，它提供了配置 Spring IoC 容器的纯Java 方法。因此它有助于避免使用 XML 配置。使用 JavaConfig 的优点在于：</p><p>（1）面向对象的配置。由于配置被定义为 JavaConfig 中的类，因此用户可以充分利用 Java 中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean 方法等。</p><p>（2）减少或消除 XML 配置。基于依赖注入原则的外化配置的好处已被证明。但是，许多开发人员不希望在 XML 和 Java 之间来回切换。JavaConfig 为开发人员提供了一种纯 Java 方法来配置与 XML 配置概念相似的 Spring 容器。从技术角度来讲，只使用 JavaConfig 配置类来配置容器是可行的，但实际上很多人认为将JavaConfig 与 XML 混合匹配是理想的。</p><p>（3）类型安全和重构友好。JavaConfig 提供了一种类型安全的方法来配置 Spring容器。由于 Java 5.0 对泛型的支持，现在可以按类型而不是按名称检索 bean，不需要任何强制转换或基于字符串的查找。</p><h3 id="Spring-Boot-自动配置原理是什么？"><a href="#Spring-Boot-自动配置原理是什么？" class="headerlink" title="Spring Boot 自动配置原理是什么？"></a>Spring Boot 自动配置原理是什么？</h3><p>注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动配置的核心，</p><p>@EnableAutoConfiguration 给容器导入META-INF/spring.factories 里定义的自动配置类。</p><p>筛选有效的自动配置类。</p><p>每一个自动配置类结合对应的 xxxProperties.java 读取配置文件进行自动配置功能</p><h3 id="你如何理解-Spring-Boot-配置加载顺序？"><a href="#你如何理解-Spring-Boot-配置加载顺序？" class="headerlink" title="你如何理解 Spring Boot 配置加载顺序？"></a>你如何理解 Spring Boot 配置加载顺序？</h3><p>在 Spring Boot 里面，可以使用以下几种方式来加载配置。</p><p>1）properties文件；</p><p>2）<a href="https://so.csdn.net/so/search?q=YAML&spm=1001.2101.3001.7020">YAML</a>文件；</p><p>3）系统环境变量；</p><p>4）命令行参数；</p><p>等等……</p><h3 id="什么是-YAML？"><a href="#什么是-YAML？" class="headerlink" title="什么是 YAML？"></a>什么是 YAML？</h3><p>YAML 是一种人类可读的数据序列化语言。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。</p><h3 id="YAML-配置的优势在哪里"><a href="#YAML-配置的优势在哪里" class="headerlink" title="YAML 配置的优势在哪里 ?"></a>YAML 配置的优势在哪里 ?</h3><p>YAML 现在可以算是非常流行的一种配置文件格式了，无论是前端还是后端，都可以见到 YAML 配置。那么 YAML 配置和传统的 properties 配置相比到底有哪些优势呢？</p><ol><li>配置有序，在一些特殊的场景下，配置有序很关键</li><li>支持数组，数组中的元素可以是基本数据类型也可以是对象</li><li>简洁</li></ol><p>相比 properties 配置文件，YAML 还有一个缺点，就是不支持 @PropertySource 注解导入自定义的 YAML 配置。</p><h3 id="Spring-Boot-是否可以使用-XML-配置"><a href="#Spring-Boot-是否可以使用-XML-配置" class="headerlink" title="Spring Boot 是否可以使用 XML 配置 ?"></a>Spring Boot 是否可以使用 XML 配置 ?</h3><p>Spring Boot 推荐使用 Java 配置而非 XML 配置，但是 Spring Boot 中也可以使用 XML 配置，通过 @ImportResource 注解可以引入一个 XML 配置。</p><h3 id="spring-boot-核心配置文件是什么？bootstrap-properties-和-application-properties-有何区别"><a href="#spring-boot-核心配置文件是什么？bootstrap-properties-和-application-properties-有何区别" class="headerlink" title="spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?"></a>spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?</h3><p>单纯做 Spring Boot 开发，可能不太容易遇到 bootstrap.properties 配置文件，但是在结合 Spring Cloud 时，这个配置就会经常遇到了，特别是在需要加载一些远程配置文件的时侯。</p><p>spring boot 核心的两个配置文件：</p><ul><li>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud Config 或者 Nacos 中会用到它。且 boostrap 里面的属性不能被覆盖；</li><li>application (. yml 或者 . properties)： 由ApplicatonContext 加载，用于 spring boot 项目的自动化配置。</li></ul><h3 id="什么是-Spring-Profiles？"><a href="#什么是-Spring-Profiles？" class="headerlink" title="什么是 Spring Profiles？"></a>什么是 Spring Profiles？</h3><p>Spring Profiles 允许用户根据配置文件（dev，test，prod 等）来注册 bean。因此，当应用程序在开发中运行时，只有某些 bean 可以加载，而在 PRODUCTION中，某些其他 bean 可以加载。假设我们的要求是 Swagger 文档仅适用于 QA 环境，并且禁用所有其他文档。这可以使用配置文件来完成。Spring Boot 使得使用配置文件非常简单。</p><h3 id="如何在自定义端口上运行-Spring-Boot-应用程序？"><a href="#如何在自定义端口上运行-Spring-Boot-应用程序？" class="headerlink" title="如何在自定义端口上运行 Spring Boot 应用程序？"></a>如何在自定义端口上运行 Spring Boot 应用程序？</h3><p>为了在自定义端口上运行 Spring Boot 应用程序，您可以在application.properties 中指定端口。server.port = 8090</p><h3 id="如何实现-Spring-Boot-应用程序的安全性？"><a href="#如何实现-Spring-Boot-应用程序的安全性？" class="headerlink" title="如何实现 Spring Boot 应用程序的安全性？"></a>如何实现 Spring Boot 应用程序的安全性？</h3><p>为了实现 Spring Boot 的安全性，我们使用 spring-boot-starter-security 依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展WebSecurityConfigurerAdapter 并覆盖其方法。</p><h3 id="比较一下-Spring-Security-和-Shiro-各自的优缺点"><a href="#比较一下-Spring-Security-和-Shiro-各自的优缺点" class="headerlink" title="比较一下 Spring Security 和 Shiro 各自的优缺点 ?"></a>比较一下 Spring Security 和 Shiro 各自的优缺点 ?</h3><p>由于 Spring Boot 官方提供了大量的非常方便的开箱即用的 Starter ，包括 Spring Security 的 Starter ，使得在 Spring Boot 中使用 Spring Security 变得更加容易，甚至只需要添加一个依赖就可以保护所有的接口，所以，如果是 Spring Boot 项目，一般选择 Spring Security 。当然这只是一个建议的组合，单纯从技术上来说，无论怎么组合，都是没有问题的。Shiro 和 Spring Security 相比，主要有如下一些特点：</p><ol><li>Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级的安全管理框架</li><li>Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单</li><li>Spring Security 功能强大；Shiro 功能简单</li></ol><h3 id="Spring-Boot-中如何解决跨域问题"><a href="#Spring-Boot-中如何解决跨域问题" class="headerlink" title="Spring Boot 中如何解决跨域问题 ?"></a>Spring Boot 中如何解决跨域问题 ?</h3><p>跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请求，在 RESTful 风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过 （CORS，Cross-origin resource sharing） 来解决跨域问题。这种解决方案并非 Spring Boot 特有的，在传统的 SSM 框架中，就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CorsConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> &#123;<br>        registry.addMapping(<span class="hljs-string">&quot;/**&quot;</span>)<br>                .allowedOrigins(<span class="hljs-string">&quot;*&quot;</span>)<br>                .allowCredentials(<span class="hljs-literal">true</span>)<br>                .allowedMethods(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&quot;PUT&quot;</span>, <span class="hljs-string">&quot;DELETE&quot;</span>, <span class="hljs-string">&quot;OPTIONS&quot;</span>)<br>                .maxAge(<span class="hljs-number">3600</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>项目中前后端分离部署，所以需要解决跨域的问题。<br>我们使用cookie存放用户登录的信息，在spring拦截器进行权限控制，当权限不符合时，直接返回给用户固定的json结果。<br>当用户登录以后，正常使用；当用户退出登录状态时或者token过期时，由于拦截器和跨域的顺序有问题，出现了跨域的现象。<br>我们知道一个http请求，先走filter，到达servlet后才进行拦截器的处理，如果我们把cors放在filter里，就可以优先于权限拦截器执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CorsConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CorsFilter <span class="hljs-title function_">corsFilter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">CorsConfiguration</span> <span class="hljs-variable">corsConfiguration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorsConfiguration</span>();<br>        corsConfiguration.addAllowedOrigin(<span class="hljs-string">&quot;*&quot;</span>);<br>        corsConfiguration.addAllowedHeader(<span class="hljs-string">&quot;*&quot;</span>);<br>        corsConfiguration.addAllowedMethod(<span class="hljs-string">&quot;*&quot;</span>);<br>        corsConfiguration.setAllowCredentials(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">UrlBasedCorsConfigurationSource</span> <span class="hljs-variable">urlBasedCorsConfigurationSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UrlBasedCorsConfigurationSource</span>();<br>        urlBasedCorsConfigurationSource.registerCorsConfiguration(<span class="hljs-string">&quot;/**&quot;</span>, corsConfiguration);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorsFilter</span>(urlBasedCorsConfigurationSource);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="什么是-CSRF-攻击？"><a href="#什么是-CSRF-攻击？" class="headerlink" title="什么是 CSRF 攻击？"></a>什么是 CSRF 攻击？</h3><p>CSRF 代表跨站请求伪造。这是一种攻击，迫使最终用户在当前通过身份验证的Web 应用程序上执行不需要的操作。CSRF 攻击专门针对状态改变请求，而不是数据窃取，因为攻击者无法查看对伪造请求的响应。</p><h3 id="Spring-Boot-中的监视器是什么？"><a href="#Spring-Boot-中的监视器是什么？" class="headerlink" title="Spring Boot 中的监视器是什么？"></a>Spring Boot 中的监视器是什么？</h3><p>Spring boot actuator 是 spring 启动框架中的重要功能之一。Spring boot 监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为 HTTP URL 访问的REST 端点来检查状态。</p><h3 id="如何在-Spring-Boot-中禁用-Actuator-端点安全性？"><a href="#如何在-Spring-Boot-中禁用-Actuator-端点安全性？" class="headerlink" title="如何在 Spring Boot 中禁用 Actuator 端点安全性？"></a>如何在 Spring Boot 中禁用 Actuator 端点安全性？</h3><p>默认情况下，所有敏感的 HTTP 端点都是安全的，只有具有 ACTUATOR 角色的用户才能访问它们。安全性是使用标准的 HttpServletRequest.isUserInRole 方法实施的。 我们可以使用来禁用安全性。只有在执行机构端点在防火墙后访问时，才建议禁用安全性。</p><h3 id="我们如何监视所有-Spring-Boot-微服务？"><a href="#我们如何监视所有-Spring-Boot-微服务？" class="headerlink" title="我们如何监视所有 Spring Boot 微服务？"></a>我们如何监视所有 Spring Boot 微服务？</h3><p>Spring Boot 提供监视器端点以监控各个微服务的度量。这些端点对于获取有关应用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运行很有帮助。但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况。想象一下涉及 50 个应用程序的微服务，管理员将不得不击中所有 50 个应用程序的执行终端。为了帮助我们处理这种情况，我们将使用位于的开源项目。 它建立在 Spring Boot Actuator 之上，它提供了一个 Web UI，使我们能够可视化多个应用程序的度量。</p><h3 id="什么是-WebSockets？"><a href="#什么是-WebSockets？" class="headerlink" title="什么是 WebSockets？"></a>什么是 WebSockets？</h3><p>WebSocket 是一种计算机通信协议，通过单个 TCP 连接提供全双工通信信道。</p><p>1、WebSocket 是双向的 -使用 WebSocket 客户端或服务器可以发起消息发送。</p><p>2、WebSocket 是全双工的 -客户端和服务器通信是相互独立的。</p><p>3、单个 TCP 连接 -初始连接使用 HTTP，然后将此连接升级到基于套接字的连接。然后这个单一连接用于所有未来的通信</p><p>4、Light -与 http 相比，WebSocket 消息数据交换要轻得多。</p><h3 id="什么是-Spring-Data"><a href="#什么是-Spring-Data" class="headerlink" title="什么是 Spring Data ?"></a>什么是 Spring Data ?</h3><p>Spring Data 是 Spring 的一个子项目。用于简化数据库访问，支持NoSQL 和 关系数据存储。其主要目标是使数据库的访问变得方便快捷。Spring Data 具有如下特点：</p><p>SpringData 项目支持 NoSQL 存储：</p><ol><li>MongoDB （文档数据库）</li><li>Neo4j（图形数据库）</li><li>Redis（键/值存储）</li><li>Hbase（列族数据库）</li></ol><p>SpringData 项目所支持的关系数据存储技术：</p><ol><li>JDBC</li><li>JPA</li></ol><p>Spring Data Jpa 致力于减少数据访问层 (DAO) 的开发量. 开发者唯一要做的，就是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！Spring Data JPA 通过规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。</p><h3 id="什么是-Spring-Batch？"><a href="#什么是-Spring-Batch？" class="headerlink" title="什么是 Spring Batch？"></a>什么是 Spring Batch？</h3><p>Spring Boot Batch 提供可重用的函数，这些函数在处理大量记录时非常重要，包括日志/跟踪，事务管理，作业处理统计信息，作业重新启动，跳过和资源管理。它还提供了更先进的技术服务和功能，通过优化和分区技术，可以实现极高批量和高性能批处理作业。简单以及复杂的大批量批处理作业可以高度可扩展的方式利用框架处理重要大量的信息。</p><h3 id="什么是-FreeMarker-模板？"><a href="#什么是-FreeMarker-模板？" class="headerlink" title="什么是 FreeMarker 模板？"></a>什么是 FreeMarker 模板？</h3><p>FreeMarker 是一个基于 Java 的模板引擎，最初专注于使用 MVC 软件架构进行动态网页生成。使用 Freemarker 的主要优点是表示层和业务层的完全分离。程序员可以处理应用程序代码，而设计人员可以处理 html 页面设计。最后使用freemarker 可以将这些结合起来，给出最终的输出页面。</p><h3 id="如何集成-Spring-Boot-和-ActiveMQ？"><a href="#如何集成-Spring-Boot-和-ActiveMQ？" class="headerlink" title="如何集成 Spring Boot 和 ActiveMQ？"></a>如何集成 Spring Boot 和 ActiveMQ？</h3><p>对于集成 Spring Boot 和 ActiveMQ，我们使用依赖关系。 它只需要很少的配置，并且不需要样板代码。</p><h3 id="什么是-Apache-Kafka？"><a href="#什么是-Apache-Kafka？" class="headerlink" title="什么是 Apache Kafka？"></a>什么是 Apache Kafka？</h3><p>Apache Kafka 是一个分布式发布 - 订阅消息系统。它是一个可扩展的，容错的发布 - 订阅消息系统，它使我们能够构建分布式应用程序。这是一个 Apache 顶级项目。Kafka 适合离线和在线消息消费。</p><h3 id="什么是-Swagger？你用-Spring-Boot-实现了它吗？"><a href="#什么是-Swagger？你用-Spring-Boot-实现了它吗？" class="headerlink" title="什么是 Swagger？你用 Spring Boot 实现了它吗？"></a>什么是 Swagger？你用 Spring Boot 实现了它吗？</h3><p>Swagger 广泛用于可视化 API，使用 Swagger UI 为前端开发人员提供在线沙箱。Swagger 是用于生成 RESTful Web 服务的可视化表示的工具，规范和完整框架实现。它使文档能够以与服务器相同的速度更新。当通过 Swagger 正确定义时，消费者可以使用最少量的实现逻辑来理解远程服务并与其进行交互。因此，Swagger消除了调用服务时的猜测。</p><h3 id="前后端分离，如何维护接口文档"><a href="#前后端分离，如何维护接口文档" class="headerlink" title="前后端分离，如何维护接口文档 ?"></a>前后端分离，如何维护接口文档 ?</h3><p>前后端分离开发日益流行，大部分情况下，我们都是通过 Spring Boot 做前后端分离开发，前后端分离一定会有接口文档，不然会前后端会深深陷入到扯皮中。一个比较笨的方法就是使用 word 或者 md 来维护接口文档，但是效率太低，接口一变，所有人手上的文档都得变。在 Spring Boot 中，这个问题常见的解决方案是 Swagger ，使用 Swagger 我们可以快速生成一个接口文档网站，接口一旦发生变化，文档就会自动更新，所有开发工程师访问这一个在线网站就可以获取到最新的接口文档，非常方便。</p><h3 id="如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？Spring-Boot项目如何热部署？"><a href="#如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？Spring-Boot项目如何热部署？" class="headerlink" title="如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？"></a>如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？</h3><p>这可以使用 DEV 工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式tomcat 将重新启动。Spring Boot 有一个开发工具（DevTools）模块，它有助于提高开发人员的生产力。Java 开发人员面临的一个主要挑战是将文件更改自动部署到服务器并自动重启服务器。开发人员可以重新加载 Spring Boot 上的更改，而无需重新启动服务器。这将消除每次手动部署更改的需要。Spring Boot 在发布它的第一个版本时没有这个功能。这是开发人员最需要的功能。DevTools 模块完全满足开发人员的需求。该模块将在生产环境中被禁用。它还提供 H2 数据库控制台以更好地测试应用程序。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="您使用了哪些-starter-maven-依赖项？"><a href="#您使用了哪些-starter-maven-依赖项？" class="headerlink" title="您使用了哪些 starter maven 依赖项？"></a>您使用了哪些 starter maven 依赖项？</h3><p>使用了下面的一些依赖项</p><p>spring-boot-starter-activemq</p><p>spring-boot-starter-security</p><p>这有助于增加更少的依赖关系，并减少版本的冲突。</p><h3 id="Spring-Boot-中的-starter-到底是什么"><a href="#Spring-Boot-中的-starter-到底是什么" class="headerlink" title="Spring Boot 中的 starter 到底是什么 ?"></a>Spring Boot 中的 starter 到底是什么 ?</h3><p>首先，这个 Starter 并非什么新的技术点，基本上还是基于 Spring 已有功能来实现的。首先它提供了一个自动化配置类，一般命名为 <code>XXXAutoConfiguration</code> ，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。当然，开发者也可以自定义 Starter</p><h3 id="spring-boot-starter-parent-有什么用"><a href="#spring-boot-starter-parent-有什么用" class="headerlink" title="spring-boot-starter-parent 有什么用 ?"></a>spring-boot-starter-parent 有什么用 ?</h3><p>我们都知道，新创建一个 Spring Boot 项目，默认都是有 parent 的，这个 parent 就是 spring-boot-starter-parent ，spring-boot-starter-parent 主要有如下作用：</p><ol><li>定义了 Java 编译版本为 1.8 。</li><li>使用 UTF-8 格式编码。</li><li>继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。</li><li>执行打包操作的配置。</li><li>自动化的资源过滤。</li><li>自动化的插件配置。</li><li>针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml。</li></ol><h3 id="Spring-Boot-打成的-jar-和普通的-jar-有什么区别"><a href="#Spring-Boot-打成的-jar-和普通的-jar-有什么区别" class="headerlink" title="Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?"></a>Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?</h3><p>Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 <code>java -jar xxx.jar</code> 命令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。</p><p>Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar 包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot 打包成的可执行 jar 解压后，在<code>\BOOT-INF\classes</code>目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。</p><h3 id="运行-Spring-Boot-有哪几种方式？"><a href="#运行-Spring-Boot-有哪几种方式？" class="headerlink" title="运行 Spring Boot 有哪几种方式？"></a>运行 Spring Boot 有哪几种方式？</h3><p>1）打包用命令或者放到容器中运行</p><p>2）用 Maven/ Gradle 插件运行</p><p>3）直接执行 main 方法运行</p><h3 id="Spring-Boot-需要独立的容器运行吗？"><a href="#Spring-Boot-需要独立的容器运行吗？" class="headerlink" title="Spring Boot 需要独立的容器运行吗？"></a>Spring Boot 需要独立的容器运行吗？</h3><p>可以不需要，内置了 Tomcat/ Jetty 等容器。</p><h3 id="开启-Spring-Boot-特性有哪几种方式？"><a href="#开启-Spring-Boot-特性有哪几种方式？" class="headerlink" title="开启 Spring Boot 特性有哪几种方式？"></a>开启 Spring Boot 特性有哪几种方式？</h3><p>1）继承spring-boot-starter-parent项目</p><p>2）导入spring-boot-dependencies项目依赖</p><h3 id="如何使用-Spring-Boot-实现异常处理？"><a href="#如何使用-Spring-Boot-实现异常处理？" class="headerlink" title="如何使用 Spring Boot 实现异常处理？"></a>如何使用 Spring Boot 实现异常处理？</h3><p>Spring 提供了一种使用 ControllerAdvice 处理异常的非常有用的方法。 我们通过实现一个 ControlerAdvice 类，来处理控制器类抛出的所有异常。</p><h3 id="如何使用-Spring-Boot-实现分页和排序？"><a href="#如何使用-Spring-Boot-实现分页和排序？" class="headerlink" title="如何使用 Spring Boot 实现分页和排序？"></a>如何使用 Spring Boot 实现分页和排序？</h3><p>使用 Spring Boot 实现分页非常简单。使用 Spring Data-JPA 可以实现将可分页的传递给存储库方法。</p><h3 id="微服务中如何实现-session-共享"><a href="#微服务中如何实现-session-共享" class="headerlink" title="微服务中如何实现 session 共享 ?"></a>微服务中如何实现 session 共享 ?</h3><p>在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务器上，各自的 session 被从物理空间上隔离开了，但是经常，我们需要在不同微服务之间共享 session ，常见的方案就是 Spring Session + Redis 来实现 session 共享。将所有微服务的 session 统一保存在 Redis 上，当各个微服务对 session 有相关的读写操作时，都去操作 Redis 上的 session 。这样就实现了 session 共享，Spring Session 基于 Spring 中的代理过滤器实现，使得 session 的同步操作对开发人员而言是透明的，非常简便。</p><h3 id="Spring-Boot-中如何实现定时任务"><a href="#Spring-Boot-中如何实现定时任务" class="headerlink" title="Spring Boot 中如何实现定时任务 ?"></a>Spring Boot 中如何实现定时任务 ?</h3><p>定时任务也是一个常见的需求，Spring Boot 中对于定时任务的支持主要还是来自 Spring 框架。</p><p>在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 @Scheduled 注解，另一个则是使用第三方框架 Quartz。</p><p>使用 Spring 中的 @Scheduled 的方式主要通过 @Scheduled 注解来实现。</p><p>使用 Quartz ，则按照 Quartz 的方式，定义 Job 和 Trigger 即可。</p><p>————————————————<br>版权声明：本文为CSDN博主「ThinkWon」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/ThinkWon/article/details/104397299">https://blog.csdn.net/ThinkWon/article/details/104397299</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring面试题</title>
    <link href="/2022/05/07/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/05/07/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是spring"><a href="#什么是spring" class="headerlink" title="什么是spring?"></a>什么是spring?</h3><p>Spring是<strong>一个轻量级Java开发框架</strong>，最早有<strong>Rod Johnson</strong>创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的JavaSE/JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。</p><p>Spring最根本的使命是<strong>解决企业级应用开发的复杂性，即简化Java开发。</strong></p><p>Spring可以做很多事情，它为企业级开发提供给了丰富的功能，但是这些功能的底层都依赖于它的两个核心特性，也就是<strong>依赖注入（dependency injection，DI）和面向切面编程（aspect-oriented programming，AOP）</strong>。</p><p>为了降低Java开发的复杂性，Spring采取了以下4种关键策略</p><ul><li>基于POJO的轻量级和最小侵入性编程；</li><li>通过依赖注入和面向接口实现松耦合；</li><li>基于切面和惯例进行声明式编程；</li><li>通过切面和模板减少样板式代码。</li></ul><h3 id="Spring框架的设计目标，设计理念，和核心是什么"><a href="#Spring框架的设计目标，设计理念，和核心是什么" class="headerlink" title="Spring框架的设计目标，设计理念，和核心是什么"></a>Spring框架的设计目标，设计理念，和核心是什么</h3><p><strong>Spring设计目标</strong>：Spring为开发者提供一个一站式轻量级应用开发平台；</p><p><strong>Spring设计理念</strong>：在JavaEE开发中，支持POJO和JavaBean开发方式，使应用面向接口开发，充分支持OO（面向对象）设计方法；Spring通过IoC容器实现对象耦合关系的管理，并实现依赖反转，将对象之间的依赖关系交给IoC容器，实现解耦；</p><p><strong>Spring框架的核心</strong>：IoC容器和AOP模块。通过IoC容器管理POJO对象以及他们之间的耦合关系；通过AOP以动态非侵入的方式增强服务。</p><p>IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。</p><h3 id="Spring的优缺点是什么？"><a href="#Spring的优缺点是什么？" class="headerlink" title="Spring的优缺点是什么？"></a>Spring的优缺点是什么？</h3><p>优点</p><ul><li><p>方便解耦，简化开发</p><p>Spring就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给Spring管理。</p></li><li><p>AOP编程的支持</p><p>Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。</p></li><li><p>声明式事务的支持</p><p>只需要通过配置就可以完成对事务的管理，而无需手动编程。</p></li><li><p>方便程序的测试</p><p>Spring对Junit4支持，可以通过注解方便的测试Spring程序。</p></li><li><p>方便集成各种优秀框架</p><p>Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis等）。</p></li><li><p>降低JavaEE API的使用难度</p><p>Spring对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低。</p></li></ul><p>缺点</p><ul><li>Spring明明一个很轻量级的框架，却给人感觉大而全</li><li>Spring依赖反射，反射影响性能</li><li>使用门槛升高，入门Spring需要较长时间</li></ul><h3 id="Spring有哪些应用场景"><a href="#Spring有哪些应用场景" class="headerlink" title="Spring有哪些应用场景"></a>Spring有哪些应用场景</h3><p><strong>应用场景</strong>：JavaEE企业应用开发，包括SSH、SSM等</p><p><strong>Spring价值</strong>：</p><ul><li>Spring是非侵入式的框架，目标是使应用程序代码对框架依赖最小化；</li><li>Spring提供一个一致的编程模型，使应用直接使用POJO开发，与运行环境隔离开来；</li><li>Spring推动应用设计风格向面向对象和面向接口开发转变，提高了代码的重用性和可测试性；</li></ul><h3 id="Spring由哪些模块组成？"><a href="#Spring由哪些模块组成？" class="headerlink" title="Spring由哪些模块组成？"></a>Spring由哪些模块组成？</h3><p>Spring 总共大约有 20 个模块， 由 1300 多个不同的文件构成。 而这些组件被分别整合在<code>核心容器（Core Container） 、 AOP（Aspect Oriented Programming）和设备支持（Instrmentation） 、数据访问与集成（Data Access/Integeration） 、 Web、 消息（Messaging） 、 Test</code>等 6 个模块中。 以下是 Spring 5 的模块结构图：</p><p><img src="https://img-blog.csdnimg.cn/2019102923475419.png" alt="在这里插入图片描述"></p><ul><li>spring core：提供了框架的基本组成部分，包括控制反转（Inversion of Control，IOC）和依赖注入（Dependency Injection，DI）功能。</li><li>spring beans：提供了BeanFactory，是工厂模式的一个经典实现，Spring将管理对象称为Bean。</li><li>spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。</li><li>spring jdbc：提供了一个JDBC的抽象层，消除了烦琐的JDBC编码和数据库厂商特有的错误代码解析， 用于简化JDBC。</li><li>spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。</li><li>spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。</li><li>spring test：主要为测试提供支持的，支持使用JUnit或TestNG对Spring组件进行单元测试和集成测试。</li></ul><h3 id="Spring-框架中都用到了哪些设计模式？"><a href="#Spring-框架中都用到了哪些设计模式？" class="headerlink" title="Spring 框架中都用到了哪些设计模式？"></a>Spring 框架中都用到了哪些<a href="https://so.csdn.net/so/search?q=%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&spm=1001.2101.3001.7020">设计模式</a>？</h3><ol><li>工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；</li><li>单例模式：Bean默认为单例模式。</li><li>代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；</li><li>模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</li><li>观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。</li></ol><h3 id="详细讲解一下核心容器（spring-context应用上下文-模块"><a href="#详细讲解一下核心容器（spring-context应用上下文-模块" class="headerlink" title="详细讲解一下核心容器（spring context应用上下文) 模块"></a>详细讲解一下核心容器（spring context应用上下文) 模块</h3><p>这是基本的Spring模块，提供spring 框架的基础功能，BeanFactory 是 任何以spring为基础的应用的核心。Spring 框架建立在此模块之上，它使Spring成为一个容器。</p><p>Bean 工厂是工厂模式的一个实现，提供了控制反转功能，用来把应用的配置和依赖从真正的应用代码中分离。最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory ，它根据XML文件中的定义加载beans。该容器从XML 文件读取配置元数据并用它去创建一个完全配置的系统或应用。</p><h3 id="Spring框架中有哪些不同类型的事件"><a href="#Spring框架中有哪些不同类型的事件" class="headerlink" title="Spring框架中有哪些不同类型的事件"></a>Spring框架中有哪些不同类型的事件</h3><p>Spring 提供了以下5种标准的事件：</p><ol><li>上下文更新事件（ContextRefreshedEvent）：在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。</li><li>上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始/重新开始容器时触发该事件。</li><li>上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。</li><li>上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。</li><li>请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知。</li></ol><h3 id="Spring-应用程序有哪些不同组件？"><a href="#Spring-应用程序有哪些不同组件？" class="headerlink" title="Spring 应用程序有哪些不同组件？"></a>Spring 应用程序有哪些不同组件？</h3><p>Spring 应用一般有以下组件：</p><ul><li>接口 - 定义功能。</li><li>Bean 类 - 它包含属性，setter 和 getter 方法，函数等。</li><li>Bean 配置文件 - 包含类的信息以及如何配置它们。</li><li>Spring 面向切面编程（AOP） - 提供面向切面编程的功能。</li><li>用户程序 - 它使用接口。</li></ul><h3 id="使用-Spring-有哪些方式？"><a href="#使用-Spring-有哪些方式？" class="headerlink" title="使用 Spring 有哪些方式？"></a>使用 Spring 有哪些方式？</h3><p>使用 Spring 有以下方式：</p><ul><li>作为一个成熟的 Spring Web 应用程序。</li><li>作为第三方 Web 框架，使用 Spring Frameworks 中间层。</li><li>作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。</li><li>用于远程使用。</li></ul><h3 id="什么是Spring-IOC-容器？"><a href="#什么是Spring-IOC-容器？" class="headerlink" title="什么是Spring IOC 容器？"></a>什么是Spring IOC 容器？</h3><p>控制反转即IoC (Inversion of Control)，它把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。</p><p>Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</p><h3 id="控制反转-IoC-有什么作用"><a href="#控制反转-IoC-有什么作用" class="headerlink" title="控制反转(IoC)有什么作用"></a>控制反转(IoC)有什么作用</h3><ul><li>管理对象的创建和依赖关系的维护。对象的创建并不是一件简单的事，在对象关系比较复杂时，如果依赖关系需要程序猿来维护的话，那是相当头疼的</li><li>解耦，由容器去维护具体的对象</li><li>托管了类的产生过程，比如我们需要在类的产生过程中做一些处理，最直接的例子就是代理，如果有容器程序可以把这部分处理交给容器，应用程序则无需去关心类是如何完成代理的</li></ul><h3 id="IOC的优点是什么？"><a href="#IOC的优点是什么？" class="headerlink" title="IOC的优点是什么？"></a>IOC的优点是什么？</h3><ul><li>IOC 或 依赖注入把应用的代码量降到最低。</li><li>它使应用容易测试，单元测试不再需要单例和JNDI查找机制。</li><li>最小的代价和最小的侵入性使松散耦合得以实现。</li><li>IOC容器支持加载服务时的饿汉式初始化和懒加载。</li></ul><h3 id="Spring-IoC-的实现机制"><a href="#Spring-IoC-的实现机制" class="headerlink" title="Spring IoC 的实现机制"></a>Spring IoC 的实现机制</h3><p>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Fruit</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br> &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Fruit</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Apple&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Orange</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Fruit</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Orange&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Fruit <span class="hljs-title function_">getInstance</span><span class="hljs-params">(String ClassName)</span> &#123;<br>        Fruit f=<span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            f=(Fruit)Class.forName(ClassName).newInstance();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> f;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] a)</span> &#123;<br>        Fruit f=Factory.getInstance(<span class="hljs-string">&quot;io.github.dunwu.spring.Apple&quot;</span>);<br>        <span class="hljs-keyword">if</span>(f!=<span class="hljs-literal">null</span>)&#123;<br>            f.eat();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Spring-的-IoC支持哪些功能"><a href="#Spring-的-IoC支持哪些功能" class="headerlink" title="Spring 的 IoC支持哪些功能"></a>Spring 的 IoC支持哪些功能</h3><p>Spring 的 IoC 设计支持以下功能：</p><ul><li>依赖注入</li><li>依赖检查</li><li>自动装配</li><li>支持集合</li><li>指定初始化方法和销毁方法</li><li>支持回调某些方法（但是需要实现 Spring 接口，略有侵入）</li></ul><p>其中，最重要的就是依赖注入，从 XML 的配置上说，即 ref 标签。对应 Spring RuntimeBeanReference 对象。</p><p>对于 IoC 来说，最重要的就是容器。容器管理着 Bean 的生命周期，控制着 Bean 的依赖注入。</p><h3 id="BeanFactory-和-ApplicationContext有什么区别？"><a href="#BeanFactory-和-ApplicationContext有什么区别？" class="headerlink" title="BeanFactory 和 ApplicationContext有什么区别？"></a>BeanFactory 和 ApplicationContext有什么区别？</h3><p>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。</p><p>依赖关系</p><p>BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。</p><p>ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：</p><ul><li>继承MessageSource，因此支持国际化。</li><li>统一的资源文件访问方式。</li><li>提供在监听器中注册bean的事件。</li><li>同时加载多个配置文件。</li><li>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</li></ul><p>加载方式</p><p>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</p><p>ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</p><p>相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p><p>创建方式</p><p>BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</p><p>注册方式</p><p>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p><h3 id="Spring-如何设计容器的，BeanFactory和ApplicationContext的关系详解"><a href="#Spring-如何设计容器的，BeanFactory和ApplicationContext的关系详解" class="headerlink" title="Spring 如何设计容器的，BeanFactory和ApplicationContext的关系详解"></a>Spring 如何设计容器的，BeanFactory和ApplicationContext的关系详解</h3><p>Spring 作者 Rod Johnson 设计了两个接口用以表示容器。</p><ul><li>BeanFactory</li><li>ApplicationContext</li></ul><p>BeanFactory 简单粗暴，可以理解为就是个 HashMap，Key 是 BeanName，Value 是 Bean 实例。通常只提供注册（put），获取（get）这两个功能。我们可以称之为 <strong>“低级容器”</strong>。</p><p>ApplicationContext 可以称之为 <strong>“高级容器”</strong>。因为他比 BeanFactory 多了更多的功能。他继承了多个接口。因此具备了更多的功能。例如资源的获取，支持多种消息（例如 JSP tag 的支持），对 BeanFactory 多了工具级别的支持等待。所以你看他的名字，已经不是 BeanFactory 之类的工厂了，而是 “应用上下文”， 代表着整个大容器的所有功能。该接口定义了一个 refresh 方法，此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载/刷新所有的 bean。</p><p>当然，除了这两个大接口，还有其他的辅助接口，这里就不介绍他们了。</p><p>BeanFactory和ApplicationContext的关系</p><p>为了更直观的展示 “低级容器” 和 “高级容器” 的关系，这里通过常用的 ClassPathXmlApplicationContext 类来展示整个容器的层级 UML 关系。</p><p><img src="https://img-blog.csdnimg.cn/20191105111441363.png" alt="img"></p><p>有点复杂？ 先不要慌，我来解释一下。</p><p>最上面的是 BeanFactory，下面的 3 个绿色的，都是功能扩展接口，这里就不展开讲。</p><p>看下面的隶属 ApplicationContext 粉红色的 “高级容器”，依赖着 “低级容器”，这里说的是依赖，不是继承哦。他依赖着 “低级容器” 的 getBean 功能。而高级容器有更多的功能：支持不同的信息源头，可以访问文件资源，支持应用事件（Observer 模式）。</p><p>通常用户看到的就是 “高级容器”。 但 BeanFactory 也非常够用啦！</p><p>左边灰色区域的是 “低级容器”， 只负载加载 Bean，获取 Bean。容器其他的高级功能是没有的。例如上图画的 refresh 刷新 Bean 工厂所有配置，生命周期事件回调等。</p><p>小结</p><p>说了这么多，不知道你有没有理解Spring IoC？ 这里小结一下：IoC 在 Spring 里，只需要低级容器就可以实现，2 个步骤：</p><ol><li>加载配置文件，解析成 BeanDefinition 放在 Map 里。</li><li>调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。</li></ol><p>上面就是 Spring 低级容器（BeanFactory）的 IoC。</p><p>至于高级容器 ApplicationContext，他包含了低级容器的功能，当他执行 refresh 模板方法的时候，将刷新整个容器的 Bean。同时其作为高级容器，包含了太多的功能。一句话，他不仅仅是 IoC。他支持不同信息源头，支持 BeanFactory 工具类，支持层级容器，支持访问文件资源，支持事件发布通知，支持接口回调等等。</p><h3 id="ApplicationContext通常的实现是什么？"><a href="#ApplicationContext通常的实现是什么？" class="headerlink" title="ApplicationContext通常的实现是什么？"></a>ApplicationContext通常的实现是什么？</h3><p><strong>FileSystemXmlApplicationContext ：</strong>此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。</p><p><strong>ClassPathXmlApplicationContext：</strong>此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。</p><p><strong>WebXmlApplicationContext：</strong>此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。</p><h3 id="什么是Spring的依赖注入？"><a href="#什么是Spring的依赖注入？" class="headerlink" title="什么是Spring的依赖注入？"></a>什么是Spring的依赖注入？</h3><p>控制反转IoC是一个很大的概念，可以用不同的方式来实现。其主要实现方式有两种：依赖注入和依赖查找</p><p>依赖注入：相对于IoC而言，依赖注入(DI)更加准确地描述了IoC的设计理念。所谓依赖注入（Dependency Injection），即组件之间的依赖关系由容器在应用系统运行期来决定，也就是由容器动态地将某种依赖关系的目标对象实例注入到应用系统中的各个关联的组件之中。组件不做定位查询，只提供普通的Java方法让容器去决定依赖关系。</p><h3 id="依赖注入的基本原则"><a href="#依赖注入的基本原则" class="headerlink" title="依赖注入的基本原则"></a>依赖注入的基本原则</h3><p>依赖注入的基本原则是：应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由IoC容器负责，“查找资源”的逻辑应该从应用组件的代码中抽取出来，交给IoC容器负责。容器全权负责组件的装配，它会把符合依赖关系的对象通过属性（JavaBean中的setter）或者是构造器传递给需要的对象。</p><h3 id="依赖注入有什么优势"><a href="#依赖注入有什么优势" class="headerlink" title="依赖注入有什么优势"></a>依赖注入有什么优势</h3><p>依赖注入之所以更流行是因为它是一种更可取的方式：让容器全权负责依赖查询，受管组件只需要暴露JavaBean的setter方法或者带参数的构造器或者接口，使容器可以在初始化时组装对象的依赖关系。其与依赖查找方式相比，主要优势为：</p><ul><li>查找定位操作与应用代码完全无关。</li><li>不依赖于容器的API，可以很容易地在任何容器以外使用应用对象。</li><li>不需要特殊的接口，绝大多数对象可以做到完全不必依赖容器。</li></ul><h3 id="有哪些不同类型的依赖注入实现方式？"><a href="#有哪些不同类型的依赖注入实现方式？" class="headerlink" title="有哪些不同类型的依赖注入实现方式？"></a>有哪些不同类型的依赖注入实现方式？</h3><p>依赖注入是时下最流行的IoC实现方式，依赖注入分为接口注入（Interface Injection），Setter方法注入（Setter Injection）和构造器注入（Constructor Injection）三种方式。其中接口注入由于在灵活性和易用性比较差，现在从Spring4开始已被废弃。</p><p><strong>构造器依赖注入</strong>：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</p><p><strong>Setter方法注入</strong>：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。</p><h3 id="构造器依赖注入和-Setter方法注入的区别"><a href="#构造器依赖注入和-Setter方法注入的区别" class="headerlink" title="构造器依赖注入和 Setter方法注入的区别"></a>构造器依赖注入和 Setter方法注入的区别</h3><table><thead><tr><th><strong>构造函数注入</strong></th><th><strong>setter</strong> <strong>注入</strong></th></tr></thead><tbody><tr><td>没有部分注入</td><td>有部分注入</td></tr><tr><td>不会覆盖 setter 属性</td><td>会覆盖 setter 属性</td></tr><tr><td>任意修改都会创建一个新实例</td><td>任意修改不会创建一个新实例</td></tr><tr><td>适用于设置很多属性</td><td>适用于设置少量属性</td></tr></tbody></table><p>两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。</p><h3 id="什么是Spring-beans？"><a href="#什么是Spring-beans？" class="headerlink" title="什么是Spring beans？"></a>什么是Spring beans？</h3><p>Spring beans 是那些形成Spring应用的主干的java对象。它们被Spring IOC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如，以XML文件中 的形式定义。</p><h3 id="一个-Spring-Bean-定义-包含什么？"><a href="#一个-Spring-Bean-定义-包含什么？" class="headerlink" title="一个 Spring Bean 定义 包含什么？"></a>一个 Spring Bean 定义 包含什么？</h3><p>一个Spring Bean 的定义包含容器必知的所有配置元数据，包括如何创建一个bean，它的生命周期详情及它的依赖。</p><h3 id="如何给Spring-容器提供配置元数据？Spring有几种配置方式"><a href="#如何给Spring-容器提供配置元数据？Spring有几种配置方式" class="headerlink" title="如何给Spring 容器提供配置元数据？Spring有几种配置方式"></a>如何给Spring 容器提供配置元数据？Spring有几种配置方式</h3><p>这里有三种重要的方法给Spring 容器提供配置元数据。</p><ul><li>XML配置文件。</li><li>基于注解的配置。</li><li>基于java的配置。</li></ul><h3 id="Spring配置文件包含了哪些信息"><a href="#Spring配置文件包含了哪些信息" class="headerlink" title="Spring配置文件包含了哪些信息"></a>Spring配置文件包含了哪些信息</h3><p>Spring配置文件是个XML 文件，这个文件包含了类信息，描述了如何配置它们，以及如何相互调用。</p><h3 id="Spring基于xml注入bean的几种方式"><a href="#Spring基于xml注入bean的几种方式" class="headerlink" title="Spring基于xml注入bean的几种方式"></a>Spring基于xml注入bean的几种方式</h3><ol><li>Set方法注入；</li><li>构造器注入：①通过index设置参数的位置；②通过type设置参数类型；</li><li>静态工厂注入；</li><li>实例工厂；</li></ol><h3 id="你怎样定义类的作用域？"><a href="#你怎样定义类的作用域？" class="headerlink" title="你怎样定义类的作用域？"></a>你怎样定义类的作用域？</h3><p>当定义一个 在Spring里，我们还能给这个bean声明一个作用域。它可以通过bean 定义中的scope属性来定义。如，当Spring要在需要的时候每次生产一个新的bean实例，bean的scope属性被指定为prototype。另一方面，一个bean每次使用的时候必须返回同一个实例，这个bean的scope 属性 必须设为 singleton。</p><h3 id="解释Spring支持的几种bean的作用域"><a href="#解释Spring支持的几种bean的作用域" class="headerlink" title="解释Spring支持的几种bean的作用域"></a>解释Spring支持的几种bean的作用域</h3><p>Spring框架支持以下五种bean的作用域：</p><ul><li><strong>singleton :</strong> bean在每个Spring ioc 容器中只有一个实例。</li><li><strong>prototype</strong>：一个bean的定义可以有多个实例。</li><li><strong>request</strong>：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。</li><li><strong>session</strong>：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li><li><strong>global-session</strong>：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li></ul><p><strong>注意：</strong> 缺省的Spring bean 的作用域是Singleton。使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p><h3 id="Spring框架中的单例bean是线程安全的吗？"><a href="#Spring框架中的单例bean是线程安全的吗？" class="headerlink" title="Spring框架中的单例bean是线程安全的吗？"></a>Spring框架中的单例bean是线程安全的吗？</h3><p>不是，Spring框架中的单例bean不是线程安全的。</p><p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</p><p>实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。</p><ul><li>有状态就是有数据存储功能。</li><li>无状态就是不会保存数据。</li></ul><h3 id="Spring如何处理线程并发问题？"><a href="#Spring如何处理线程并发问题？" class="headerlink" title="Spring如何处理线程并发问题？"></a>Spring如何处理线程并发问题？</h3><p>在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域，因为Spring对一些Bean中非线程安全状态采用ThreadLocal进行处理，解决线程安全问题。</p><p>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。</p><p>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p><h3 id="解释Spring框架中bean的生命周期"><a href="#解释Spring框架中bean的生命周期" class="headerlink" title="解释Spring框架中bean的生命周期"></a>解释Spring框架中bean的生命周期</h3><p>在传统的Java应用中，bean的生命周期很简单。使用Java关键字new进行bean实例化，然后该bean就可以使用了。一旦该bean不再被使用，则由Java自动进行垃圾回收。相比之下，Spring容器中的bean的生命周期就显得相对复杂多了。正确理解Spring bean的生命周期非常重要，因为你或许要利用Spring提供的扩展点来自定义bean的创建过程。下图展示了bean装载到Spring应用上下文中的一个典型的生命周期过程。<br><img src="https://img-blog.csdnimg.cn/201911012343410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt="img"></p><p>bean在Spring容器中从创建到销毁经历了若干阶段，每一阶段都可以针对Spring如何管理bean进行个性化定制。</p><p>正如你所见，在bean准备就绪之前，bean工厂执行了若干启动步骤。</p><p>我们对上图进行详细描述：</p><p>Spring对bean进行实例化；</p><p>Spring将值和bean的引用注入到bean对应的属性中；</p><p>如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBean-Name()方法；</p><p>如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；</p><p>如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；</p><p>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessBeforeInitialization()方法；</p><p>如果bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似地，如果bean使用initmethod声明了初始化方法，该方法也会被调用；</p><p>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法；</p><p>此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</p><p>如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。</p><p>现在你已经了解了如何创建和加载一个Spring容器。但是一个空的容器并没有太大的价值，在你把东西放进去之前，它里面什么都没有。为了从Spring的DI(依赖注入)中受益，我们必须将应用对象装配进Spring容器中。</p><h3 id="哪些是重要的bean生命周期方法？-你能重载它们吗？"><a href="#哪些是重要的bean生命周期方法？-你能重载它们吗？" class="headerlink" title="哪些是重要的bean生命周期方法？ 你能重载它们吗？"></a>哪些是重要的bean生命周期方法？ 你能重载它们吗？</h3><p>有两个重要的bean 生命周期方法，第一个是setup ， 它是在容器加载bean的时候被调用。第二个方法是 teardown 它是在容器卸载类的时候被调用。</p><p>bean 标签有两个重要的属性（init-method和destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct和@PreDestroy）。</p><h3 id="什么是Spring的内部bean？什么是Spring-inner-beans？"><a href="#什么是Spring的内部bean？什么是Spring-inner-beans？" class="headerlink" title="什么是Spring的内部bean？什么是Spring inner beans？"></a>什么是Spring的内部bean？什么是Spring inner beans？</h3><p>在Spring框架中，当一个bean仅被用作另一个bean的属性时，它能被声明为一个内部bean。内部bean可以用setter注入“属性”和构造方法注入“构造参数”的方式来实现，内部bean通常是匿名的，它们的Scope一般是prototype。</p><h3 id="在-Spring中如何注入一个java集合？"><a href="#在-Spring中如何注入一个java集合？" class="headerlink" title="在 Spring中如何注入一个java集合？"></a>在 Spring中如何注入一个java集合？</h3><p>Spring提供以下几种集合的配置元素：</p><p>类型用于注入一列值，允许有相同的值。</p><p>类型用于注入一组值，不允许有相同的值。</p><p>类型用于注入一组键值对，键和值都可以为任意类型。</p><p>类型用于注入一组键值对，键和值都只能为String类型。</p><h3 id="什么是bean装配？"><a href="#什么是bean装配？" class="headerlink" title="什么是bean装配？"></a>什么是bean装配？</h3><p>装配，或bean 装配是指在Spring 容器中把bean组装到一起，前提是容器需要知道bean的依赖关系，如何通过依赖注入来把它们装配到一起。</p><h3 id="什么是bean的自动装配？"><a href="#什么是bean的自动装配？" class="headerlink" title="什么是bean的自动装配？"></a>什么是bean的自动装配？</h3><p>在Spring框架中，在配置文件中设定bean的依赖关系是一个很好的机制，Spring 容器能够自动装配相互合作的bean，这意味着容器不需要和配置，能通过Bean工厂自动处理bean之间的协作。这意味着 Spring可以通过向Bean Factory中注入的方式自动搞定bean之间的依赖关系。自动装配可以设置在每个bean上，也可以设定在特定的bean上。</p><h3 id="解释不同方式的自动装配，spring-自动装配-bean-有哪些方式？"><a href="#解释不同方式的自动装配，spring-自动装配-bean-有哪些方式？" class="headerlink" title="解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？"></a>解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？</h3><p>在spring中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象，使用autowire来配置自动装载模式。</p><p>在Spring框架xml配置中共有5种自动装配：</p><ul><li>no：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配bean。</li><li>byName：通过bean的名称进行自动装配，如果一个bean的 property 与另一bean 的name 相同，就进行自动装配。</li><li>byType：通过参数的数据类型进行自动装配。</li><li>constructor：利用构造函数进行装配，并且构造函数的参数通过byType进行装配。</li><li>autodetect：自动探测，如果有构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。</li></ul><h3 id="使用-Autowired注解自动装配的过程是怎样的？"><a href="#使用-Autowired注解自动装配的过程是怎样的？" class="headerlink" title="使用@Autowired注解自动装配的过程是怎样的？"></a>使用@Autowired注解自动装配的过程是怎样的？</h3><p>使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，&lt;context:annotation-config /&gt;。</p><p>在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：</p><ul><li><p>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</p></li><li><p>如果查询的结果不止一个，那么@Autowired会根据名称来查找；</p></li><li><p>如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required=false。</p></li></ul><h3 id="自动装配有哪些局限性？"><a href="#自动装配有哪些局限性？" class="headerlink" title="自动装配有哪些局限性？"></a>自动装配有哪些局限性？</h3><p>自动装配的局限性是：</p><p><strong>重写</strong>：你仍需用 和 配置来定义依赖，意味着总要重写自动装配。</p><p><strong>基本数据类型</strong>：你不能自动装配简单的属性，如基本数据类型，String字符串，和类。</p><p><strong>模糊特性</strong>：自动装配不如显式装配精确，如果有可能，建议使用显式装配。</p><h3 id="你可以在Spring中注入一个null-和一个空字符串吗？"><a href="#你可以在Spring中注入一个null-和一个空字符串吗？" class="headerlink" title="你可以在Spring中注入一个null 和一个空字符串吗？"></a>你可以在Spring中注入一个null 和一个空字符串吗？</h3><p>可以。</p><h3 id="什么是基于Java的Spring注解配置-给一些注解的例子"><a href="#什么是基于Java的Spring注解配置-给一些注解的例子" class="headerlink" title="什么是基于Java的Spring注解配置? 给一些注解的例子"></a>什么是基于Java的Spring注解配置? 给一些注解的例子</h3><p>基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。</p><p>以@Configuration 注解为例，它用来标记类可以当做一个bean的定义，被Spring IOC容器使用。</p><p>另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> StudentBean <span class="hljs-title function_">myStudent</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StudentBean</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="怎样开启注解装配？"><a href="#怎样开启注解装配？" class="headerlink" title="怎样开启注解装配？"></a>怎样开启注解装配？</h3><p>注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在Spring配置文件中配置 <code>&lt;context:annotation-config/&gt;</code>元素。</p><h3 id="Component-Controller-Repository-Service-有何区别？"><a href="#Component-Controller-Repository-Service-有何区别？" class="headerlink" title="@Component, @Controller, @Repository, @Service 有何区别？"></a>@Component, @Controller, @Repository, @Service 有何区别？</h3><p>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</p><p>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</p><p>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</p><p>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</p><h3 id="Required-注解有什么作用"><a href="#Required-注解有什么作用" class="headerlink" title="@Required 注解有什么作用"></a>@Required 注解有什么作用</h3><p>这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@Required</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> string <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Autowired-注解有什么作用"><a href="#Autowired-注解有什么作用" class="headerlink" title="@Autowired 注解有什么作用"></a>@Autowired 注解有什么作用</h3><p>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。@Autowired 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required一样，修饰setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> string <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Autowired和-Resource之间的区别"><a href="#Autowired和-Resource之间的区别" class="headerlink" title="@Autowired和@Resource之间的区别"></a>@Autowired和@Resource之间的区别</h3><p>@Autowired可用于：构造函数、成员变量、Setter方法</p><p>@Autowired和@Resource之间的区别</p><ul><li><p>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。</p></li><li><p>@Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。</p></li></ul><h3 id="Qualifier-注解有什么作用"><a href="#Qualifier-注解有什么作用" class="headerlink" title="@Qualifier 注解有什么作用"></a>@Qualifier 注解有什么作用</h3><p>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。</p><h3 id="RequestMapping-注解有什么用？"><a href="#RequestMapping-注解有什么用？" class="headerlink" title="@RequestMapping 注解有什么用？"></a>@RequestMapping 注解有什么用？</h3><p>@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注释可应用于两个级别：</p><ul><li>类级别：映射请求的 URL</li><li>方法级别：映射 URL 以及 HTTP 请求方法</li></ul><h3 id="解释对象-关系映射集成模块"><a href="#解释对象-关系映射集成模块" class="headerlink" title="解释对象/关系映射集成模块"></a>解释对象/关系映射集成模块</h3><p>Spring 通过提供ORM模块，支持我们在直接JDBC之上使用一个对象/关系映射映射(ORM)工具，Spring 支持集成主流的ORM框架，如Hiberate，JDO和 iBATIS，JPA，TopLink，JDO，OJB 。Spring的事务管理同样支持以上所有ORM框架及JDBC。</p><h3 id="在Spring框架中如何更有效地使用JDBC？"><a href="#在Spring框架中如何更有效地使用JDBC？" class="headerlink" title="在Spring框架中如何更有效地使用JDBC？"></a>在Spring框架中如何更有效地使用JDBC？</h3><p>使用Spring JDBC 框架，资源管理和错误处理的代价都会被减轻。所以开发者只需写statements 和 queries从数据存取数据，JDBC也可以在Spring框架提供的模板类的帮助下更有效地被使用，这个模板叫JdbcTemplate</p><h3 id="解释JDBC抽象和DAO模块"><a href="#解释JDBC抽象和DAO模块" class="headerlink" title="解释JDBC抽象和DAO模块"></a>解释JDBC抽象和DAO模块</h3><p>通过使用JDBC抽象和DAO模块，保证数据库代码的简洁，并能避免数据库资源错误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一的异常访问层。它还利用Spring的AOP 模块给Spring应用中的对象提供事务管理服务。</p><h3 id="Spring-DAO-有什么用？"><a href="#Spring-DAO-有什么用？" class="headerlink" title="Spring DAO 有什么用？"></a>Spring DAO 有什么用？</h3><p>Spring DAO（数据访问对象） 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。</p><h3 id="Spring-JDBC-API-中存在哪些类？"><a href="#Spring-JDBC-API-中存在哪些类？" class="headerlink" title="Spring JDBC API 中存在哪些类？"></a>Spring JDBC API 中存在哪些类？</h3><p>JdbcTemplate</p><p>SimpleJdbcTemplate</p><p>NamedParameterJdbcTemplate</p><p>SimpleJdbcInsert</p><p>SimpleJdbcCall</p><h3 id="JdbcTemplate是什么"><a href="#JdbcTemplate是什么" class="headerlink" title="JdbcTemplate是什么"></a>JdbcTemplate是什么</h3><p>JdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</p><h3 id="使用Spring通过什么方式访问Hibernate？使用-Spring-访问-Hibernate-的方法有哪些？"><a href="#使用Spring通过什么方式访问Hibernate？使用-Spring-访问-Hibernate-的方法有哪些？" class="headerlink" title="使用Spring通过什么方式访问Hibernate？使用 Spring 访问 Hibernate 的方法有哪些？"></a>使用Spring通过什么方式访问Hibernate？使用 Spring 访问 Hibernate 的方法有哪些？</h3><p>在Spring中有两种方式访问Hibernate：</p><ul><li>使用 Hibernate 模板和回调进行控制反转</li><li>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点</li></ul><h3 id="如何通过HibernateDaoSupport将Spring和Hibernate结合起来？"><a href="#如何通过HibernateDaoSupport将Spring和Hibernate结合起来？" class="headerlink" title="如何通过HibernateDaoSupport将Spring和Hibernate结合起来？"></a>如何通过HibernateDaoSupport将Spring和Hibernate结合起来？</h3><p>用Spring的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：</p><ul><li>配置the Hibernate SessionFactory</li><li>继承HibernateDaoSupport实现一个DAO</li><li>在AOP支持的事务中装配</li></ul><h3 id="Spring支持的事务管理类型，-spring-事务实现方式有哪些？"><a href="#Spring支持的事务管理类型，-spring-事务实现方式有哪些？" class="headerlink" title="Spring支持的事务管理类型， spring 事务实现方式有哪些？"></a>Spring支持的事务管理类型， spring 事务实现方式有哪些？</h3><p>Spring支持两种类型的事务管理：</p><p><strong>编程式事务管理</strong>：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。</p><p><strong>声明式事务管理</strong>：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。</p><h3 id="Spring事务的实现方式和实现原理"><a href="#Spring事务的实现方式和实现原理" class="headerlink" title="Spring事务的实现方式和实现原理"></a>Spring事务的实现方式和实现原理</h3><p>Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的。</p><h3 id="说一下Spring的事务传播行为"><a href="#说一下Spring的事务传播行为" class="headerlink" title="说一下Spring的事务传播行为"></a>说一下Spring的事务传播行为</h3><p>spring事务的传播行为说的是，当多个事务同时存在的时候，spring如何处理这些事务的行为。</p><blockquote><p>① PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</p><p>② PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</p><p>③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p><p>④ PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</p><p>⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p><p>⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</p><p>⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</p></blockquote><h3 id="说一下-spring-的事务隔离？"><a href="#说一下-spring-的事务隔离？" class="headerlink" title="说一下 spring 的事务隔离？"></a>说一下 spring 的事务隔离？</h3><p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p><ol><li>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</li><li>ISOLATION_READ_UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；</li><li>ISOLATION_READ_COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；</li><li>ISOLATION_REPEATABLE_READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</li><li>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</li></ol><p><strong>脏读</strong> ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p><p><strong>不可重复读</strong> ：是指在一个事务内，多次读同一数据。</p><p><strong>幻读</strong> ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p><h3 id="Spring框架的事务管理有哪些优点？"><a href="#Spring框架的事务管理有哪些优点？" class="headerlink" title="Spring框架的事务管理有哪些优点？"></a>Spring框架的事务管理有哪些优点？</h3><ul><li>为不同的事务API 如 JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。</li><li>为编程式事务管理提供了一套简单的API而不是一些复杂的事务API</li><li>支持声明式事务管理。</li><li>和Spring各种数据访问抽象层很好得集成。</li></ul><h3 id="你更倾向用那种事务管理类型？"><a href="#你更倾向用那种事务管理类型？" class="headerlink" title="你更倾向用那种事务管理类型？"></a>你更倾向用那种事务管理类型？</h3><p>大多数Spring框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</p><h3 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h3><p>OOP(Object-Oriented Programming)面向对象编程，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p><p>AOP(Aspect-Oriented Programming)，一般称为面向切面编程，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等。</p><h3 id="Spring-AOP-and-AspectJ-AOP-有什么区别？AOP-有哪些实现方式？"><a href="#Spring-AOP-and-AspectJ-AOP-有什么区别？AOP-有哪些实现方式？" class="headerlink" title="Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？"></a>Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？</h3><p>AOP实现的关键在于 代理模式，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。</p><p>（1）AspectJ是静态代理的增强，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。</p><p>（2）Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p><h3 id="JDK动态代理和CGLIB动态代理的区别"><a href="#JDK动态代理和CGLIB动态代理的区别" class="headerlink" title="JDK动态代理和CGLIB动态代理的区别"></a>JDK动态代理和CGLIB动态代理的区别</h3><p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：</p><ul><li>JDK动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例, 生成目标类的代理对象。</li><li>如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</li></ul><p>静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。</p><blockquote><p>InvocationHandler 的 invoke(Object proxy,Method method,Object[] args)：proxy是最终生成的代理实例; method 是被代理目标实例的某个具体方法; args 是被代理目标实例某个方法的具体入参, 在方法反射调用时使用。</p></blockquote><h3 id="如何理解-Spring-中的代理？"><a href="#如何理解-Spring-中的代理？" class="headerlink" title="如何理解 Spring 中的代理？"></a>如何理解 Spring 中的代理？</h3><p>将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。</p><p>Advice + Target Object = Proxy</p><h3 id="解释一下Spring-AOP里面的几个名词"><a href="#解释一下Spring-AOP里面的几个名词" class="headerlink" title="解释一下Spring AOP里面的几个名词"></a>解释一下Spring AOP里面的几个名词</h3><p>（1）切面（Aspect）：切面是通知和切点的结合。通知和切点共同定义了切面的全部内容。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。</p><p>（2）连接点（Join point）：指方法，在Spring AOP中，一个连接点 总是 代表一个方法的执行。 应用可能有数以千计的时机应用通知。这些时机被称为连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p><p>（3）通知（Advice）：在AOP术语中，切面的工作被称为通知。</p><p>（4）切入点（Pointcut）：切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。</p><p>（5）引入（Introduction）：引入允许我们向现有类添加新方法或属性。</p><p>（6）目标对象（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。它通常是一个代理对象。也有人把它叫做 被通知（adviced） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。</p><p>（7）织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程。在目标对象的生命周期里有多少个点可以进行织入：</p><ul><li>编译期：切面在目标类编译时被织入。AspectJ的织入编译器是以这种方式织入切面的。</li><li>类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入就支持以这种方式织入切面。</li><li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。</li></ul><h3 id="Spring在运行时通知对象"><a href="#Spring在运行时通知对象" class="headerlink" title="Spring在运行时通知对象"></a>Spring在运行时通知对象</h3><p>通过在代理类中包裹切面，Spring在运行期把切面织入到Spring管理的bean中。代理封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标bean。当代理拦截到方法调用时，在调用目标bean方法之前，会执行切面逻辑。</p><p>直到应用需要被代理的bean时，Spring才创建代理对象。如果使用的是ApplicationContext的话，在ApplicationContext从BeanFactory中加载所有bean的时候，Spring才会创建被代理的对象。因为Spring运行时才创建代理对象，所以我们不需要特殊的编译器来织入SpringAOP的切面。</p><h3 id="Spring只支持方法级别的连接点"><a href="#Spring只支持方法级别的连接点" class="headerlink" title="Spring只支持方法级别的连接点"></a>Spring只支持方法级别的连接点</h3><p>因为Spring基于动态代理，所以Spring只支持方法连接点。Spring缺少对字段连接点的支持，而且它不支持构造器连接点。方法之外的连接点拦截功能，我们可以利用Aspect来补充。</p><h3 id="在Spring-AOP-中，关注点和横切关注的区别是什么？在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处"><a href="#在Spring-AOP-中，关注点和横切关注的区别是什么？在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处" class="headerlink" title="在Spring AOP 中，关注点和横切关注的区别是什么？在 spring aop 中 concern 和 cross-cutting concern 的不同之处"></a>在Spring AOP 中，关注点和横切关注的区别是什么？在 spring aop 中 concern 和 cross-cutting concern 的不同之处</h3><p>关注点（concern）是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。</p><p>横切关注点（cross-cutting concern）是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</p><h3 id="Spring通知有哪些类型？"><a href="#Spring通知有哪些类型？" class="headerlink" title="Spring通知有哪些类型？"></a>Spring通知有哪些类型？</h3><p>在AOP术语中，切面的工作被称为通知，实际上是程序执行时要通过SpringAOP框架触发的代码段。</p><p>Spring切面可以应用5种类型的通知：</p><ol><li>前置通知（Before）：在目标方法被调用之前调用通知功能；</li><li>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li><li>返回通知（After-returning ）：在目标方法成功执行之后调用通知；</li><li>异常通知（After-throwing）：在目标方法抛出异常后调用通知；</li><li>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</li></ol><blockquote><p>同一个aspect，不同advice的执行顺序：</p><p>①没有异常情况下的执行顺序：</p><p>around before advice<br>before advice<br>target method 执行<br>around after advice<br>after advice<br>afterReturning</p><p>②有异常情况下的执行顺序：</p><p>around before advice<br>before advice<br>target method 执行<br>around after advice<br>after advice<br>afterThrowing:异常发生<br>java.lang.RuntimeException: 异常发生</p></blockquote><h3 id="什么是切面-Aspect？"><a href="#什么是切面-Aspect？" class="headerlink" title="什么是切面 Aspect？"></a>什么是切面 Aspect？</h3><p>aspect 由 pointcount 和 advice 组成，切面是通知和切点的结合。 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑编织到切面所指定的连接点中.<br>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:</p><ul><li>如何通过 pointcut 和 advice 定位到特定的 joinpoint 上</li><li>如何在 advice 中编写切面代码.</li></ul><p>可以简单地认为, 使用 @Aspect 注解的类就是切面.</p><p><img src="https://img-blog.csdnimg.cn/2020021212264438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="解释基于XML-Schema方式的切面实现"><a href="#解释基于XML-Schema方式的切面实现" class="headerlink" title="解释基于XML Schema方式的切面实现"></a>解释基于XML Schema方式的切面实现</h3><p>在这种情况下，切面由常规类以及基于XML的配置实现。</p><h3 id="解释基于注解的切面实现"><a href="#解释基于注解的切面实现" class="headerlink" title="解释基于注解的切面实现"></a>解释基于注解的切面实现</h3><p>在这种情况下(基于@AspectJ的实现)，涉及到的切面声明的风格与带有java5标注的普通java类一致。</p><h3 id="有几种不同类型的自动代理？"><a href="#有几种不同类型的自动代理？" class="headerlink" title="有几种不同类型的自动代理？"></a>有几种不同类型的自动代理？</h3><p>BeanNameAutoProxyCreator</p><p>DefaultAdvisorAutoProxyCreator</p><p>Metadata autoproxying</p><p>————————————————<br>版权声明：本文为CSDN博主「ThinkWon」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/ThinkWon/article/details/104397516">https://blog.csdn.net/ThinkWon/article/details/104397516</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java面试题总汇</title>
    <link href="/2022/05/07/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E6%B1%87/"/>
    <url>/2022/05/07/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E6%B1%87/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Java基础"><a href="#一、Java基础" class="headerlink" title="一、Java基础"></a>一、Java基础</h1><h2 id="1-JDK-和-JRE-有什么区别？"><a href="#1-JDK-和-JRE-有什么区别？" class="headerlink" title="1. JDK 和 JRE 有什么区别？"></a><strong>1. JDK 和 JRE 有什么区别？</strong></h2><p>JDK 为 Java 开发工具包，JRE 为运行环境，JDK 包含了 JRE，同时也包含了编译 Java 源码的编译器 javac，如果你需要运行 Java程序，只安装 JRE 就可以了，如果要编写 Java 程序，需要安装 JDK。</p><h2 id="2-和-equals-的区别是什么？"><a href="#2-和-equals-的区别是什么？" class="headerlink" title="2. == 和 equals 的区别是什么？"></a><strong>2. == 和 equals 的区别是什么？</strong></h2><p>== 用作于基本类型比较的是值是否相等，用作于引用类型比较的引用是否相等</p><p>equals 默认情况下比较的是引用，只是很多类重写了 equals 方法，比如 String、Integer等把它变成了值比较。</p><h2 id="3-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？"><a href="#3-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？" class="headerlink" title="3. 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？"></a><strong>3. 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？</strong></h2><p>不对，两个对象的 hashCode 相同，equals不一定为 true</p><h2 id="4-final-在-java-中有什么作用？"><a href="#4-final-在-java-中有什么作用？" class="headerlink" title="4. final 在 java 中有什么作用？"></a><strong>4. final 在 java 中有什么作用？</strong></h2><ul><li>用 final 修饰的类叫最终类，该类不能被继承 </li><li>final 修饰的方法不能被重写</li><li>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改</li></ul><h2 id="5-java-中的-Math-round-1-5-等于多少？"><a href="#5-java-中的-Math-round-1-5-等于多少？" class="headerlink" title="5. java 中的 Math.round(-1.5) 等于多少？"></a><strong>5. java 中的 Math.round(-1.5) 等于多少？</strong></h2><p>等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是向上取整，负 0.5 直接舍弃</p><h2 id="6-String-属于基本的数据类型吗？"><a href="#6-String-属于基本的数据类型吗？" class="headerlink" title="6. String 属于基本的数据类型吗？"></a><strong>6. String 属于基本的数据类型吗？</strong></h2><p>String 不属于基本数据类型，基本数据类型有八种：byte、short、boolean、float、int、double、long、char</p><h2 id="7-java-中操作字符串都有哪些类？它们之间有什么区别？"><a href="#7-java-中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="7. java 中操作字符串都有哪些类？它们之间有什么区别？"></a><strong>7. java 中操作字符串都有哪些类？它们之间有什么区别？</strong></h2><p>操作字符串的类有String、StringBuffer、StringBuilder</p><p>他们的区别在于String声明的是不可变的对象，每次操作字符串都会生成一个新的String对象，然后将指针指向新的 String 对象，SpringBuffer和SpringBuilder可以在原有对象的基础上进行操作。</p><p>SpringBuffer和SpringBuilder的区别在于，SpringBuffer是线程安全的，SpringBuilder线程不安全，SpringBuilder的性能要高于SpringBuffer，所以在单线程环境下推荐使用SpringBuilder，多线程环境下推荐使用SpringBuffer</p><h2 id="8-String-str-”i”与-String-str-new-String-“i”-一样吗？"><a href="#8-String-str-”i”与-String-str-new-String-“i”-一样吗？" class="headerlink" title="8. String str=”i”与 String str=new String(“i”)一样吗？"></a><strong>8. String str=”i”与 String str=new String(“i”)一样吗？</strong></h2><p>不一样，因为内存的分配方式不一样，String str = “i”的方式，java虚拟机会将其分配到常量池中，而String str = new String(“i”)则会被分配到堆内存中</p><h2 id="9-如何将字符串反转？"><a href="#9-如何将字符串反转？" class="headerlink" title="9. 如何将字符串反转？"></a><strong>9. 如何将字符串反转？</strong></h2><p>使用StirngBuilder或StringBuffer的reverse()方法</p><h2 id="10-String-类的常用方法都有那些？"><a href="#10-String-类的常用方法都有那些？" class="headerlink" title="10. String 类的常用方法都有那些？"></a><strong>10. String 类的常用方法都有那些？</strong></h2><ul><li>indexOf()： 返回指定字符的索引</li><li>charAt()：返回指定索引处的字符</li><li>replace()：字符串替换</li><li>trim()：取出两端空格</li><li>split()：分割字符串，返回一个分割后的字符串数组</li><li>getBytes()：返回字符串的byte类型数组     </li><li>length()：返回字符串长度</li><li>toLowerCase()：将字符串转换成小写字母</li><li>toUpperCase()：将字符串转换成大写字母</li><li>subString()：截取字符串</li><li>equals()：字符串比较</li></ul><h2 id="11-抽象类必须要有抽象方法吗？"><a href="#11-抽象类必须要有抽象方法吗？" class="headerlink" title="11. 抽象类必须要有抽象方法吗？"></a><strong>11. 抽象类必须要有抽象方法吗？</strong></h2><p>抽象类不一定非要有抽象方法</p><h2 id="12-普通类和抽象类有哪些区别？"><a href="#12-普通类和抽象类有哪些区别？" class="headerlink" title="12. 普通类和抽象类有哪些区别？"></a><strong>12. 普通类和抽象类有哪些区别？</strong></h2><p>普通类不能包含抽象方法，抽象类可以包含抽象方法</p><p>抽象类不能直接实例化，普通类可以直接实例化</p><h2 id="13-抽象类能使用-final-修饰吗？"><a href="#13-抽象类能使用-final-修饰吗？" class="headerlink" title="13. 抽象类能使用 final 修饰吗？"></a><strong>13. 抽象类能使用 final 修饰吗？</strong></h2><p>不能，定义抽象类就是要让其他类继承的，如果使用final修饰该类就不能被继承</p><h2 id="14-接口和抽象类有什么区别？"><a href="#14-接口和抽象类有什么区别？" class="headerlink" title="14. 接口和抽象类有什么区别？"></a><strong>14. 接口和抽象类有什么区别？</strong></h2><ul><li>实现：抽象的子类使用extends来继承；接口必须使用implements来实现</li><li>构造函数：抽象类可以有构造函数，接口不能</li><li>main方法：抽象类可以有main方法，并且可以运行，接口不能有main方法</li><li>实现数量：类可以实现多个接口；但只能继承一个抽象类</li><li>访问修饰符：接口中的方法默认使用public修饰，抽象类中的方法可以是任意访问修饰符</li></ul><h2 id="15-java-中-IO-流分为几种？"><a href="#15-java-中-IO-流分为几种？" class="headerlink" title="15. java 中 IO 流分为几种？"></a><strong>15. java 中 IO 流分为几种？</strong></h2><p>按功能来分：输入流（input）、输出流（output）</p><p>按类型来分：字节流和字符流</p><p>字节流和字符流的区别是：字节流按8位传输以字节为单位输入输出数据，字符流按16位传输以字符为单位输入输出数据</p><h2 id="16-BIO、NIO、AIO-有什么区别？"><a href="#16-BIO、NIO、AIO-有什么区别？" class="headerlink" title="16. BIO、NIO、AIO 有什么区别？"></a><strong>16. BIO、NIO、AIO 有什么区别？</strong></h2><p>BIO：同步阻塞式IO，就是我们平常使用的传统IO，他的特点是模式简单使用方便，并发处理能力低</p><p>NIO：同步非阻塞式IO，就是传统IO的升级，客户端和服务端通过channel通讯，实现多路复用</p><p>AIO：NIO的升级，也叫NIO2，实现了异步非阻塞IO，异步IO的操作基于事件和回调机制 </p><h2 id="17-Files的常用方法都有哪些？"><a href="#17-Files的常用方法都有哪些？" class="headerlink" title="17. Files的常用方法都有哪些？"></a><strong>17. Files的常用方法都有哪些？</strong></h2><ul><li>Files.exists()：检测文件路径是否存在</li><li>Files.createFile()：创建文件</li><li>Files.createDirectory()：创建文件夹</li><li>Files.delete()：删除一个文件或目录</li><li>Files.copy()：复制文件</li><li>Files.move()：移动文件</li><li>Files.size()：查看文件个数</li><li>Files.read()：读取文件</li><li>Files.write()：写入文件   </li></ul><h2 id="附加："><a href="#附加：" class="headerlink" title="附加："></a><del>附加：</del></h2><h3 id="谈谈你对面向对象的理解？"><a href="#谈谈你对面向对象的理解？" class="headerlink" title="谈谈你对面向对象的理解？"></a>谈谈你对面向对象的理解？</h3><p>在我理解，面向对象是向现实世界模型的自然延伸，这是一种 “万物皆对象” 的编程思想。在现实生活中的任何物体都可以归为一类事物，而每一个个体都是一类事物的实例。面向对象的编程是以对象为中心，以消息为驱动，所以程序 = 对象 + 消息</p><p><strong>面向对象有三大特征，封装、继承和多态</strong></p><p>封装就是将一类事物的属性和行为抽象成一个类，让它属性私有化，行为公开化，提高了数据的隐秘性，使代码模块化。这样做使得代码的复用性更高</p><p>继承就是进一步将一类事物共有的属性和行为抽象成一个父类，而每个子类既有父类的行为和属性也有自己特有的行为和属性。这样做扩展了已经存在的代码块，也进一步提高了代码的复用性</p><p>多态就是为了实现接口复用，它的一大作用就是为了解耦，简单来说就是同一个行为具有多个不同的表现形式的能力</p><h3 id="Ajax的工作原理"><a href="#Ajax的工作原理" class="headerlink" title="Ajax的工作原理"></a>Ajax的工作原理</h3><p>Ajax 的工作原理相当于在用户和服务器之间加了一个中间层，让用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器。只有确定需要从服务器读取新数据时再由 Ajax 引擎向服务器提交请求</p><h3 id="手写单例模式？"><a href="#手写单例模式？" class="headerlink" title="手写单例模式？"></a>手写单例模式？</h3><figure class="highlight smali"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs smali">public class Singleton &#123;<br>   <span class="hljs-keyword"> private</span><span class="hljs-keyword"> static</span> Singleton instance;<br>   <span class="hljs-keyword"> private</span> Singleton() &#123;&#125;<br>   <span class="hljs-keyword"> public</span><span class="hljs-keyword"> static</span> synchronized Singleton getInstance() &#123;<br>       <span class="hljs-built_in"> if </span>(instance == null) &#123;<br>           <span class="hljs-built_in"> instance </span>=<span class="hljs-built_in"> new </span>Singleton();<br>        &#125;<br>       <span class="hljs-built_in"> return </span>instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="同步和异步的区别？"><a href="#同步和异步的区别？" class="headerlink" title="同步和异步的区别？"></a>同步和异步的区别？</h3><p>同步：发起者需要等待接收者返回过来的信息，成功之后在发起</p><p>异步：发起者不等待接受这返回过来的信息，随时发下一个请求</p><h1 id="二、容器"><a href="#二、容器" class="headerlink" title="二、容器"></a>二、容器</h1><h2 id="18-java-容器都有哪些？"><a href="#18-java-容器都有哪些？" class="headerlink" title="18. java 容器都有哪些？"></a><strong>18. java 容器都有哪些？</strong></h2><p>Java 容器主要分为 Collection 和 Map 两大类，其下又有很多子类</p><ul><li>Collection<ul><li>List<ul><li>ArrayList</li><li>LinkedList</li><li>Vector</li><li>Stack</li></ul></li><li>Set<ul><li>HashSet</li><li>LinkedHashSet</li><li>TreeSet</li></ul></li></ul></li><li>Map<ul><li>HashMap<ul><li>LinkedHashMap</li></ul></li><li>TreeMap</li><li>ConcurrentHashMap</li><li>Hashtable</li></ul></li></ul><h2 id="19-Collection-和-Collections-有什么区别？"><a href="#19-Collection-和-Collections-有什么区别？" class="headerlink" title="19. Collection 和 Collections 有什么区别？"></a><strong>19. Collection 和 Collections 有什么区别？</strong></h2><ul><li>Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。</li><li>Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法： Collections. sort(list)。</li></ul><h2 id="20-List、Set、Map-之间的区别是什么？"><a href="#20-List、Set、Map-之间的区别是什么？" class="headerlink" title="20. List、Set、Map 之间的区别是什么？"></a><strong>20. List、Set、Map 之间的区别是什么？</strong></h2><p>list：有序集合、元素可重复</p><p>set：无序集合、元素不可重复</p><p>map：键值对集合、Key无序，Value允许重复</p><h2 id="21-HashMap-和-Hashtable-有什么区别？"><a href="#21-HashMap-和-Hashtable-有什么区别？" class="headerlink" title="21. HashMap 和 Hashtable 有什么区别？"></a><strong>21. HashMap 和 Hashtable 有什么区别？</strong></h2><ul><li>HashMap去掉了Hashtable的contains方法，加上了containsValue（）和containsKey（）方法</li><li>Hashtable线程安全，HashMap线程不安全</li><li>HashMap允许空键值，Hashtable不允许</li></ul><h2 id="22-如何决定使用-HashMap-还是-TreeMap？"><a href="#22-如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="22. 如何决定使用 HashMap 还是 TreeMap？"></a><strong>22. 如何决定使用 HashMap 还是 TreeMap？</strong></h2><p>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择</p><h2 id="23-说一下-HashMap-的实现原理？"><a href="#23-说一下-HashMap-的实现原理？" class="headerlink" title="23. 说一下 HashMap 的实现原理？"></a><strong>23. 说一下 HashMap 的实现原理？</strong></h2><ul><li>HashMap基于Hash算法实现，通过put(key,value)存储，get(key)来获取value</li><li>当传入key时，HashMap会根据Key，调用hash(Object key)方法，计算出hash值，根据hash值将value保存在Node对象里，Node对象保存在数组里</li><li>当计算出hash值相同时，称之为hash冲突，HashMap的做法是用链表和红黑树存储相同hash值的value</li><li>当hash冲突的个数小于等于8使用链表；大于8时，使用红黑树解决链表查询慢的问题 </li></ul><h2 id="24-说一下-HashSet-的实现原理？"><a href="#24-说一下-HashSet-的实现原理？" class="headerlink" title="24. 说一下 HashSet 的实现原理？"></a><strong>24. 说一下 HashSet 的实现原理？</strong></h2><p>HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p><h2 id="25-ArrayList-和-LinkedList-的区别是什么？"><a href="#25-ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="25. ArrayList 和 LinkedList 的区别是什么？"></a><strong>25. ArrayList 和 LinkedList 的区别是什么？</strong></h2><ul><li>数据结构实现：ArrayList 的底层数据结构是动态数组，LinkedList 底层数据结构是双向链表</li><li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找</li><li>增加和删除效率：在不是首尾的增加和删除操作时，LinkedList 要比 ArrayList 效率高，因为 ArrayList 增加删除操作涉及到了元素的位移</li></ul><h2 id="26-如何实现数组和-List-之间的转换？"><a href="#26-如何实现数组和-List-之间的转换？" class="headerlink" title="26. 如何实现数组和 List 之间的转换？"></a><strong>26. 如何实现数组和 List 之间的转换？</strong></h2><ul><li>List转换为数组：调用ArrayList的toArray方法</li><li>数组转换为List：调用Arrays的asList方法</li></ul><h2 id="27-ArrayList-和-Vector-的区别是什么？"><a href="#27-ArrayList-和-Vector-的区别是什么？" class="headerlink" title="27. ArrayList 和 Vector 的区别是什么？"></a><strong>27. ArrayList 和 Vector 的区别是什么？</strong></h2><ul><li>ArrayList在内存不够时会增加原来的0.5倍，而Vector增加1倍</li><li>Vector 使用了 synchronized 来实现线程同步，是线程安全的，ArrayList 线程不安全</li><li>ArrayList 性能要高于 Vector</li></ul><h2 id="28-Array-和-ArrayList-有什么区别？"><a href="#28-Array-和-ArrayList-有什么区别？" class="headerlink" title="28. Array 和 ArrayList 有什么区别？"></a><strong>28. Array 和 ArrayList 有什么区别？</strong></h2><ul><li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象</li><li>Array 是指定大小的，而  ArrayList 大小是固定的</li><li>Array 没有提供ArrayList那么多功能，比如 addAll、removeAl l和 iterator 等方法只有 ArrayList 有</li></ul><h2 id="29-在-Queue-中-poll-和-remove-有什么区别？"><a href="#29-在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="29. 在 Queue 中 poll()和 remove()有什么区别？"></a><strong>29. 在 Queue 中 poll()和 remove()有什么区别？</strong></h2><p>poll( )和 remove( )都是从队列中返回第一个元素并在队列中删除返回的对象，区别在于 poll() 在获取元素失败时会返回null，remove() 失败的时候会抛出异常</p><h2 id="30-哪些集合类是线程安全的？"><a href="#30-哪些集合类是线程安全的？" class="headerlink" title="30. 哪些集合类是线程安全的？"></a><strong>30. 哪些集合类是线程安全的？</strong></h2><p>vector、statck、hashtable、ConcurrentHashMap</p><h2 id="31-迭代器-Iterator-是什么？"><a href="#31-迭代器-Iterator-是什么？" class="headerlink" title="31. 迭代器 Iterator 是什么？"></a><strong>31. 迭代器 Iterator 是什么？</strong></h2><p>Iterator 接口提供遍历任何 Collection 的接口，可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumberation，允许调用者在迭代过程中移除元素</p><h2 id="32-Iterator-怎么使用？有什么特点？"><a href="#32-Iterator-怎么使用？有什么特点？" class="headerlink" title="32. Iterator 怎么使用？有什么特点？"></a><strong>32. Iterator 怎么使用？有什么特点？</strong></h2><ul><li>使用方法 iterator() 要求容器返回一个 Iterator</li><li>使用 hasNext() 检查序列中是否还有元素</li><li>使用 next() 获得序列中的下一个元素</li><li>使用 remove() 将迭代器新返回的元素删除</li></ul><p>​    Iterator 的特点是更加安全，因为它可以确保在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常</p><h2 id="33-Iterator-和-ListIterator-有什么区别？"><a href="#33-Iterator-和-ListIterator-有什么区别？" class="headerlink" title="33. Iterator 和 ListIterator 有什么区别？"></a><strong>33. Iterator 和 ListIterator 有什么区别？</strong></h2><ul><li>Iterator 可用来遍历Set和List集合，但是ListIterator 只能用来遍历List集合</li><li>Iterator 只能单向遍历，ListIterator 可以双向遍历</li><li>ListIterator 实现了 Iterator 接口，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置</li></ul><h2 id="34-怎么确保一个集合不能被修改？"><a href="#34-怎么确保一个集合不能被修改？" class="headerlink" title="34.怎么确保一个集合不能被修改？"></a>34.怎么确保一个集合不能被修改？</h2><p>可以使用 Collections.unmodifiableCollection（昂某的fai bou）(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java.lang.UnsupportedOperationException 异常</p><h2 id="附加：-1"><a href="#附加：-1" class="headerlink" title="附加："></a><del>附加：</del></h2><h3 id="ConcurrentHashMap-的实现原理？"><a href="#ConcurrentHashMap-的实现原理？" class="headerlink" title="ConcurrentHashMap 的实现原理？"></a>ConcurrentHashMap 的实现原理？</h3><ul><li>1.7     <ul><li>数据结构：ReentrantLock + Segment + HashEntry，一个 Segment 中包含一个 HashEntry 数组，每个HashEntry 又是一个链表结构</li><li>元素查询：二次hash，第一次hash定位到 Segment，第二次hash定位到元素所在的链表的头部</li><li>锁：Segment 分段锁，Segment 继承了 ReentrantLock，锁定操作的 Segment，其他的 Segment 不受影响，并发度为 segment 的个数，可以通过构造函数指定，数组扩容不会影响其他的 segment</li></ul></li></ul><h3 id="你了解Java的List吗？"><a href="#你了解Java的List吗？" class="headerlink" title="你了解Java的List吗？"></a>你了解Java的List吗？</h3><p>List是一个接口，常见的实现类有ArrayList和LinkedList</p><h3 id="讲讲这两个实现类的区别？"><a href="#讲讲这两个实现类的区别？" class="headerlink" title="讲讲这两个实现类的区别？"></a>讲讲这两个实现类的区别？</h3><p>ArrayList底层数据结构是数组，支持下标访问，查询数据快，默认初始值大小是10，容量不足时会进行扩容；</p><p>linkedList底层数据结构是链表，将元素添加到元素的末尾，不需要扩容</p><h3 id="讲讲-ArrayList的扩容"><a href="#讲讲-ArrayList的扩容" class="headerlink" title="讲讲 ArrayList的扩容"></a>讲讲 ArrayList的扩容</h3><p>它是在grow方法里进行扩容，将数组扩大到原来的1.5倍</p><p>举个例子吧，如果初始化的值是8，当我们添加第9个元素时，发现数组空间不够，就会进行扩容，扩容之后的容量是12，扩容之后，会调用arrays的copyOf方法对数组进行拷贝</p><h3 id="ArrayList和LinkedList分别使用于什么场景"><a href="#ArrayList和LinkedList分别使用于什么场景" class="headerlink" title="ArrayList和LinkedList分别使用于什么场景"></a>ArrayList和LinkedList分别使用于什么场景</h3><p>对于随机访问一个元素，ArrayList速度要比LinkedList快，因为ArrayList可以通过下标直接找到元素，而LinkedList需要移动指针遍历每一个元素直到找到为止</p><p>新增和删除操作的话，LinkedList要比Arraylist速度快，因为ArrayList在新增和删除元素的时候，可能会扩容和复制数组；而LinkedList只需要修改指针就可以</p><p>因此ArrayList适用于读多写少的场景，LinkedList适合增删多，查询少的场景</p><h3 id="Set和List的区别？"><a href="#Set和List的区别？" class="headerlink" title="Set和List的区别？"></a>Set和List的区别？</h3><p>List它是以索引来存取元素，有序的，元素允许重复，可以插入多个null；Set不能存放重复的元素，无序的，只允许插入一个null</p><p>List底层实现有数组和链表两种，Set是基于Map实现的，Set里的元素值就是Map里的键值</p><h3 id="了解Vector吗"><a href="#了解Vector吗" class="headerlink" title="了解Vector吗"></a>了解Vector吗</h3><p>Vector底层数据结构是数组，现在基本没有使用Vector了，因为操作Vector效率比较低。相对于ArrayList，它线程安全，在扩容的时候会扩展为原来的2倍</p><h3 id="还知道哪些线程安全的List"><a href="#还知道哪些线程安全的List" class="headerlink" title="还知道哪些线程安全的List"></a>还知道哪些线程安全的List</h3><p>可以使用Collections的synchronizedList方法来返回一个线程安全的List</p><p>也可以使用CopyOnWriteArrayList</p><h3 id="讲讲CopyOnWriteArrayList的原理"><a href="#讲讲CopyOnWriteArrayList的原理" class="headerlink" title="讲讲CopyOnWriteArrayList的原理"></a>讲讲CopyOnWriteArrayList的原理</h3><p>CopyOnWriteArrayList是一个线程安全的List，底层是通过复制数组的方式实现的，所谓CopyOnWrite，就是写时复制，当我们往容器添加元素时，不会直接往容器里添加，而是先将当前容器进行复制，复制出一个新的容器，然后往新的容器里添加元素，添加完之后，再将原容器的引用指向新的容器。</p><h3 id="CopyOnWriteArrayList有什么缺点"><a href="#CopyOnWriteArrayList有什么缺点" class="headerlink" title="CopyOnWriteArrayList有什么缺点"></a>CopyOnWriteArrayList有什么缺点</h3><p>内存占用的问题，因为CopyOnWrite的写时复制的机制，再进行写操作时，内存会同时驻扎两个对象的内存，CopyOnWrite也不能保证数据的实时一致性，可能会读取到旧数据</p><h3 id="怎么给List排序"><a href="#怎么给List排序" class="headerlink" title="怎么给List排序"></a>怎么给List排序</h3><p>可以使用list自身的sort方法，也可以使用Collections的sort方法</p><h3 id="怎么在遍历arraylist时移除一个元素"><a href="#怎么在遍历arraylist时移除一个元素" class="headerlink" title="怎么在遍历arraylist时移除一个元素"></a>怎么在遍历arraylist时移除一个元素</h3><p>可以使用迭代器的remove方法</p><h1 id="三、多线程"><a href="#三、多线程" class="headerlink" title="三、多线程"></a>三、<strong>多线程</strong></h1><h2 id="35-并行和并发有什么区别？"><a href="#35-并行和并发有什么区别？" class="headerlink" title="35. 并行和并发有什么区别？"></a><strong>35. 并行和并发有什么区别？</strong></h2><ul><li>并发：一个处理器可以同时处理多个任务。这是逻辑上的同时发生</li><li>并行：多个处理器同时处理多个不同的任务。这是物理上的同时发生</li></ul><p>如下图：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/181/202205071834434.png" alt="202202231914971"></p><p>并发 = 两个队列和一台咖啡机</p><p>并行 = 两个队列和两台咖啡机</p><h2 id="36-线程和进程的区别？"><a href="#36-线程和进程的区别？" class="headerlink" title="36. 线程和进程的区别？"></a><strong>36. 线程和进程的区别？</strong></h2><p>一个程序下至少有一个进程，一个进程下至少有一个线程，进程下也可以有多个线程来增加程序的执行速度</p><h2 id="37-守护线程是什么？"><a href="#37-守护线程是什么？" class="headerlink" title="37. 守护线程是什么？"></a><strong>37. 守护线程是什么？</strong></h2><p>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。</p><h2 id="38-创建线程有哪几种方式？"><a href="#38-创建线程有哪几种方式？" class="headerlink" title="38. 创建线程有哪几种方式？"></a><strong>38. 创建线程有哪几种方式？</strong></h2><p>①. 继承Thread类 重写 run 方法</p><ul><li>定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。</li><li>创建Thread子类的实例，即创建了线程对象。</li><li>调用线程对象的start()方法来启动该线程。</li></ul><p>②. 实现 Runnable 接口</p><ul><li>定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li><li>创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</li><li>调用线程对象的start()方法来启动该线程。</li></ul><p>③. 实现 Callable 接口</p><ul><li>创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</li><li>创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。</li><li>使用FutureTask对象作为Thread对象的target创建并启动新线程。</li><li>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。</li></ul><h2 id="39-说一下-runnable-和-callable-有什么区别？"><a href="#39-说一下-runnable-和-callable-有什么区别？" class="headerlink" title="39. 说一下 runnable 和 callable 有什么区别？"></a><strong>39. 说一下 runnable 和 callable 有什么区别？</strong></h2><p>runnable 没有返回值，callable 有返回值， callable 可以看作成 runnable 的补充吧</p><h2 id="40-线程有哪些状态？"><a href="#40-线程有哪些状态？" class="headerlink" title="40. 线程有哪些状态？"></a><strong>40. 线程有哪些状态？</strong></h2><p>线程通常都有六种状态</p><ul><li>New（新创建）</li><li>Runnable（可运行）</li><li>Blocked（被阻塞）</li><li>Waiting（等待）</li><li>Timed Waiting（计时等待）</li><li>Terminated（被终止）</li></ul><h2 id="41-sleep-和-wait-有什么区别？"><a href="#41-sleep-和-wait-有什么区别？" class="headerlink" title="41. sleep() 和 wait() 有什么区别？"></a><strong>41. sleep() 和 wait() 有什么区别？</strong></h2><ul><li>类的不同：sleep() 属于 Thread，wait() 属于  Object</li><li>方法属性：sleep（）是一个静态方法，wait（）是一个实例方法</li><li>用法不同：sleep() 时间到了会自动恢复，wait() 可以使用 notify()/notifyAll() 直接唤醒</li></ul><h2 id="42-notify-和-notifyAll-有什么区别？"><a href="#42-notify-和-notifyAll-有什么区别？" class="headerlink" title="42. notify()和 notifyAll()有什么区别？"></a><strong>42. notify()和 notifyAll()有什么区别？</strong></h2><ul><li>notifyAll() 会唤醒所有线程，调用后，会将所有在等待池的线程移动到锁池，然后竞争锁，竞争成功就继续执行，不成功就留在锁池等锁被释放后再次竞争锁</li><li>notify() 只会唤醒一个线程，具体唤醒那个由虚拟机控制</li></ul><h2 id="43-线程的-run-和-start-有什么区别？"><a href="#43-线程的-run-和-start-有什么区别？" class="headerlink" title="43. 线程的 run()和 start()有什么区别？"></a><strong>43. 线程的 run()和 start()有什么区别？</strong></h2><p>start() 方法用于启动线程， run() 方法用于执行线程运行时的代码</p><p>run() 可以重复调用，start() 只能调用一次</p><h2 id="44-创建线程池有哪几种方式？"><a href="#44-创建线程池有哪几种方式？" class="headerlink" title="44. 创建线程池有哪几种方式？"></a><strong>44. 创建线程池有哪几种方式？</strong></h2><p>有七种方式，最核心的是最后一种：</p><ul><li>newSingleThreadExecutor()（一可死在可特儿）：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；</li><li>newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；</li><li>newFixedThreadPool(int nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；</li><li>newSingleThreadScheduled（四开丑的）Executor()：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；</li><li>newScheduledThreadPool(int corePoolSize)：和newSingleThreadScheduledExecutor()类似，创建的是个     ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；</li><li>newWorkStealingPool(int parallelism)：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；</li><li>ThreadPoolExecutor()：是最原始的线程池创建，上面1-3创建方式都是对ThreadPoolExecutor的封装。</li></ul><h2 id="45-线程池都有哪些状态？"><a href="#45-线程池都有哪些状态？" class="headerlink" title="45.线程池都有哪些状态？"></a>45.线程池都有哪些状态？</h2><ul><li>running：这是正常的状态，接受新的任务，处理等待队列中的任务</li><li>shutdown：不接受新的任务提交，但是会继续处理等待队列中的任务</li><li>stop：不接受新的任务提交，不处理等待队列中的任务，中断正在执行任务的线程</li><li>（tai ding）tidying：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 tidying 时，会执行钩子方法 terminated()（车儿每内dei的）</li><li>terminated：terminated() 方法结束后，线程池的状态就会变成这个</li></ul><h2 id="46-线程池中-submit-和-execute-方法有什么区别？"><a href="#46-线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="46. 线程池中 submit()和 execute()方法有什么区别？"></a><strong>46. 线程池中 submit()和 execute()方法有什么区别？</strong></h2><ul><li>execute()：只能执行 Runnble 类型的任务</li><li>submit()：可以执行 Runnble 和 Callable 类型的任务</li></ul><p>Callable 类型的任务可以获得执行的返回值，而 Runnble 执行无返回值</p><h2 id="47-在-java-程序中怎么保证多线程的运行安全？"><a href="#47-在-java-程序中怎么保证多线程的运行安全？" class="headerlink" title="47. 在 java 程序中怎么保证多线程的运行安全？"></a><strong>47. 在 java 程序中怎么保证多线程的运行安全？</strong></h2><ul><li>方法一：使用安全类：比如 Java.util.concurrent 下的类</li><li>方法二：使用自动锁 synchronized</li><li>方法三：使用手动锁 Lock 锁</li></ul><p>手动锁 Java 代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Lock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> ReentrantLock();<br><span class="hljs-keyword">lock</span>. <span class="hljs-keyword">lock</span>();<br><span class="hljs-keyword">try</span> &#123;<br>    System. <span class="hljs-keyword">out</span>. println(<span class="hljs-string">&quot;获得锁&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> handle exception</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    System. <span class="hljs-keyword">out</span>. println(<span class="hljs-string">&quot;释放锁&quot;</span>);<br>    <span class="hljs-keyword">lock</span>. unlock();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="48-多线程中-synchronized-锁升级原理是什么？"><a href="#48-多线程中-synchronized-锁升级原理是什么？" class="headerlink" title="48. 多线程中 synchronized 锁升级原理是什么？"></a><strong>48. 多线程中 synchronized 锁升级原理是什么？</strong></h2><p>在锁对象的对象头里有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让这个线程持有偏向锁，并将 threadid 设置为这个线程 id，再次进入的时候会先判断 threadid 是否与这个线程的 id 一致，如果一致就可以直接使用这个对象，如果不一致，就升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级锁升级为重量级锁，这个过程就构成了 synchronized 锁的升级</p><h2 id="49-什么是死锁？"><a href="#49-什么是死锁？" class="headerlink" title="49. 什么是死锁？"></a><strong>49. 什么是死锁？</strong></h2><p>线程A 持有资源1，而线程B 持有资源2，并且它们都想获得对方的资源，产生了它们之间相互等待的现象，造成阻塞，就是死锁</p><h2 id="50-怎么防止死锁？"><a href="#50-怎么防止死锁？" class="headerlink" title="50. 怎么防止死锁？"></a><strong>50. 怎么防止死锁？</strong></h2><ul><li>尽量使用 tryLock(long timeout，TimeUnit unit) 方法（ReentrantLock、ReentrantReadWriteLock），设置超时时间，超时可以退出防止死锁</li><li>使用 java.util.concurrent 并发类代替自己手写锁</li><li>降低锁的使用粒度，尽量不要几个功能用同一把锁</li><li>减少同步的代码块</li></ul><h2 id="51-ThreadLocal是什么？有哪些使用场景？"><a href="#51-ThreadLocal是什么？有哪些使用场景？" class="headerlink" title="51.ThreadLocal是什么？有哪些使用场景？"></a>51.ThreadLocal是什么？有哪些使用场景？</h2><p>ThreadLocal 为每个使用这个变量的线程提供独立的变量副本，所以每一个线程都可以独立改变自己的副本，而不会影响其他线程所对应的副本</p><p>ThreadLocal 经典使用场景是数据库连接和 session 管理等</p><h2 id="52-说一下synchronized底层实现原理？"><a href="#52-说一下synchronized底层实现原理？" class="headerlink" title="52.说一下synchronized底层实现原理？"></a>52.说一下synchronized底层实现原理？</h2><p>synchronized 是由一对  monitorenter(妈内这儿安ter)/monitorexit(妈内这儿爱可sei特) 指令实现的，monitor 对象是同步的基本实现单元，在 Java6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也低，但在 Java6 的时候，Java 虚拟机对此进行了改进，提供了三种不同的 monitor 实现，他就是常说的三种不同的锁：偏向锁、轻量级锁和重量级锁，也大大提高了性能</p><h2 id="53-synchronized和volatile的区别是什么？"><a href="#53-synchronized和volatile的区别是什么？" class="headerlink" title="53.synchronized和volatile的区别是什么？"></a>53.synchronized和volatile的区别是什么？</h2><ul><li>volatile 是变量修饰类；synchronized 是修饰类、方法、代码段</li><li>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 可以保证变量的修改可见性和原子性</li><li>volatile 不会造成线程阻塞；synchronized 可能会造成线程阻塞</li></ul><h2 id="54-synchronized-和-Lock有什么区别？"><a href="#54-synchronized-和-Lock有什么区别？" class="headerlink" title="54.synchronized 和 Lock有什么区别？"></a>54.synchronized 和 Lock有什么区别？</h2><ul><li>synchronized 可以给类、方法、代码块加锁；Lock 只能给代码块加锁</li><li>synchronized 也不需要手动获取锁和释放锁，使用比较简单，发生异常会自动释放锁，不会造成死锁；而 Lock 需要自己加锁和释放锁，如果使用不当没有 unLock() 去释放锁就会造成死锁</li><li>通过 Lock 可以知道有没有成功获取到锁；synchronized 无法办到</li></ul><h2 id="55-synchronized-和-ReentrantLock区别是什么？"><a href="#55-synchronized-和-ReentrantLock区别是什么？" class="headerlink" title="55.synchronized 和 ReentrantLock区别是什么？"></a>55.synchronized 和 ReentrantLock区别是什么？</h2><p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差比较大，但是在 Java6 中对synchronized 进行了很多的改进</p><p>区别如下：</p><ul><li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作</li><li>ReentrantLock 必须手动获取和释放锁，而 synchronized 不需要手动获取和释放</li><li>ReentrantLock 只能用于代码块锁，synchronized 可以修饰方法，代码块等</li></ul><h2 id="56-说一下atomic（额套妹可）的原理？"><a href="#56-说一下atomic（额套妹可）的原理？" class="headerlink" title="56.说一下atomic（额套妹可）的原理？"></a>56.说一下atomic（额套妹可）的原理？</h2><p>atomic 主要利用 CAS（Compare And Wwap）和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大大提升</p><h2 id="附加：-2"><a href="#附加：-2" class="headerlink" title="附加："></a><del>附加：</del></h2><h3 id="创建线程池的-7-个参数？"><a href="#创建线程池的-7-个参数？" class="headerlink" title="创建线程池的 7 个参数？"></a>创建线程池的 7 个参数？</h3><p>核心线程数、最大线程数、超时时间、时间单位、任务队列、线程工厂、拒绝策略</p><h3 id="CAS-和-AQS-的区别？"><a href="#CAS-和-AQS-的区别？" class="headerlink" title="CAS 和 AQS 的区别？"></a>CAS 和 AQS 的区别？</h3><p>CAS 是一系列的操作集合，获取当前值进行计算，如果当前值没有改变，表示线程没有被占用，直接更新成功，否则重试或返回成功或失败</p><p>AQS 是抽象队列同步器，它是各种同步工具锁的基础，比如 ReentrantLock是基于 AQS 实现的</p><h1 id="四、反射"><a href="#四、反射" class="headerlink" title="四、反射"></a>四、反射</h1><h2 id="57-什么是反射？"><a href="#57-什么是反射？" class="headerlink" title="57.什么是反射？"></a>57.什么是反射？</h2><p>反射是在运行状态中，对任意一个类，都能够知道这个类的所有属性和方法；对任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取信息以及动态调用对象的方法的功能就是反射</p><h2 id="58-什么是Java序列化？什么情况下需要序列化？"><a href="#58-什么是Java序列化？什么情况下需要序列化？" class="headerlink" title="58.什么是Java序列化？什么情况下需要序列化？"></a>58.什么是Java序列化？什么情况下需要序列化？</h2><p>Java对象转换成字节流的过程称为序列化。</p><p>字节流转换成Java对象的过程称为反序列化</p><p>什么情况下需要序列化：</p><ul><li>想把内存中的对象状态保存到一个文件或者数据库中时</li><li>想用套接字在网络上传送对象的时候</li><li>想通过 RMI（远程方法调用）传输对象的</li></ul><h2 id="59-动态代理是什么？有哪些应用？"><a href="#59-动态代理是什么？有哪些应用？" class="headerlink" title="59.动态代理是什么？有哪些应用？"></a>59.动态代理是什么？有哪些应用？</h2><p>动态代理就是程序运行时动态生成的代理类</p><p>动态代理的应用：</p><ul><li>Spring的AOP</li><li>加事务</li><li>加权限</li><li>加日志</li></ul><h2 id="60-怎么实现动态代理？"><a href="#60-怎么实现动态代理？" class="headerlink" title="60.怎么实现动态代理？"></a>60.怎么实现动态代理？</h2><p>JDK 原生动态代理和 CGLIB 动态代理，JDK 原生动态代理基于接口实现的，而 CGLIB 是基于继承当前类的子类实现的</p><h1 id="五、对象拷贝"><a href="#五、对象拷贝" class="headerlink" title="五、对象拷贝"></a>五、对象拷贝</h1><h2 id="61-为什么要使用克隆？"><a href="#61-为什么要使用克隆？" class="headerlink" title="61.为什么要使用克隆？"></a>61.为什么要使用克隆？</h2><p>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化的时候的值，所以当需要一个新的对象来保存当前对象的“状态”就需要靠克隆方法了</p><h2 id="62-如何实现对象克隆？"><a href="#62-如何实现对象克隆？" class="headerlink" title="62.如何实现对象克隆？"></a>62.如何实现对象克隆？</h2><ul><li>实现 Cloneable 接口并重写 Object 类中的 clone() 方法</li><li>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正深度的克隆</li></ul><h2 id="63-深拷贝和浅拷贝的区别是什么？"><a href="#63-深拷贝和浅拷贝的区别是什么？" class="headerlink" title="63.深拷贝和浅拷贝的区别是什么？"></a>63.深拷贝和浅拷贝的区别是什么？</h2><ul><li>浅拷贝：当对象被复制时只复制它本身和其中包含的值类型的成员变量，引用类型的成员变量并没有复制</li><li>深克隆：除了对象本身被复制外，对象包含的所有成员变量也复制</li></ul><h1 id="六、Java-Web"><a href="#六、Java-Web" class="headerlink" title="六、Java Web"></a>六、Java Web</h1><h2 id="64-jsp和servlet有什么区别？"><a href="#64-jsp和servlet有什么区别？" class="headerlink" title="64.jsp和servlet有什么区别？"></a>64.jsp和servlet有什么区别？</h2><p> servlet</p><ul><li>一种服务器端的Java应用程序</li><li>由 Web 容器加载和管理</li><li>用于生成动态 Web 内容</li><li>负责处理客户端请求</li></ul><p>jsp</p><ul><li>是 servlet 的扩展，本质上还是 servlet</li><li>每个 jsp 页面就是一个 servlet 实例</li><li>jsp 页面会被 web 容器编译成 servlet，servlet再负责响应用户请求</li></ul><p>区别：</p><ul><li>servlet 适合动态输出 web 数据和业务逻辑处理，对于 html 页面内容的修改非常不方便；jsp 是在 html 代码中嵌入Java代码，适合页面的显示</li><li>内置对象不同，获取内置对象的方式也不同</li></ul><h2 id="65-jsp有哪些内置对象？作用分别是什么？"><a href="#65-jsp有哪些内置对象？作用分别是什么？" class="headerlink" title="65.jsp有哪些内置对象？作用分别是什么？"></a>65.jsp有哪些内置对象？作用分别是什么？</h2><ul><li>request：封装客户端的请求，其中包含GET或POST请求的参数</li><li>response：封装服务器对客户端的响应</li><li>pageContext：通过该对象可以获取其他对象</li><li>session：封装用户会话的对象</li><li>application：封装服务器运行环境的对象</li><li>out：输出服务器响应的输出流对象</li><li>config：Web应用的配置对象</li><li>page：JSP页面本身（相当于Java中的this）</li><li>exception：封装页面抛出异常的对象</li></ul><h2 id="66-说一下jsp的-4-种作用域？"><a href="#66-说一下jsp的-4-种作用域？" class="headerlink" title="66.说一下jsp的 4 种作用域？"></a>66.说一下jsp的 4 种作用域？</h2><p>JSP中的四种作用域包括page、request、session和application，具体来说：</p><ul><li><strong>page</strong>代表与一个页面相关的对象和属性</li><li><strong>request</strong>代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域</li><li><strong>session</strong>代表与某个用户服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中</li><li><strong>application</strong>代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域</li></ul><h2 id="67-session和cookie有什么区别"><a href="#67-session和cookie有什么区别" class="headerlink" title="67.session和cookie有什么区别"></a>67.session和cookie有什么区别</h2><ul><li>存储位置不同：session 存储在服务端，cookie 存储在客户端</li><li>安全性不同：cookie 安全性一般，在浏览器存储，可以被伪造和修改</li><li>容量和个数限制：cookie 有容量限制，每个站点下的 cookie 也有个数限制</li><li>存储的多样性：session 可以存储在 redis 中、数据库中、应用程序中；而 cookie 只能存储在浏览器中</li></ul><h2 id="68-说一下session的工作原理？"><a href="#68-说一下session的工作原理？" class="headerlink" title="68.说一下session的工作原理？"></a>68.说一下session的工作原理？</h2><p>session 的工作原理是客户端登录完成之后，服务器会创建对应的 session，session 创建完后，会把 session 的 id 发送给客户端，客户端在存储到浏览器中，这样客户端每次访问服务器时，都会带着 sessionid，服务器拿到 sessionid 之后，在内存找到对应的 session 就可以正常工作了</p><h2 id="69-如果客户端禁止cookie，session还能用吗？"><a href="#69-如果客户端禁止cookie，session还能用吗？" class="headerlink" title="69.如果客户端禁止cookie，session还能用吗？"></a>69.如果客户端禁止cookie，session还能用吗？</h2><p>可以用，session 只是依赖 cookie 存储 sessionid，如果 cookie 被禁用了，可以使用 url 中添加 sessionid 的方式保证 session 能正常使用。</p><h2 id="70-springmvc和struts的区别？"><a href="#70-springmvc和struts的区别？" class="headerlink" title="70.springmvc和struts的区别？"></a>70.springmvc和struts的区别？</h2><ul><li>拦截级别：struts2 是类级别的拦截；spring mvc是方法级别的拦截</li><li>数据独立性：spring mvc 的方法之间基本上独立的，独享 request 和 response 数据，请求数据通过参数获取，处理结果通过 ModelMap 交回给框架，方法之间不共享变量；而 struts2 虽然方法之间也是独立的，但其所有 action 变量是共享的，这不会影响程序运行，却给我们编码和读程序时带来了一定的麻烦</li><li>拦截机制：struts2 有自己的 interceptor 机制，spring mvc用的是独立的 aop 方式，这样导致 struts2 的配置文件量比 spring mvc 大</li><li>对 ajax 的支持：spring mvc 集成了 ajax，所有 ajax 使用很方便，只需要一个注解 @ResponseBody 就可以实现了，而 struts2 一般需要安装插件或自己写代码才行</li></ul><h2 id="71-如何避免sql注入？"><a href="#71-如何避免sql注入？" class="headerlink" title="71.如何避免sql注入？"></a>71.如何避免sql注入？</h2><ol><li>使用预处理 PreparedStatement （喷er配儿的 死dei个们次）</li><li>使用正则表达式过滤传入的参数</li></ol><h2 id="72-什么是XSS攻击，如何避免？"><a href="#72-什么是XSS攻击，如何避免？" class="headerlink" title="72.什么是XSS攻击，如何避免？"></a>72.什么是XSS攻击，如何避免？</h2><p>XSS 攻击：即跨站脚本攻击，它是 Web 程序中常见的漏洞。原理是攻击者往 Web 页面里插入恶意的脚本代码（css 代码、Javascript 代码等），当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，如盗取用户 cookie、破坏页面结构、重定向到其他网站等。</p><p>预防 XSS 的核心是必须对输入的数据做过滤处理。</p><h2 id="73-什么是CSRF攻击，如何避免？"><a href="#73-什么是CSRF攻击，如何避免？" class="headerlink" title="73.什么是CSRF攻击，如何避免？"></a>73.什么是CSRF攻击，如何避免？</h2><p>CSRF 代表跨站请求伪造，这是一种攻击，迫使最终用户在当前通过身份验证的Web 应用程序上执行不需要的操作。CSRF 攻击专门针对状态改变请求，而不是数据窃取，因为攻击者无法查看对伪造请求的响应。</p><p>如何避免：</p><ol><li><p>验证请求来源地址</p><blockquote><p>HTTP头中的Referer字段记录了该HTTP请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，而如果黑客要对其实施 CSRF攻击，他一般只能在他自己的网站构造请求。因此，可以通过验证Referer值来防御CSRF攻击</p></blockquote></li><li><p>关键操作添加验证码</p><blockquote><p>关键操作页面加上验证码，后台收到请求后通过判断验证码可以防御CSRF。但这种方法对用户不太友好</p></blockquote></li><li><p>在请求地址中添加token并验证</p><blockquote><p>CSRF攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于cookie中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的cookie来通过验证。要抵御CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于cookie之中。可以在HTTP请求中以参数的形式加入一个随机产生的token，并在服务器端建立一个拦截器来验证这个token，如果请求中没有token或者token不正确，则认为可能是CSRF攻击而拒绝该请求。这种方法要比检查Referer要安全一些，token可以在用户登录后产生并放入session中，然后在每次请求时把token从session中拿出，与请求中的token进行比对，但这种方法难点在于如何把token以参数的形式加入请求。</p><p>对于GET请求，token将附在请求地址后，这样URL就变成了 <a href="http://url/?csrftoken=tokenvalue">http://url?csrftoken=tokenvalue</a></p><p>而对于POST请求，要在from的最后加上<input type="hidden" name="csrftoken" value="csrftoken"/>，这样就把token以参数的形式加入请求了</p></blockquote></li><li><p>在HTTP头中自定义属性并验证</p><blockquote><p>这种方法也是使用token并进行验证，和上一种方法不同的是，这里并不是把token以参数的形式置于HTTP请求之中，而是把它放到HTTP头中自定义的属性里。通过XMLHttpRequest这个类，可以一次性给所有该类请求加上csrftoken这个HTTP头属性，并把token值放入其中。这样解决了上种方法在请求中加入token的不变，同时，通过XMLHttpRequest请求的地址不会被记录到浏览器的地址栏，也不用担心token会透过Referer泄漏到其他网站中去</p></blockquote></li></ol><h1 id="七、异常"><a href="#七、异常" class="headerlink" title="七、异常"></a>七、异常</h1><h2 id="74-throw和throws的区别？"><a href="#74-throw和throws的区别？" class="headerlink" title="74.throw和throws的区别？"></a>74.throw和throws的区别？</h2><ul><li>throw：是真实抛出的一个异常</li><li>throws：是声明可能会抛出的异常</li></ul><h2 id="75-final、finally、finalze有什么区别？"><a href="#75-final、finally、finalze有什么区别？" class="headerlink" title="75.final、finally、finalze有什么区别？"></a>75.final、finally、finalze有什么区别？</h2><ul><li>final：是修饰符，如果修饰类，此类不能被继承；如果修饰方法，这个方法不能被重写；如果修饰变量，这个变量不能更该</li><li>finally：是 try{}catch{}finally{} 最后一部分，表示无论发生任何情况都会执行，finally 部分可以省略，但如果 finally 部分存在，就一定会执行里面的代码</li><li>finalize：是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法  </li></ul><h2 id="76-try-catch-finally中哪个部分可以省略？"><a href="#76-try-catch-finally中哪个部分可以省略？" class="headerlink" title="76.try-catch-finally中哪个部分可以省略？"></a>76.try-catch-finally中哪个部分可以省略？</h2><p>try-catch-finally 其中 catch 和 finally 都可以省略，但是不能同时省略，也就是说有 try 的时候，后面必须跟一个 catch 或者 finally</p><h2 id="77-try-catch-finally中，如果catch中return了，finally还会执行吗？"><a href="#77-try-catch-finally中，如果catch中return了，finally还会执行吗？" class="headerlink" title="77.try-catch-finally中，如果catch中return了，finally还会执行吗？"></a>77.try-catch-finally中，如果catch中return了，finally还会执行吗？</h2><p>会执行，即使 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行</p><h2 id="78-常见的异常类有哪些？"><a href="#78-常见的异常类有哪些？" class="headerlink" title="78.常见的异常类有哪些？"></a>78.常见的异常类有哪些？</h2><ul><li>NullPointerException：空指针异常</li><li>ClassNotFoundException：指定类不存在</li><li>NumberFor matException：字符串转换为数字异常</li><li>IndexOutOfBoundsException：数组下标越界异常</li><li>ClassCastException：数据类型转换异常</li><li>FileNotFoundException：文件未找到异常</li><li>NoSuchMethodException：方法不存在异常</li><li>IOException：IO 异常</li></ul><h1 id="八、网络"><a href="#八、网络" class="headerlink" title="八、网络"></a>八、<strong>网络</strong></h1><h2 id="79-http-响应码-301-和-302-代表的是什么？有什么区别？"><a href="#79-http-响应码-301-和-302-代表的是什么？有什么区别？" class="headerlink" title="79. http 响应码 301 和 302 代表的是什么？有什么区别？"></a><strong>79. http 响应码 301 和 302 代表的是什么？有什么区别？</strong></h2><p>301、302都是HTTP状态的编码，都代表着某个URL发生了转移</p><ul><li>301 redirect：永久重定向</li><li>302 redirect：暂时重定向</li></ul><p>他们的区别是，301 对搜索引擎优化更加有利；302 有被提示为网络拦截的风险</p><h2 id="80-forward和redirect的区别？"><a href="#80-forward和redirect的区别？" class="headerlink" title="80.forward和redirect的区别？"></a>80.forward和redirect的区别？</h2><p>forward是转发，redirect是重定向</p><ul><li>地址栏 url 显示：forward url不会发生变化，redirect 会发生变化</li><li>数据共享：forward 可以共享 request 里的数据，redirect 不能</li><li>效率：forward 比 redirect 效率高</li></ul><h2 id="81-简述tcp和udp的区别？"><a href="#81-简述tcp和udp的区别？" class="headerlink" title="81.简述tcp和udp的区别？"></a>81.简述tcp和udp的区别？</h2><ul><li>TCP 面向连接；UDP 是无连接的，就是发送数据之前不需要建立连接</li><li>TCP 提供可靠的服务，UPD 无法保证</li><li>TCP 面向字节流，UPD 面向报文</li><li>TCP 数据传输慢，UPD 数据传输快</li></ul><h2 id="82-TCP为什么要三次握手，两次不行吗？为什么？"><a href="#82-TCP为什么要三次握手，两次不行吗？为什么？" class="headerlink" title="82.TCP为什么要三次握手，两次不行吗？为什么？"></a>82.TCP为什么要三次握手，两次不行吗？为什么？</h2><p>如果采用两次握手，那么只要服务器发出确认数据包就会建立连接，但由于客户端这时并没有响应服务器端的请求，那这时服务器端就会一直在等待客户端，这样服务器端就白白浪费了一定的资源</p><p>如果采用三次握手，服务器端没有收到客户端的再次确认，就会知道客户端并没有要求建立请求，就不会浪费服务器的资源</p><h2 id="83-说一下TCP粘包是怎么产生的？"><a href="#83-说一下TCP粘包是怎么产生的？" class="headerlink" title="83.说一下TCP粘包是怎么产生的？"></a>83.说一下TCP粘包是怎么产生的？</h2><p>tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因</p><p><strong>① 发送方产生粘包：发送端需要等缓冲区满了才发出去，造成粘包</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIMnOiaLZLvCauibB6a1NxIwLdQC1gqfKDwusvSlQxEaDnRSySSvcK2VNlpdH9MFfRasTicha14JuvKYQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><strong>② 接收方产生粘包：接收方不及时接收缓冲区的包，造成多个包接收</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIMnOiaLZLvCauibB6a1NxIwLdV9Mic1uabwcX3AqZ9Tw9M7lcbwMQxFVUMWmG3SKNRibVLHZgcQvFDbmw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h2 id="84-OSI-的七层模型都有哪些？"><a href="#84-OSI-的七层模型都有哪些？" class="headerlink" title="84.OSI 的七层模型都有哪些？"></a>84.OSI 的七层模型都有哪些？</h2><ol><li>应用层：网络服务与最终用户的一个接口</li><li>表示层：数据的表示、安全、压缩</li><li>会话层：建立、管理、终止会话</li><li>传输层：定义传输数据的协议端口号，以及流控和差错校验</li><li>网络层：进行逻辑地址寻址，实现不用网络之间的路径选择</li><li>数据链路层：建立逻辑连接、进行硬件地址寻址、差错效验等功能</li><li>物理层：建立、维护、断开物理连接</li></ol><h2 id="85-get-和-post-请求有哪些区别？"><a href="#85-get-和-post-请求有哪些区别？" class="headerlink" title="85.get 和 post 请求有哪些区别？"></a>85.get 和 post 请求有哪些区别？</h2><ul><li>get 请求会被浏览器主动缓存，而 post 不会</li><li>get 传递参数有大小限制，而 post 没有</li><li>post 参数传输更安全，get 的参数会明文显示在 url 上，post不会</li></ul><h2 id="86-如何实现跨域？"><a href="#86-如何实现跨域？" class="headerlink" title="86.如何实现跨域？"></a>86.如何实现跨域？</h2><p>实现跨域有一下几种方案：</p><ul><li>服务器端运行跨域设置 CORS 等于 *；</li><li>在单个接口使用注解 @CrossOrigin 运行跨域；</li><li>使用 jsonp 跨域</li></ul><h2 id="87-说一下JSONP实现原理？"><a href="#87-说一下JSONP实现原理？" class="headerlink" title="87.说一下JSONP实现原理？"></a>87.说一下JSONP实现原理？</h2><p>jsonp JSON with Padding，它是利用 script 标签的 src 连接可以访问不同源的特性，加载远程返回的 JS 函数来执行的</p><h1 id="九、设计模式"><a href="#九、设计模式" class="headerlink" title="九、设计模式"></a>九、设计模式</h1><h2 id="88-说一下你熟悉的设计模式"><a href="#88-说一下你熟悉的设计模式" class="headerlink" title="88.说一下你熟悉的设计模式"></a>88.说一下你熟悉的设计模式</h2><ul><li>单例模式：保证被创建一次，节省系统开销</li><li>工程模式（简单工厂、抽象工厂）：解耦代码</li><li>观察者模式：定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新</li><li>外观模式：提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用</li><li>模板方法模式：定义了一个算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤</li><li>状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类</li></ul><h2 id="89-简单工厂和抽象工厂有什么区别？"><a href="#89-简单工厂和抽象工厂有什么区别？" class="headerlink" title="89.简单工厂和抽象工厂有什么区别？"></a>89.简单工厂和抽象工厂有什么区别？</h2><p><strong>简单工厂：</strong>用来生产同一等级结构中的任意产品，但对于增加新的产品无能为力</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIO6jib8XP3r8h8sib080icibHvuSJqRGYdhLZItsEf08Sx8aaPribM8zwzn8QVENHWfPx7NX2AV1ylg3Fg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><strong>抽象工厂：</strong>用来生产不同产品族的全部产品，对于增加新的产品无能为力，但支持增加产品族</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIO6jib8XP3r8h8sib080icibHvuEjfkB779GfJ2ibh82pwJmcvia3RhfKCUQ23nKXEtfNltctciawxP9jibEw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h1 id="十、Spring-Spring-MVC"><a href="#十、Spring-Spring-MVC" class="headerlink" title="十、Spring / Spring MVC"></a>十、<strong>Spring / Spring MVC</strong></h1><h2 id="90-为什么要使用Spring？"><a href="#90-为什么要使用Spring？" class="headerlink" title="90.为什么要使用Spring？"></a>90.为什么要使用Spring？</h2><ul><li>Spring 提供了 ioc 技术，容器会帮我们管理依赖对象，不需要自己创建和管理，更轻松的实现程序的解耦</li><li>Spring 提供了事务支持，让事务操作变得更加简单</li><li>Spring 提供了面向切面编程，可以很方便的处理某一类的问题</li><li>更方便的集成其他框架</li></ul><h2 id="91-解释一下什么aop？"><a href="#91-解释一下什么aop？" class="headerlink" title="91.解释一下什么aop？"></a>91.解释一下什么aop？</h2><p>AOP是<del>面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术</del></p><p>面向切面是<del>面向对象的延续</del>，是Spring框架中的一个重要内容，利用AOP可以对业务逻辑的各个部分进行隔离，使业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时也提高了开发效率</p><p><del>AOP有两种实现方式：</del></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/181/202205071834739.png" alt="202202212005413"></p><ul><li><del>静态代理</del>，就是代理类在编译阶段生成，在编译阶段将通知织入Java字节码中，AspectJ使用的就是静态代理</li><li><del>动态代理</del>，代理类在程序运行时创建，AOP框架不会去修改字节码，而是在内存中临时生成一个代理对象，在运行期间对业务方法进行增强，不会生成新类</li></ul><p>而Spring AOP 动态代理又有两种实现方式：JDK 动态代理 和 CGLIB 动态代理</p><p><del>区别：</del></p><p>JDK动态代理：如果目标类实现了接口，Spring AOP 会选择使用 JDK 动态代理目标类，代理类根据目标类实现的接口动态生成，不需要自己编写，生成的动态代理类和目标类都实现相同的接口，它的核心就<code>InvocationHandler</code>接口和<code>Proxy</code>类</p><p>CGLIB动态代理：通过继承实现，如果目标类没有实现接口，那么 AOP 会选择使用 CGLIB 动态代理目标类，CGLIB可以在运行时动态生成类的字节码，动态创建目标类的子类对象，在子类对象中增强目标类</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/181/202205071834936.png" alt="202202212009981"></p><p><del>有五种通知类型：</del></p><ul><li><del>Before(前置通知)</del></li><li><del>AfterReturning(后置通知)</del></li><li><del>AfterThrowing(异常处理通知)</del></li><li><del>After(最终通知)</del></li><li><del>Around(环绕通知)</del>（饿ruang的）</li></ul><h2 id="92-解释一下什么是-ioc？"><a href="#92-解释一下什么是-ioc？" class="headerlink" title="92. 解释一下什么是 ioc？"></a><strong>92. 解释一下什么是 ioc？</strong></h2><p>首先IOC是一个<del>容器</del>，是用来装载对象的，它的核心思想就是<del>控制反转</del></p><p>控制反转就是说，<del>把对象的控制权交给了spring去管理</del>，我们不进行任何操作</p><p>在没有控制反转的时候，我们需要<del>自己去创建对象，配置对象</del>，还要<del>人工去处理对象与对象之间的依赖关系</del>，当工程量起来的时候，这种关系维护是非常麻烦的，所以就有了控制反转这个概念，将对象的创建、配置等一系列操作交给Spring去管理，我们使用的时候直接取就可以</p><h2 id="93-spring-有哪些主要模块？"><a href="#93-spring-有哪些主要模块？" class="headerlink" title="93.spring 有哪些主要模块？"></a><strong>93.spring 有哪些主要模块？</strong></h2><ol><li>spring core：框架的最基础部分，提供 ioc 和依赖注入特性</li><li>spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法</li><li>spring dao：提供了 JDBC 的抽象层</li><li>spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等</li><li>spring web：提供了针对 web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 web 的 applicationcontext</li><li>spring web mvc：spring 中的 mvc 封装包提供了 web 应用的 Model-View-Controller（MVC）的实现</li></ol><h2 id="94-Spring常用的注入方式有哪些？"><a href="#94-Spring常用的注入方式有哪些？" class="headerlink" title="94.Spring常用的注入方式有哪些？"></a>94.Spring常用的注入方式有哪些？</h2><p>Spring通过DI（依赖注入）实现IOC（控制反转），常用的注入方式主要有三种：</p><ul><li>构造方法注入</li><li>setter注入</li><li>基于注解注入</li></ul><h2 id="95-Spring中的bean是线程安全吗？"><a href="#95-Spring中的bean是线程安全吗？" class="headerlink" title="95.Spring中的bean是线程安全吗？"></a>95.Spring中的bean是线程安全吗？</h2><p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理</p><p>实际大部分时候 spring bean 无状态的（比如 dao 类），所以某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把 singleton（sing狗森）变更为 prototype（po头type），这样请求 bean 相当于 new Bean() 了，所以就可以保证线程安全</p><ul><li>有状态就是有数据存储功能</li><li>无状态就是不会保存数据</li></ul><h2 id="96-Spring支持几种bean的作用域？"><a href="#96-Spring支持几种bean的作用域？" class="headerlink" title="96.Spring支持几种bean的作用域？"></a>96.Spring支持几种bean的作用域？</h2><p>Spring支持5种作用域：</p><ul><li><strong>singleton</strong>：spring ioc容器中只存在一个bean实例，bean以单例模式存在，是系统默认值</li><li><strong>prototype</strong>：每次从容器调用bean时都会创建一个新的实例，每次getBean()相当于执行new Bean()操作</li><li><strong>request</strong>：每次http请求都会创建一个bean；</li><li><strong>session</strong>：同一个http session共享一个bean实例</li><li><strong>global session</strong>：用于portlet（破儿里特）容器，因为每个portlet有单独的session，global session提供一个全局性的http session</li></ul><p>注意：使用 prototype 作用域需要慎重考虑，因为频繁创建和销毁 bean 会带来很大的性能开销</p><h2 id="97-Spring自动装配bean有哪些方式？"><a href="#97-Spring自动装配bean有哪些方式？" class="headerlink" title="97.Spring自动装配bean有哪些方式？"></a>97.Spring自动装配bean有哪些方式？</h2><ul><li>no：默认值，手动装配方式，需要通过 ref 设定 bean 的依赖关系</li><li>byName：根据 bean 的名称进行装配，当一个bean的名称和其他bean的属性一致，则自动装配</li><li>byType：根据 bean 类型进行装配，当一个bean的属性类型与其他bean的属性的数据类型一致，则自动装配</li><li>constructor（看骚可特儿）：通过构造器进行装配，与 byType 类似，如果bean的构造器有与其他bean类型相同的属性，则进行自动装配</li><li>autodelete：如果有默认构造器，就以构造器的方式进行装配，否则以 byType 方式进行装配</li></ul><h2 id="98-Spring事务实现方式有哪些？"><a href="#98-Spring事务实现方式有哪些？" class="headerlink" title="98.Spring事务实现方式有哪些？"></a>98.Spring事务实现方式有哪些？</h2><ul><li>声明式事务：声明式事务有两种实现方式<ul><li>基于 xml 配置文件的方式</li><li>注解方式（在类上添加 @Transaction 注解）</li></ul></li><li>编程式事务：在代码中调用 commit()、rollback() 等事务管理的相关方法</li></ul><h2 id="99-请简述Spring的事务隔离级别？"><a href="#99-请简述Spring的事务隔离级别？" class="headerlink" title="99.请简述Spring的事务隔离级别？"></a>99.请简述Spring的事务隔离级别？</h2><p><strong>default（默认）：</strong>使用数据库默认的事务隔离级别</p><p><strong>read_committed（读已提交）</strong>：一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认隔离级别</p><p><strong>read_uncommitted（读未提交）</strong>：最低的隔离级别，事务未提交前，就可以被其他事务读取（会造成幻读、脏读、不可重复读）</p><p><strong>repeatable_read（可重复读）</strong>：保证多次读取同一个数据时，值和事务开始时候的内容是一致的，禁止读取到别的事务未提交的数据（会造成幻读），MySQL默认级别</p><p><strong>serializable（串行化）</strong>：代价最高但是最可靠的隔离级别，这个隔离级别可以防止脏读、不可重复读、幻读</p><ul><li>脏读：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事物尝试插入记录 A，这时事务还没有提交，然后另一个事务尝试读取到了记录 A</li><li>不可重复读：就是一个事务内多次根据同一查询条件查询出来的同一条记录的值不一致</li><li>幻读：同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询有 n 条记录，但是第二次查询有 n+1 条记录，跟幻觉一样，发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个数据集的内容被修改了，所以数据行的记录个数就改变了</li></ul><h2 id="100-说一下Spring-MVC运行流程？"><a href="#100-说一下Spring-MVC运行流程？" class="headerlink" title="100.说一下Spring MVC运行流程？"></a>100.说一下Spring MVC运行流程？</h2><p>流程图：<img src="https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIO6jib8XP3r8h8sib080icibHvuXf6N81oaWRBTJN3tYEHBPib8eHCGO6MmlvknSuibEmlROtz4IcfrxX9w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><ol><li>spring mvc 先将请求发送给 DispatcherServlet</li><li>DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器</li><li>HandlerMapping根据用户的请求匹配对应的处理器，返回一个执行链</li><li>HandlerAdapter 经过适配调用具体的处理器Controller</li><li>Controller 执行完成返回 ModelAndView</li><li>DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器</li><li>ViewReslover 解析后返回具体的 View</li><li>DispatcherServlet 根据 View 进行渲染视图</li></ol><h2 id="101-Spring-MVC-有哪些组件？"><a href="#101-Spring-MVC-有哪些组件？" class="headerlink" title="101.Spring MVC 有哪些组件？"></a>101.Spring MVC 有哪些组件？</h2><ul><li>前置控制器：DispatcherServlet </li><li>处理器映射器：HandlerMapping</li><li>处理器：Controller</li><li>模型和视图：ModelAndView</li><li>视图解析器：ViewResolver</li><li>处理器适配器：HandlerAdapter</li><li>文件上传处理器：MultipartResolver</li></ul><h2 id="102-RequestMapping的作用是什么？"><a href="#102-RequestMapping的作用是什么？" class="headerlink" title="102.@RequestMapping的作用是什么？"></a>102.@RequestMapping的作用是什么？</h2><p>@RequestMapping是用来标识请求地址映射的注解</p><p>可以用在类上或者方法上，方法匹配的完整路径是controller类上的@RequestMapping注解的value值加上方法上的@RequestMapping注解的value值</p><h2 id="103-Autowired的作用是什么？"><a href="#103-Autowired的作用是什么？" class="headerlink" title="103.@Autowired的作用是什么？"></a>103.@Autowired的作用是什么？</h2><p>@Autowired它可以对类成员变量、方法以和构造方法进行标注，完成自动装配的工作，通过@Autowired的使用来消除get/set方法</p><h2 id="附加：-3"><a href="#附加：-3" class="headerlink" title="附加："></a><del>附加：</del></h2><h3 id="什么是spring？"><a href="#什么是spring？" class="headerlink" title="什么是spring？"></a>什么是spring？</h3><p>spring是一个轻量级的框架，目的是为了解决企业级应用开发的业务逻辑层和其他层的耦合问题，他有两个核心的特性，就是IOC和AOP</p><h3 id="Spring-中都用到了哪些设计模式？"><a href="#Spring-中都用到了哪些设计模式？" class="headerlink" title="Spring 中都用到了哪些设计模式？"></a>Spring 中都用到了哪些设计模式？</h3><p><strong>工厂模式：</strong> 比如通过BeanFactory和ApplicationContext来生产Bean对象</p><p><strong>代理模式：</strong>AOP的实现方式就是通过代理来实现，Spring主要是使用JDK动态代理和CGLIB代理</p><p><strong>单例设计模式：</strong>Spring中的Bean默认都是单例的</p><p><strong>模板方法模式：</strong>Spring中jdbcTemplate等以Template结尾的对数据库操作得类，都会使用到模板方法设计模式，一些通用的功能</p><p><strong>包装器设计模式：</strong>我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源</p><p><strong>观察者模式：</strong>Spring事件驱动模型是观察者模式</p><p><strong>适配器模式：</strong>Spring AOP的增强或通知使用到了适配器模式</p><h3 id="Spring-Bean的生命周期"><a href="#Spring-Bean的生命周期" class="headerlink" title="Spring Bean的生命周期"></a>Spring Bean的生命周期</h3><p>Spring Bean的生命周期大致分为4个阶段：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/181/202205071833097.png" alt="202202212029312"></p><ol><li><del>[实例化]</del>：实例化Bean对象</li><li><del>[填充属性]</del>：给这个Bean赋值</li><li><del>[初始化]</del>：<ol><li>如果实现了 Aware 接口，会通过接口获取容器资源</li><li>如果实现了 BeanPostProcessor（扑rua sei色儿） 接口，会回调这个接口的前后置处理增强</li><li>如果配置了 init-method 方法，会执行这个方法</li></ol></li><li><del>[销毁]</del>：<ol><li><ul><li>如果实现了 DisposableBean（diss po 子bo） 接口，会回调这个接口的 destroy 方法</li><li>如果配置了 destroy-method 方法，会执行 destroy -method 配置的方法</li></ul></li></ol></li></ol><h3 id="Spring中七种事务传播行为"><a href="#Spring中七种事务传播行为" class="headerlink" title="Spring中七种事务传播行为"></a>Spring中七种事务传播行为</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/181/202205071833310.png" alt="202202212042703"></p><p>事务的传播行为，默认值为 REQUIRED。可以手动指定其他的事务传播行为，如下：</p><ul><li><strong>REQUIRED</strong></li></ul><p>​       如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务。</p><ul><li><p><strong>SUPPORTS（死破er次）</strong></p><p>如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行。</p></li><li><p><strong>MANDATORY（man的头瑞）</strong></p></li></ul><p>​       如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常。</p><ul><li><strong>REQUIRES_NEW</strong></li></ul><p>​       重新创建一个新的事务，如果当前存在事务，就挂起当前的事务。</p><ul><li><strong>NOT_SUPPORTED</strong></li></ul><p>​       以非事务的方式运行，如果当前存在事务，暂 停当前的事务。</p><ul><li><strong>NEVER（奶味er）</strong></li></ul><p>​       以非事务的方式运行，如果当前存在事务，则抛出异常。</p><ul><li><strong>NESTED（nice忒的）</strong></li></ul><p>​       如果没有，就新建一个事务；如果有，就在当前事务中嵌套其他事务。</p><h3 id="Autowired-和-Resource-有什么区别"><a href="#Autowired-和-Resource-有什么区别" class="headerlink" title="@Autowired 和 @Resource 有什么区别?"></a>@Autowired 和 @Resource 有什么区别?</h3><ul><li>@Resource和@Autowired都可以标注在属性上进行注入</li><li>@Resource默认是按照名称来装配注入的，如果找不到名称匹配的bean，就按照类型来装配注入</li><li>@Autowired默认是按照类型来装配注入的，要是想按照名称来注入的话，需要结合@Qualifier（夸了fai儿）注解一起使用</li><li>@Resource是jdk提供的，@Autowired是spring提供的</li></ul><h3 id="Spring中的IOC容器有哪些？有什么区别？"><a href="#Spring中的IOC容器有哪些？有什么区别？" class="headerlink" title="Spring中的IOC容器有哪些？有什么区别？"></a>Spring中的IOC容器有哪些？有什么区别？</h3><p>主要提供了<del>两种IOC容器~~~~，BeanFactory和ApplicationContext</del></p><p>BeanFactory<del>只提供了最基本的实例化对象和拿对象的功能</del></p><p>ApplicationContext继承了BeanFactory，它的作用更加强大，比如支持注解注入，国际化等功能</p><h3 id="那BeanFactory和FactoryBean又有什么区别？"><a href="#那BeanFactory和FactoryBean又有什么区别？" class="headerlink" title="那BeanFactory和FactoryBean又有什么区别？"></a>那BeanFactory和FactoryBean又有什么区别？</h3><p>相同点：都是用来创建bean对象的</p><p>不同点：使用BeanFactory创建对象的时候，我们必须严格遵循生命周期流程；如果想要简单的自定义某个对象的创建，同时创建完后想交给spring来管理，那就需要实现FactoryBean接口</p><h3 id="Repository、-Service、-Compent、-Controller它们有什么区别？"><a href="#Repository、-Service、-Compent、-Controller它们有什么区别？" class="headerlink" title="@Repository、@Service、@Compent、@Controller它们有什么区别？"></a>@Repository、@Service、@Compent、@Controller它们有什么区别？</h3><p>这四个注解的<del>本质都是一样的，都是将对象放入spring容器中，只是为了在使用上区分不同的应用分层</del></p><ul><li>@Repository：dao层</li><li>@Service：service层</li><li>@Controller：控制层</li><li>@Compent：其他不属于以上三层的统一使用这个注解</li></ul><h3 id="Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别？"></a>Spring AOP 和 AspectJ AOP 有什么区别？</h3><p>Spring AOP 是运行时增强，而AspectJ是编译时增强。</p><p>Spring AOP 已经集成了AspectJ，AspectJ比Spring AOP更强大，但是Spring AOP 相对来说更简单，如果我们切面比较少，那两者性能差别不是很大。如果切面多的话，最好使用AspectJ，它比Spring AOP快很多</p><h3 id="Spring事务中，什么情况下导致事务失效"><a href="#Spring事务中，什么情况下导致事务失效" class="headerlink" title="Spring事务中，什么情况下导致事务失效"></a>Spring事务中，什么情况下导致事务失效</h3><ul><li>方法访问权限问题，修饰符不是public</li><li>方法用final修饰，动态代理不能代理final方法</li><li>没有加@Service、@Component..注解，没有被spring去管理</li><li>数据库表不支持事务</li></ul><h3 id="Spring是怎么解决循环依赖的？"><a href="#Spring是怎么解决循环依赖的？" class="headerlink" title="Spring是怎么解决循环依赖的？"></a>Spring是怎么解决循环依赖的？</h3><p>如果在代码中，把两个或者多个bean相互之间去持有对方的引用，就会发生循环依赖，循环依赖会导致注入发生死循环，这是spring发生循环依赖的一个原因，循环依赖呢有三种形态，第一种是互相依赖，也就是A依赖B，B又依赖A，它们之间形成了一个循环依赖，第二种是三者间依赖，也就是A依赖B，B依赖C，C又依赖A，形成循环依赖，第三种是自我依赖，也就是说A依赖A形成的循环依赖，</p><p>Spring设计了三级缓存去解决循环依赖的问题，当我们通过 getBean() 去获得一个对象实例的时候，Spring会先从一级缓存去找，如果一级缓存没有，就去二级缓存找，如果一级二级都没有找到，那就意味着这个bean还没有实例化，Spring就会去实例化这个bean，然后把这个目标bean放入到二级缓存，同时加入一个标记，是表示它是否存在循环依赖，如果不存在，就把这个bean放入二级缓存，否则会标记这个bean存在循环依赖，然后再等待下一次轮询的时候去赋值，也就是解析@Autowired 注解，等@Autowired 注解赋值完成后，会将目标bean存入一级缓存</p><ul><li>一级缓存存放所有成熟的bean</li><li>二级缓存存放所有早期bean</li><li>先取一级缓存再取二级缓存</li></ul><h3 id="三级缓存的作用是什么？"><a href="#三级缓存的作用是什么？" class="headerlink" title="三级缓存的作用是什么？"></a>三级缓存的作用是什么？</h3><p>三级缓存是用来存储代理bean，在调用getBean() 的时候呢，发现目标bean需要通过代理工厂来创建，这时候会把创建好的实例保存到三级缓存，最终也会把赋值好的bean同步到一级缓存</p><h3 id="Spring在那些情况下无法解决循环依赖的问题？"><a href="#Spring在那些情况下无法解决循环依赖的问题？" class="headerlink" title="Spring在那些情况下无法解决循环依赖的问题？"></a>Spring在那些情况下无法解决循环依赖的问题？</h3><p>有四种情况下的循环依赖是无法解决的</p><p>第一种是多实例bean，通过setter注入的时候，不能解决循环依赖的问题</p><p>第二种是构造器注入bean的情况下，不能解决循环依赖的问题</p><p>第三种是单例的代理bean，通过setter注入的情况下，不能解决循环依赖问题</p><p>第四种是设置@DependsOn（弟盼的sei昂）注解的bean，不能解决循环依赖的问题</p><h1 id="十一、Spring-Boot-Spring-Cloud"><a href="#十一、Spring-Boot-Spring-Cloud" class="headerlink" title="十一、Spring Boot / Spring Cloud"></a>十一、Spring Boot / Spring Cloud</h1><h2 id="104-什么是Spring-Boot？"><a href="#104-什么是Spring-Boot？" class="headerlink" title="104.什么是Spring Boot？"></a>104.什么是Spring Boot？</h2><p>springboot主要用来简化使用spring的难度和繁锁的XML配置，它是spring组件的一站式解决方案，采取了约定大于配置的方法。通过.properties或者.yml文件代替了spring的xml配置文件，同时也支持@ImportResource注解加载xml配置，它还提供了嵌入式HTTP服务器，让开发更简单</p><h2 id="105-为什么要用Spring-Boot？"><a href="#105-为什么要用Spring-Boot？" class="headerlink" title="105.为什么要用Spring Boot？"></a>105.为什么要用Spring Boot？</h2><p>springboot可以自动装配，使用javaconfig可以避免使用xml，同时还提供了嵌入式的HTTP服务器</p><h2 id="106-Spring-Boot的核心配置文件是什么？"><a href="#106-Spring-Boot的核心配置文件是什么？" class="headerlink" title="106.Spring Boot的核心配置文件是什么？"></a>106.Spring Boot的核心配置文件是什么？</h2><p>springboot有两种类型的配置文件，application和bootstrap</p><p>bootstrap是系统级别的，优先级要比application高</p><p>bootstrap有三个使用场景：</p><ul><li>使用springcloud config配置中心时，需要在bootstrap配置文件中添加连接到配置中心的配置属性，来加载外部配置中心的配置信息</li><li>一些固定的不能被覆盖的属性</li><li>一些加密或解密的场景</li></ul><h2 id="107-Spring-Boot-配置文件有哪几种类型？它们有什么区别？"><a href="#107-Spring-Boot-配置文件有哪几种类型？它们有什么区别？" class="headerlink" title="107.Spring Boot 配置文件有哪几种类型？它们有什么区别？"></a>107.Spring Boot 配置文件有哪几种类型？它们有什么区别？</h2><p>主要有properties和yml格式，区别主要是书写格式不同，另外yml格式也不支持@PropertySource（噗绕破踢）注解导入配置</p><h2 id="108-Spring-Boot有哪些方式可以实现热部署？"><a href="#108-Spring-Boot有哪些方式可以实现热部署？" class="headerlink" title="108.Spring Boot有哪些方式可以实现热部署？"></a>108.Spring Boot有哪些方式可以实现热部署？</h2><p>这就涉及到springboot热部署的问题，只需安装devtools工具包，就能实现修改后的文件，通过Ctrl+F9来实现热更新</p><h2 id="109-springboot和spring有什么区别"><a href="#109-springboot和spring有什么区别" class="headerlink" title="109. springboot和spring有什么区别"></a>109. springboot和spring有什么区别</h2><p>springboot是spring的扩展，他使用约定大于配置的理念开发，所以使用springboot开发同样的功能，不需要像spring那样手动配置，springboot的自动装配，让各功能模块的引入和配置变得非常简单</p><p><del>spring需要手动配置，springboot实现了自动配置</del></p><h2 id="附加"><a href="#附加" class="headerlink" title="附加"></a><del>附加</del></h2><h3 id="Spring-Boot-自动装配原理？"><a href="#Spring-Boot-自动装配原理？" class="headerlink" title="Spring Boot 自动装配原理？"></a>Spring Boot 自动装配原理？</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/181/202205071832615.jpg" alt="202202212106538"></p><ul><li>@EnableAutoConfiguration注解、@Configuration注解和@ConditionalOnClass注解组成了springboot自动配置的核心，首先他得是一个配置文件，其次根据类路径下是否有这个类去自动配置。具体是通过maven读取每个starter中的spring.factories文件，这个配置文件配置了所有需要被创建在spring容器中的bean</li></ul><h3 id="什么是Spring-Boot-Starter？"><a href="#什么是Spring-Boot-Starter？" class="headerlink" title="什么是Spring Boot Starter？"></a>什么是Spring Boot Starter？</h3><p>starters可以理解为启动器，它包含了一系列可以集成到应用里面的依赖包，可以一站式集成spring和其他技术。</p><p>它的工作原理是：springboot 在启动时扫描项目依赖的jar包，然后去找包含spring.factories文件的jar包，根据spring.factories配置加载AutoConfigure类。根据@Conditional注解的条件，进行自动配置然后把bean注入到Spring Context</p><h3 id="Spring-Boot-有哪几种读取配置的方式？"><a href="#Spring-Boot-有哪几种读取配置的方式？" class="headerlink" title="Spring Boot 有哪几种读取配置的方式？"></a>Spring Boot 有哪几种读取配置的方式？</h3><p>使用@Value注解加载单个属性</p><p>使用@ConfigurationProperties注解可以加载一组属性</p><h3 id="Spring-Boot-支持哪些日志框架？推荐和默认的日志框架是哪个？"><a href="#Spring-Boot-支持哪些日志框架？推荐和默认的日志框架是哪个？" class="headerlink" title="Spring Boot 支持哪些日志框架？推荐和默认的日志框架是哪个？"></a>Spring Boot 支持哪些日志<a href="https://so.csdn.net/so/search?q=%E6%A1%86%E6%9E%B6&spm=1001.2101.3001.7020">框架</a>？推荐和默认的日志框架是哪个？</h3><p>springboot支持logging、log4j、logback，springboot默认使用logback，推荐使用log4j</p><h3 id="Spring-Boot-可以兼容老-Spring-项目吗？"><a href="#Spring-Boot-可以兼容老-Spring-项目吗？" class="headerlink" title="Spring Boot 可以兼容老 Spring 项目吗？"></a>Spring Boot 可以兼容老 Spring 项目吗？</h3><p>可以兼容，使用@ImportResource注解导入老spring项目配置文件</p><h3 id="（Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的）介绍一下-SpringBootApplication-注解"><a href="#（Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的）介绍一下-SpringBootApplication-注解" class="headerlink" title="（Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的）介绍一下 @SpringBootApplication 注解"></a>（Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的）介绍一下 @SpringBootApplication 注解</h3><p>springboot的核心注解是@SpirngBootApplication，他也是启动类使用的注解，他里面主要包含了3个注解：</p><ul><li>@SpringBootConfiguration：它组合了@Configuration注解，实现配置文件的功能</li><li>@EnableAutoConfiguration：它是自动装配的核心注解</li><li>@ComponentScan：扫表spring组件</li></ul><h3 id="你如何理解-Spring-Boot-配置加载顺序？"><a href="#你如何理解-Spring-Boot-配置加载顺序？" class="headerlink" title="你如何理解 Spring Boot 配置加载顺序？"></a>你如何理解 Spring Boot 配置加载顺序？</h3><p>排序：properties文件、yaml文件、系统环境变量、命令参数等配置文件</p><h3 id="什么是-JavaConfig？"><a href="#什么是-JavaConfig？" class="headerlink" title="什么是 JavaConfig？"></a>什么是 JavaConfig？</h3><p>javaconfig是spring社区的产品，他提供了配置spring ioc容器的纯java方法，避免使用xml配置</p><h3 id="Spring-Boot支持哪些嵌入式Web容器？"><a href="#Spring-Boot支持哪些嵌入式Web容器？" class="headerlink" title="Spring Boot支持哪些嵌入式Web容器？"></a>Spring Boot支持哪些嵌入式Web容器？</h3><p>支持Tomcat、Jetty、Undertow（按得儿头）</p><h3 id="什么是YAML"><a href="#什么是YAML" class="headerlink" title="什么是YAML?"></a>什么是YAML?</h3><p>TAML是一种可读的数据序列化语言，它通常用于配置文件</p><h3 id="YAML-配置的优势在哪里"><a href="#YAML-配置的优势在哪里" class="headerlink" title="YAML 配置的优势在哪里 ?"></a>YAML 配置的优势在哪里 ?</h3><p>配置有序</p><p>支持数组，数组中的元素可以是基本数据类型或者对象</p><p>简洁方便</p><h3 id="Spring-Boot-是否可以使用-XML-配置"><a href="#Spring-Boot-是否可以使用-XML-配置" class="headerlink" title="Spring Boot 是否可以使用 XML 配置 ?"></a>Spring Boot 是否可以使用 XML 配置 ?</h3><p>springboot可以使用xml配置，通过@ImportResource注解加载xml配置</p><h3 id="application-properties和bootstrap-properties有何区别"><a href="#application-properties和bootstrap-properties有何区别" class="headerlink" title="application.properties和bootstrap.properties有何区别 ?"></a>application.properties和bootstrap.properties有何区别 ?</h3><p>bootstrap比application优先加载，配置在应用程序上下文的引导阶段生效，而且bootstrap里面的属性不能被覆盖</p><p>application用于springboot项目的自动化配置</p><h3 id="什么是-Spring-Profiles？"><a href="#什么是-Spring-Profiles？" class="headerlink" title="什么是 Spring Profiles？"></a>什么是 Spring Profiles？</h3><p>spring profiles 允许用户根据配置文件（dev，prod，test等）来注册bean，当应用程序在开发环境中运行时，只有某些bean可以加载，而在生产环境中，某些其他bean也可以加载，比如要求swagger文档仅适用于测试环境，并且禁用所有其他文档，可以使用配置文件来完成</p><h3 id="如何在自定义端口上运行-Spring-Boot-应用程序"><a href="#如何在自定义端口上运行-Spring-Boot-应用程序" class="headerlink" title="如何在自定义端口上运行 Spring Boot 应用程序"></a>如何在自定义端口上运行 Spring Boot 应用程序</h3><p>可以在application.properties配置文件中指定端口，比如server.port=8090</p><h3 id="如何实现-Spring-Boot-应用程序的安全性？"><a href="#如何实现-Spring-Boot-应用程序的安全性？" class="headerlink" title="如何实现 Spring Boot 应用程序的安全性？"></a>如何实现 Spring Boot 应用程序的安全性？</h3><p>为了实现springboot的安全性，可以使用spring-boot-starter-security依赖，添加安全配置和重写WebSecurityConfigurerAdapter配置类的方法</p><h3 id="什么是-WebSocket？"><a href="#什么是-WebSocket？" class="headerlink" title="什么是 WebSocket？"></a>什么是 WebSocket？</h3><p>WebSocket是一种计算机通信协议，通过单个TCP连接提供全双工通信信道</p><p>WebSocket是双向的，使用WebSocket客户端或服务器可以实现消息发送</p><p>WebSocket是双全工的，客户端和服务器通信是相互独立的</p><p>WebSocket使用单个TCP连接，和http相比，WebSocket消息数据交换要轻得多</p><h3 id="Spring-Boot-中的监视器是什么？（什么是Spring-Boot-Actuator）？"><a href="#Spring-Boot-中的监视器是什么？（什么是Spring-Boot-Actuator）？" class="headerlink" title="Spring Boot 中的监视器是什么？（什么是Spring Boot Actuator）？"></a>Spring Boot 中的监视器是什么？（什么是Spring Boot Actuator）？</h3><p>springboot监视器可以访问生产环境中正在运行的应用程序的当前状态，监视器模块公开了一组可直接作为HTTP URL 访问的REST端点来检查状态</p><h3 id="如何使用-Spring-Boot-实现异常处理？"><a href="#如何使用-Spring-Boot-实现异常处理？" class="headerlink" title="如何使用 Spring Boot 实现异常处理？"></a>如何使用 Spring Boot 实现异常处理？</h3><p>使用@ControllerAdvice注解处理异常，实现一个ControllerAdvice类来处理控制器类抛出的所有异常</p><h3 id="如何监视所有-Spring-Boot-微服务？"><a href="#如何监视所有-Spring-Boot-微服务？" class="headerlink" title="如何监视所有 Spring Boot 微服务？"></a>如何监视所有 Spring Boot 微服务？</h3><p>springboot提供监视器端点监控各个微服务，这些端点对于获取有关应用程序的信息，以及它们的组件是否正常运行很有帮助，但是用监视器的一个主要缺点是，必须单独打开应用程序的知识点以了解状态或健康状况</p><h3 id="运行-Spring-Boot-有哪几种方式？"><a href="#运行-Spring-Boot-有哪几种方式？" class="headerlink" title="运行 Spring Boot 有哪几种方式？"></a>运行 Spring Boot 有哪几种方式？</h3><p>用命令打包放到容器中运行</p><p>用maven插件运行</p><p>直接执行main方法运行</p><h3 id="springboot中如何解决跨域问题"><a href="#springboot中如何解决跨域问题" class="headerlink" title="springboot中如何解决跨域问题"></a><strong>springboot中如何解决跨域问题</strong></h3><p>跨域都是通过前端JSONP来解决的，但是只能处理get类型请求，像post、put、delete就不支持，所以一般采用后端跨域通过WebMvcConfiguration接口来重写addCorsMappings方法，解决跨域问题</p><h3 id="在springboot微服务设计中，如何实现session共享"><a href="#在springboot微服务设计中，如何实现session共享" class="headerlink" title="在springboot微服务设计中，如何实现session共享"></a><strong>在springboot微服务设计中，如何实现session共享</strong></h3><p>在微服务中以为一个项目可以被拆成多个子项目，导致内存中session不一致，可以采用spring session + redis的方式，把session统一保存在redis中</p><p><del>———————————————————————————————————————————————————–</del></p><h2 id="110-什么是-Spring-Cloud？"><a href="#110-什么是-Spring-Cloud？" class="headerlink" title="110. 什么是 Spring Cloud？"></a><strong>110. 什么是 Spring Cloud？</strong></h2><p>Spring Cloud是一系列框架的有序集合，他利用Spring Boot的开发便利性简化了分布式系统基础设施的开发，比如服务发现注册、配置中心、负载均衡、断路器等，都可以用Spring Boot的开发风格做到一键启动和部署。</p><h2 id="111-什么是断路器？"><a href="#111-什么是断路器？" class="headerlink" title="111. 什么是断路器？"></a><strong>111. 什么是断路器？</strong></h2><p>当一个服务调用另一个服务由于网络原因或者其他原因出现问题，调用者就会等待被调用者的响应，如果更多的服务请求会导致更多请求等待，发生连锁效应（服务雪崩）</p><p>断路器有三种状态：</p><ul><li>打开状态：一段时间内达到一定的次数无法调用，并且多次监测没有恢复的迹象，断路器完全打开，那么下次请求就不会请求到该服务</li><li>半开状态：短时间内有恢复迹象，断路器会将部分请求发给服务，正常调用时，断路器关闭</li><li>关闭状态：当服务一直处于正常状态，能正常调用</li></ul><h2 id="112-spring-cloud-的核心组件有哪些？"><a href="#112-spring-cloud-的核心组件有哪些？" class="headerlink" title="112. spring cloud 的核心组件有哪些？"></a><strong>112. spring cloud 的核心组件有哪些？</strong></h2><ul><li>Eureka：服务注册与发现</li><li>Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发送请求</li><li>Ribbon：实现负载均衡，从一个服务的多台机器中选择一台</li><li>Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题</li><li>Zuul：网关管理，有 Zuul 网关转发请求给对应的服务</li><li>Config：配置中心</li></ul><h2 id="附加：-4"><a href="#附加：-4" class="headerlink" title="附加："></a><del>附加：</del></h2><h3 id="谈谈你对微服务的理解？"><a href="#谈谈你对微服务的理解？" class="headerlink" title="谈谈你对微服务的理解？"></a>谈谈你对微服务的理解？</h3><p>就是将单体应用根据业务拆分成多个服务，每个服务提供单个业务功能的服务，一个服务只做一件事。</p><h3 id="服务注册和发现是什么意思？Spring-Cloud如何实现？"><a href="#服务注册和发现是什么意思？Spring-Cloud如何实现？" class="headerlink" title="服务注册和发现是什么意思？Spring Cloud如何实现？"></a>服务注册和发现是什么意思？Spring Cloud如何实现？</h3><p>当我们开始一个项目时，我们通常在属性文件中进行所有配置，当服务越来越多的时候添加和修改这些属性就变的很复杂，有些服务可能会下降。手动更改属性可能会产生问题。Eureka服务注册和发现可以在这种情况下提供帮助，因为所有服务都在Eureka服务器上注册并通过调用Eureka服务器来查找，所以不需要处理服务地点的任何更改和处理</p><h3 id="什么是Eureka？"><a href="#什么是Eureka？" class="headerlink" title="什么是Eureka？"></a>什么是Eureka？</h3><p>eureka是服务注册中心，系统中的其他服务使用eureka的客户端连接到eureka服务中，并且保持心跳，这样工作人员可以通过eureka服务来监控各个微服务是否运行正常</p><h3 id="Eureka怎么实现高可用"><a href="#Eureka怎么实现高可用" class="headerlink" title="Eureka怎么实现高可用"></a>Eureka怎么实现高可用</h3><p>集群吧，注册多台eureka，然后把springcloud服务互相注册，客户端从eureka获取信息时，按照eureka的顺序来访问</p><h3 id="Eureka和ZooKeeper都可以提供服务注册与发现的功能-请说说两个的区别？"><a href="#Eureka和ZooKeeper都可以提供服务注册与发现的功能-请说说两个的区别？" class="headerlink" title="Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别？"></a>Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别？</h3><ol><li>zookeeper中的节点服务挂了就要选举，在选举期间注册服务瘫痪，虽然服务最终会恢复，但是选举期间是不可用的，选举就是微服务做了集群，必须有一台主其他的都是从</li><li>eureka各个节点都是平等关系，服务挂了没关系，只要有一台eureka就可以保证服务可用，数据都是最新的，如果查询到的数据不是最新的，就是因为eureka的自我保护模式导致的</li><li>eureka本质上是一个工程，而zookeeper只是一个进程</li><li>eureka可以很好的应对因为网络故障导致部分节点失去联系的情况，不会像zookeeper一样使整个注册系统瘫痪</li></ol><h3 id="分别描述springcloud组件的原理？"><a href="#分别描述springcloud组件的原理？" class="headerlink" title="分别描述springcloud组件的原理？"></a>分别描述springcloud组件的原理？</h3><p><del>Eureka（注册发现）</del></p><p>作用：实现服务治理（服务注册与发现）</p><p>由两个组件组成：Eureka服务端和客户端</p><p>Eureka服务端就是服务注册中心。支持集群部署</p><p>Eureka客户端是一个Java客户端，用来处理服务注册与发现</p><p><strong>在应用启动时，Eureka客户端向服务端注册自己的服务信息，同时把服务端的服务信息缓存到本地。客户端会和服务端周期性的进行心跳交互，来更新服务信息</strong></p><p><del>Ribbon</del></p><p>作用：Ribbon，负载均衡</p><p>简介：Spring Cloud Ribbon 是一个基于HTTP和TCP的客户端负载均衡工具，它基于Netfilx</p><p>Ribbon实现：通过Spring Cloud的封装，可以让我们轻松的将面向服务的REST模板请求自动转换成客户端负载均衡的服务调用</p><p>负载策略：随机、轮询、权重、重试、最低并发、可用过滤、响应时间加权重</p><p><del>Hystrix</del></p><p>作用：断路器、保护系统、控制故障范围</p><p>简介：为了保证高可用，单个服务通常会集群部署。由于网络原因或自身原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，这时如果有大量请求过来，会导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的后果，这就是服务故障的 “雪崩” 效验</p><p><del>Zuul</del></p><p>作用：API网关，路由，负载均衡等多种作用</p><p>简介：类似nginx，反向代理的功能，不过netfix自己增加了一些配合其他组件的特性。</p><p>在微服务架构中，后端服务往往不直接开放给调用端，而是通过一个API网关根据请求的URL，路由到相应的服务。当添加API网关后，在第三方调用端和服务提供方之间就创建了一面墙，这面墙直接与调用方通信进行权限控制，后将请求均衡分发给后台服务器 </p><p><del>Feign</del></p><p>作用：服务与服务之间的调用</p><p><del>Config</del></p><p>作用：管理配置</p><p>简介：Spirng Cloud Config提供服务器端和客户端。服务器存储后端的默认实现使用git，因此它轻松支持标签版本的配置环境，以及可以访问用于管理内容的各种工具，这个还是静态的，得配合Spring Cloud Bus实现动态的配置更新</p><h3 id="什么是Hystrix-断路器？我们需要它吗？"><a href="#什么是Hystrix-断路器？我们需要它吗？" class="headerlink" title="什么是Hystrix 断路器？我们需要它吗？"></a>什么是Hystrix 断路器？我们需要它吗？</h3><p>因为一些原因，公开服务会引发异常。在这种情况下使用Hystrix定义了一个回退的方法。如果在公开服务中发生异常，就回退方法返回一些默认值</p><p>断路器的目的是给第一页方法或第一页方法可能调用的其它方法留出时间，并导致异常恢复。可能发生的情况是，在负载比较小的情况下，导致异常的问题有更好的恢复机会</p><p><img src="https://img-blog.csdnimg.cn/20210420195518875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ4Nzk1NjA3,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="什么是Spring-Cloud-Bus？我们需要它吗？"><a href="#什么是Spring-Cloud-Bus？我们需要它吗？" class="headerlink" title="什么是Spring Cloud Bus？我们需要它吗？"></a>什么是Spring Cloud Bus？我们需要它吗？</h3><p>Spring Cloud Bus提供了跨多个实例刷新配置的功能。如果我们有多个微服务启动并运行，这就特别有用，这是通过将所有微服务连接到各个消息代理来实现的。不管什么时候刷新实例，这个事件都会订阅到侦听这个代理的所有服务，并且它们也会刷新，可以通过使用端点/总线/刷新来实现对任何单个实例的刷新</p><h3 id="SpringBoot和SpringCloud的区别？"><a href="#SpringBoot和SpringCloud的区别？" class="headerlink" title="SpringBoot和SpringCloud的区别？"></a>SpringBoot和SpringCloud的区别？</h3><p>SpringBoot专注快速开发单个个体微服务</p><p>SpringCloud是关注全局的微服务协调整理框架，它把spring boot开发的一个个单体服务整合管理起来，为各个微服务提供配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、分布式会话等集成服务</p><p>SpringBoot可以离开SpringCloud独立使用开发项目，但是SpringCloud离不开SpringBoot，属于依赖的关系，SpringBoot专注快速方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架</p><h3 id="Spring-Cloud和dubbo区别"><a href="#Spring-Cloud和dubbo区别" class="headerlink" title="Spring Cloud和dubbo区别?"></a>Spring Cloud和dubbo区别?</h3><ol><li>服务调用方式：dubbo是RPC；SpringCloud是Rest API</li><li>注册中心：dubbo是zookeeper；SpringCloud是eureka，也可以是zookeeper</li><li>服务网关：dubbo本身没有实现，只能通过第三方技术整合，SpringCloud有Zuul</li></ol><h3 id="什么是网关？"><a href="#什么是网关？" class="headerlink" title="什么是网关？"></a>什么是网关？</h3><p>网关相当于一个网络服务架构的入口，所有网络请求必须通过网关转发到具体的服务】</p><h3 id="网关的作用是什么？"><a href="#网关的作用是什么？" class="headerlink" title="网关的作用是什么？"></a>网关的作用是什么？</h3><p>统一管理微服务请求，权限控制、负载均衡、路由转发、监控、安全控制黑名单和白名单等</p><h3 id="什么是Spring-Cloud-Zuul（服务网关）"><a href="#什么是Spring-Cloud-Zuul（服务网关）" class="headerlink" title="什么是Spring Cloud Zuul（服务网关）"></a>什么是Spring Cloud Zuul（服务网关）</h3><ul><li>Zuul是对SpringCloud提供的路由方案，他会根据请求的路径不同，网关会定位到指定的微服务，代理请求到不同的微服务接口，他对外隐蔽了微服务的真正接口地址。三个重要概念：动态路由表，路由定位，反向代理：<ul><li>动态路由表：Zuul支持eureka路由，手动配置路由，这两种都支持自动更新</li><li>路由定位：根据请求路径，Zuul有自己的一套定位服务规则以及路由表达式匹配</li><li>反向代理：客户端请求到路由网关，网关受理之后，在对目标发送请求，拿到响应之后在给客户端</li></ul></li><li>它可以和eureka、ribbon、hystrix等组件配合使用</li><li>Zuul的应用场景：<ul><li>对外暴露，权限校验，服务聚合，日志审计等</li></ul></li></ul><h3 id="网关与过滤器有什么区别？"><a href="#网关与过滤器有什么区别？" class="headerlink" title="网关与过滤器有什么区别？"></a>网关与过滤器有什么区别？</h3><p>网关是对所有服务的请求进行分析过滤，过滤器是对单个服务而言</p><h3 id="常用网关框架有那些？"><a href="#常用网关框架有那些？" class="headerlink" title="常用网关框架有那些？"></a>常用网关框架有那些？</h3><p>Nginx、Zuul、Gateway</p><h3 id="既然Nginx可以实现网关？为什么还需要使用Zuul框架"><a href="#既然Nginx可以实现网关？为什么还需要使用Zuul框架" class="headerlink" title="既然Nginx可以实现网关？为什么还需要使用Zuul框架"></a>既然Nginx可以实现网关？为什么还需要使用Zuul框架</h3><p>Zuul是SpringCloud集成的网关，可以对SpringCloud架构提供更灵活的服务</p><h3 id="如何设计一套API接口？"><a href="#如何设计一套API接口？" class="headerlink" title="如何设计一套API接口？"></a>如何设计一套API接口？</h3><p>考虑到API接口的分类可以将API接口分为开放API接口和内网API接口，内网API接口用于局域网，为内部服务器提供服务。开放API接口用于对外部合作单位提供接口调用，需要遵循Oauth2.0权限认证协议。同时还需要考虑安全性、幂等性问题</p><h3 id="负载平衡的意义什么？"><a href="#负载平衡的意义什么？" class="headerlink" title="负载平衡的意义什么？"></a>负载平衡的意义什么？</h3><p>简单来说，先建集群，集群就是把一个人的事情交给多个人去做，加入要做1000个产品给一个人做要10天，叫10个人做就是1天，这就是集群，负载均衡的话就是用来控制集群，平均分配</p><h3 id="Ribbon是什么？"><a href="#Ribbon是什么？" class="headerlink" title="Ribbon是什么？"></a>Ribbon是什么？</h3><ul><li>ribbon是netfix发布的开源项目，主要功能是提供客户端的软件负载均衡算法</li><li>ribbon客户端组件提供一系列完善的配置项，比如超时连接，重试等。简单来说，就是在配置文件中列出后面所有的机器，ribbon会自动帮你去连接这些机器</li></ul><h3 id="Ribbon底层实现原理？"><a href="#Ribbon底层实现原理？" class="headerlink" title="Ribbon底层实现原理？"></a>Ribbon底层实现原理？</h3><p>ribbon使用discoveryClient从注册中心读取目标服务信息，对同一接口请求进行计数，使用%取余算法获取目标服务集群索引，返回获取到的目标服务信息</p><h3 id="LoadBalanced注解的作用"><a href="#LoadBalanced注解的作用" class="headerlink" title="@LoadBalanced注解的作用"></a><strong>@LoadBalanced注解的作用</strong></h3><p>开启客户端负载均衡</p><h3 id="什么是Hystrix？"><a href="#什么是Hystrix？" class="headerlink" title="什么是Hystrix？"></a>什么是Hystrix？</h3><p>在分布式系统，我们一定会依赖各种服务，那么这些服务一定会出现失败的情况，就会导致雪崩，Hystrix就是一个防雪崩的工具，它有服务降级，服务熔断，服务隔离，监控等一些防止雪崩的技术</p><p>四种防雪崩方式：</p><ul><li>服务降级：接口调用失败就调用本地的方法返回一个空</li><li>服务熔断：接口调用失败就会进入调用接口前定义好的一个熔断方法，返回错误信息</li><li>服务隔离：为隔离的服务开启一个独立的线程池，这样在高并发的情况下不会影响其他服务</li><li>服务监控：在服务发生调用时，会将每秒请求数、成功请求数等运行指标记录下来</li></ul><h3 id="谈谈服务雪崩效应？"><a href="#谈谈服务雪崩效应？" class="headerlink" title="谈谈服务雪崩效应？"></a>谈谈服务雪崩效应？</h3><ul><li><p>雪崩效应是当某个服务发生宕机时，调用这个服务的其他服务也会发生宕机，大型项目的微服务之间的调用是互通的，这样就会将服务的不可用逐步扩大到其他服务，从而使整个项目的服务宕机崩溃</p><p>发生雪崩效应的原因有以下几点</p></li><li><p>单个服务的代码存在bug</p></li><li><p>请求访问量激增导致服务发生崩溃</p></li><li><p>服务器的硬件故障也会导致部分服务不可用</p></li></ul><h3 id="在微服务中，如何保护服务"><a href="#在微服务中，如何保护服务" class="headerlink" title="在微服务中，如何保护服务?"></a>在微服务中，如何保护服务?</h3><p>一般使用hystrix框架，实现服务隔离来避免出现服务雪崩效应，从而能达到保护服务的效果</p><h3 id="什么是Feign？"><a href="#什么是Feign？" class="headerlink" title="什么是Feign？"></a>什么是Feign？</h3><p>feign是一个声明web服务客户端</p><p>它把我们需要调用的服务方法定义成抽象方法保存在本地，不需要构建http请求，直接调用接口就行了</p><h3 id="SpringCloud有几种调用接口方式？"><a href="#SpringCloud有几种调用接口方式？" class="headerlink" title="SpringCloud有几种调用接口方式？"></a>SpringCloud有几种调用接口方式？</h3><ul><li>Feign</li><li>RestTemplate</li></ul><h3 id="Ribbon和Feign调用服务的区别？"><a href="#Ribbon和Feign调用服务的区别？" class="headerlink" title="Ribbon和Feign调用服务的区别？"></a>Ribbon和Feign调用服务的区别？</h3><ul><li>ribbon需要我们自己构建http请求，模拟http请求然后通过RestTemplate发给其他服务</li><li>feign是在ribbon的基础上进行了一次改进，采用接口的方式，把我们需要调用的服务方法定义成抽象方法保存在本地就可以，不需要自己构建http请求，直接调用接口</li></ul><h3 id="什么是Spring-Cloud-Config"><a href="#什么是Spring-Cloud-Config" class="headerlink" title="什么是Spring Cloud Config?"></a>什么是Spring Cloud Config?</h3><p>Spring Cloud Config为分布式系统中的外部配置提供服务器和客户端支持，可以方便的对微服务各个环境下的配置进行集中式管理。Spring Cloud Config分为Config Server 和Config Client两部分。Config Server负责读取配置文件，并暴露API接口，Config Client通过调用Config Server的接口来读取配置文件</p><h3 id="分布式配置中心的作用？"><a href="#分布式配置中心的作用？" class="headerlink" title="分布式配置中心的作用？"></a>分布式配置中心的作用？</h3><p>可以动态改变项目配置信息，并且不用重新部署项目</p><h3 id="SpringCloud-Config可以实现实时刷新吗？"><a href="#SpringCloud-Config可以实现实时刷新吗？" class="headerlink" title="SpringCloud Config可以实现实时刷新吗？"></a>SpringCloud Config可以实现实时刷新吗？</h3><p>SpringCloud Config实时刷新采用Spring Cloud Bus消息总线</p><h1 id="十二、Hibernate"><a href="#十二、Hibernate" class="headerlink" title="十二、Hibernate"></a><strong>十二、Hibernate</strong></h1><h2 id="113-为什么要使用hibernate？"><a href="#113-为什么要使用hibernate？" class="headerlink" title="113.为什么要使用hibernate？"></a>113.为什么要使用hibernate？</h2><ul><li>hibernate 是对 jdbc 的封装，大大简化了数据访问层的繁琐的重复性代码</li><li>hibernate 是一个优秀的 ORM 实现，很多程度上简化了 DAO 层的编码功能</li><li>可以很方便的进行数据库的移植工作</li><li>提供了缓存机制，使程序执行被更改的高效</li></ul><h2 id="114-什么是-ORM-框架？"><a href="#114-什么是-ORM-框架？" class="headerlink" title="114.什么是 ORM 框架？"></a>114.什么是 ORM 框架？</h2><p>ORM（Object Relation Mapping）对象关系映射，是把数据库中的关系数据映射成为程序中的对象</p><p>使用 ORM 的优点：提高了开发效率降低了开发成本、开发更简单更对象化、可移植更强</p><h2 id="115-hibernate-中如何在控制台查看打印的-SQL-语句"><a href="#115-hibernate-中如何在控制台查看打印的-SQL-语句" class="headerlink" title="115.hibernate 中如何在控制台查看打印的 SQL 语句"></a>115.hibernate 中如何在控制台查看打印的 SQL 语句</h2><p>在 Config 里面把 hibernate.show_SQL 设置为 true 就可以，但不建议开启，开启之后会降低程序的运行效率</p><h2 id="116-hibernate-有几种查询方式"><a href="#116-hibernate-有几种查询方式" class="headerlink" title="116.hibernate 有几种查询方式"></a>116.hibernate 有几种查询方式</h2><p>三种：hql、原生 SQL、条件查询 Criteria</p><h2 id="117-hibernate-实体类可以被定义为-final吗？"><a href="#117-hibernate-实体类可以被定义为-final吗？" class="headerlink" title="117.hibernate 实体类可以被定义为 final吗？"></a>117.hibernate 实体类可以被定义为 final吗？</h2><p>实体类可以定义为 final，但这样的话就不能使用 hibernate 代理模式下的延迟关联提供性能了，所以不建议定义实体类为 final</p><h2 id="118-hibernate-中使用-Integer-和-int-做映射有什么区别？"><a href="#118-hibernate-中使用-Integer-和-int-做映射有什么区别？" class="headerlink" title="118.hibernate 中使用 Integer 和 int 做映射有什么区别？"></a>118.hibernate 中使用 Integer 和 int 做映射有什么区别？</h2><p>Integer 类型为对象，它的值允许为 null，而 int 属于基本数据类型，值不能为 null</p><h2 id="119-hibernate-是如何工作的？"><a href="#119-hibernate-是如何工作的？" class="headerlink" title="119.hibernate 是如何工作的？"></a>119.hibernate 是如何工作的？</h2><ul><li>读取并解析配置文件</li><li>读取并解析映射文件，创建 SessionFactory</li><li>打开 Session</li><li>创建事务</li><li>进行持久化操作</li><li>提交事务</li><li>关闭 Session</li><li>关闭 SessionFactory</li></ul><h2 id="120-get-和-load-的区别？"><a href="#120-get-和-load-的区别？" class="headerlink" title="120.get() 和 load() 的区别？"></a>120.get() 和 load() 的区别？</h2><ul><li>数据查询时，没有 OID 指定的对象，get() 返回 null；load() 返回一个代理对象</li><li>load() 支持延迟加载；get() 不支持延迟加载</li></ul><h2 id="121-说一下-hibernate-的缓存机制？"><a href="#121-说一下-hibernate-的缓存机制？" class="headerlink" title="121.说一下 hibernate 的缓存机制？"></a>121.说一下 hibernate 的缓存机制？</h2><p>hibernate 常用的缓存有一级缓存和二级缓存</p><p>一级缓存：也叫 Session 缓存，只在 Session 作用范围内有效，不需要用户干涉，有 hibernate 自身维护，可以通过：evict(Object) 清除 object 的缓存；clear() 清除一级缓存中的所有数据；flush() 刷出缓存</p><p>二级缓存：应用级别的缓存，在所有 Session 中都有效，支持配置第三方的缓存，如：EhCache</p><h2 id="122-hibernate-对象有哪些状态？"><a href="#122-hibernate-对象有哪些状态？" class="headerlink" title="122.hibernate 对象有哪些状态？"></a>122.hibernate 对象有哪些状态？</h2><ul><li>临时/瞬时状态：直接 new 出来的对象，该对象还没被持久化（没保存数据库中），不受 Session 管理</li><li>持久化状态：当调用 Session 的 save/saveOrupdate/get/load/list 等方法的时候，对象就是持久化状态</li><li>游离状态：Session 关闭之后就是游离状态</li></ul><h2 id="123-在-hibernate-中-getCurrentSession-和-openSession-的区别是什么？"><a href="#123-在-hibernate-中-getCurrentSession-和-openSession-的区别是什么？" class="headerlink" title="123.在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？"></a>123.在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？</h2><ul><li>getCurrentSession 会绑定当前线程，而 openSession 不会</li><li>getCurrentSession 事务是 Spring 控制的，并且不需要手动关闭，而 openSession 需要我们自己手动开启和提交事务</li></ul><h2 id="124-hibernate-实体类必须要有无参构造函数吗？为什么？"><a href="#124-hibernate-实体类必须要有无参构造函数吗？为什么？" class="headerlink" title="124.hibernate 实体类必须要有无参构造函数吗？为什么？"></a>124.hibernate 实体类必须要有无参构造函数吗？为什么？</h2><p>hibernate 中每个实体类必须提供一个无参构造函数，以为 hibernate 框架要使用 reflection api，通过调用 ClassnewInstance() 来创建实体类的实例，如果没有无参的构造函数就会抛出异常</p><h1 id="十三、Mybatis"><a href="#十三、Mybatis" class="headerlink" title="十三、Mybatis"></a><strong>十三、Mybatis</strong></h1><h2 id="125-mybatis-中-和-的区别是什么？"><a href="#125-mybatis-中-和-的区别是什么？" class="headerlink" title="125. mybatis 中 #{}和 ${}的区别是什么？"></a><strong>125. mybatis 中 #{}和 ${}的区别是什么？</strong></h2><ul><li>{}是预编译处理，${}是字符串替换</li><li>Mybatis在处理#{}时，会将sql中的#{}替换为？号占位符，调用PreparedStatement（per派尔的死得个门特）的set方法来赋值</li><li>Mybatis在处理${}时，就是把${}替换成变量的值</li><li>使用#{}可以有效防止SQL注入，提高系统安全性</li></ul><h2 id="126-mybatis-有几种分页方式？"><a href="#126-mybatis-有几种分页方式？" class="headerlink" title="126. mybatis 有几种分页方式？"></a><strong>126. mybatis 有几种分页方式？</strong></h2><p>分页方式：逻辑分页和物理分页</p><ul><li>逻辑分页：使用Mybatis自带的RowBounds进行分页，它是一次性查询很多数据，然后在数据中再进行检索</li><li>物理分页：手写sql分页或者使用分页插件PageHelper，去数据库查询指定条数的分页数据的形式</li></ul><h2 id="127-RowBounds-是一次性查询全部结果吗？为什么？"><a href="#127-RowBounds-是一次性查询全部结果吗？为什么？" class="headerlink" title="127.RowBounds 是一次性查询全部结果吗？为什么？"></a>127.RowBounds 是一次性查询全部结果吗？为什么？</h2><p>RowBounds 表面是在所有数据中检索数据，其实并不是一次性查询出所有数据，以为 Mybatis 是对 JDBC 的封装，在 JDBC 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如我要查询更多数据，它会在你执行 next() 的时候，去查询更多的数据，就好比我去自动取款机取 10000 元，但取款机每次最多能取 2000 元，所以要取5次才能取完，只是对于 JDBC 来说，当你调用 next() 的时候会自动帮你完成查询工作，这样做的好处可以有效防止内存溢出</p><h2 id="128-Mybatis-逻辑分页和物理分页的区别是什么？"><a href="#128-Mybatis-逻辑分页和物理分页的区别是什么？" class="headerlink" title="128.Mybatis 逻辑分页和物理分页的区别是什么？"></a>128.Mybatis 逻辑分页和物理分页的区别是什么？</h2><ul><li>逻辑分页是先查出来，然后利用代码去取需要的部分</li><li>物理分页是利用 sql 自带的 limit 去实现，本身查询出来的数据就是分好页的 </li></ul><h2 id="129-Mybatis-是否支持延迟加载？延迟加载的原理是什么？"><a href="#129-Mybatis-是否支持延迟加载？延迟加载的原理是什么？" class="headerlink" title="129.Mybatis 是否支持延迟加载？延迟加载的原理是什么？"></a>129.Mybatis 是否支持延迟加载？延迟加载的原理是什么？</h2><p>Mybatis 支持延迟加载，设置 lazyLoadingEnabled为true即可</p><p>延迟加载的原理是调用的时候触发加载，而不是在初始化的时候就加载信息，比如调用 a.getB()，这时候发现 a.getB() 的值为 null，此时会单独触发事先保存好的关联 B 对象的 SQL，先查询出来 B，然后在调用 a.setB(b)，而这时候在调用a.getB().getName()，就有值了，这就是延迟加载的基本原理</p><h2 id="130-说一下-Mybatis-的一级缓存和二级缓存？"><a href="#130-说一下-Mybatis-的一级缓存和二级缓存？" class="headerlink" title="130.说一下 Mybatis 的一级缓存和二级缓存？"></a>130.说一下 Mybatis 的一级缓存和二级缓存？</h2><ul><li>一级缓存：基于 PerpetualCache（per拍车哦开吃）的 HashMap 本地缓存，他的生命周期是和 SQLSession 一致的，有多个 SQLSession 或者分布式的环境中数据库操作，可能会出现脏数据。当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认一级缓存是开启的</li><li>二级缓存：也是基于 PerpetualCache 的 HashMap 本地缓存，不同在于其存储作用域为 Mapper 级别的，如果多个 SQLSession 之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口</li></ul><p>开启二级缓存数据查询流程：二级缓存 -&gt; 一级缓存 -&gt; 数据库</p><p>缓存更新机制：当某一个作用域进行了 Mapper进行了增删改操作后，默认该作用域下所有缓存被清除</p><h2 id="131-Mybatis-和-hibernate-的区别有哪些？"><a href="#131-Mybatis-和-hibernate-的区别有哪些？" class="headerlink" title="131.Mybatis 和 hibernate 的区别有哪些？"></a>131.Mybatis 和 hibernate 的区别有哪些？</h2><ul><li>灵活性：Mybatis 更加灵活，自己可以写 SQL 语句，使用起来比较方便</li><li>可移植性：Mybatis 有很多自己写的 SQL，以为每个数据库的 SQL 可以不同，所以移植性比较差</li><li>学习和使用门槛：Mybatis 入门比较简单，使用门槛也更低</li><li>二级缓存：hibernate 拥有更好的二级缓存，他的二级缓存可以自行更换为第三方的二级缓存</li></ul><h2 id="132-Mybatis-有哪些执行器（Executor）？"><a href="#132-Mybatis-有哪些执行器（Executor）？" class="headerlink" title="132.Mybatis 有哪些执行器（Executor）？"></a>132.Mybatis 有哪些执行器（Executor）？</h2><p>Mybatis 有三种基本的执行器</p><ul><li>SimpleExecutor：每执行一次 update 或者 select 就开启一个 Statement 对象，用完立刻关闭 Statement 对象</li><li>ReuseExecutor：执行 update 和 select，以 SQL 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后不关闭 Statement 对象，而是放置于 Map 内供下一次使用，总而言之，就是重复使用 Statement  对象</li><li>BatchExecutor：执行 update 没有 select，jdbc 批处理不支持 select，将所有 SQL 都添加到批处理中，等待统一执行，它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch() 完毕后，等待逐一执行 executeBatch() 批处理，于 jdbc 批处理相同</li></ul><h2 id="133-Mybatis-分页插件的实现原理是什么？"><a href="#133-Mybatis-分页插件的实现原理是什么？" class="headerlink" title="133.Mybatis 分页插件的实现原理是什么？"></a>133.Mybatis 分页插件的实现原理是什么？</h2><p>分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截等待执行的 SQL，然后重写 SQL，根据方言添加对应的物理分页语句和参数</p><h2 id="134-Mybatis-如何编写一个自定义插件？"><a href="#134-Mybatis-如何编写一个自定义插件？" class="headerlink" title="134.Mybatis 如何编写一个自定义插件？"></a>134.Mybatis 如何编写一个自定义插件？</h2><p><strong>自定义插件实现原理</strong></p><p>Mybatis 自定义插件针对 Mybatis 四大对象（Executor、StatementHandler、ParameleHandler、ResultSetHandler）进行拦截</p><ul><li>Executor：拦截内容执行器，它负责调用 StatementHandler 操作数据库，并把结果集通过 ResultSetHandler进行自动映射，另外它还处理了二级缓存的操作</li><li>StatementHandler：拦截 SQL 语法构建的处理，它是 Mybatis 直接和数据库执行 SQL 脚本的对象，另外它也实现了 Mybatis 的一级缓存</li><li>ParameleHandler：拦截参数的处理</li><li>ResultSetHandler：拦截结果集的处理</li></ul><p><strong>自定义插件实现的关键</strong></p><p>Mybatis 插件要实现 Interceptor接口，接口包含的方法，如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interceptor</span> </span>&#123;   <br>   <span class="hljs-function">Object <span class="hljs-title">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable</span>;       <br>   <span class="hljs-function">Object <span class="hljs-title">plugin</span><span class="hljs-params">(Object <span class="hljs-keyword">target</span>)</span></span>;    <br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setProperties</span><span class="hljs-params">(Properties properties)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>setProperties 方法是在 Mybatis 进行配置插件的时候可以配置自定义相关属性。即：接口实现对象的参数配置</li><li>plugin 方法是插件用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理，可以决定是否要进行拦截而决定要返回一个什么样的目标对象，官方提供了示例：return Plugin wrap(target， this)</li><li>intercept 方法就是要进行拦截的时候要执行的方法</li></ul><p><strong>自定义插件实现实例</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Intercepts</span>(&#123;<span class="hljs-meta">@Signature</span>(<span class="hljs-keyword">type</span> = <span class="hljs-title class_">Executor</span>. <span class="hljs-keyword">class</span>, method = <span class="hljs-string">&quot;query&quot;</span>,<br>        args = &#123;<span class="hljs-title class_">MappedStatement</span>. <span class="hljs-keyword">class</span>, <span class="hljs-title class_">Object</span>. <span class="hljs-keyword">class</span>, <span class="hljs-title class_">RowBounds</span>. <span class="hljs-keyword">class</span>, <span class="hljs-title class_">ResultHandler</span>. <span class="hljs-keyword">class</span>&#125;)&#125;)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">intercept</span>(<span class="hljs-title class_">Invocation</span> invocation) throws <span class="hljs-title class_">Throwable</span> &#123;<br>     <span class="hljs-title class_">Object</span> target = invocation. <span class="hljs-title function_">getTarget</span>(); <span class="hljs-comment">//被代理对象</span><br>     <span class="hljs-title class_">Method</span> method = invocation. <span class="hljs-title function_">getMethod</span>(); <span class="hljs-comment">//代理方法</span><br>     <span class="hljs-title class_">Object</span>[] args = invocation. <span class="hljs-title function_">getArgs</span>(); <span class="hljs-comment">//方法参数</span><br>     <span class="hljs-comment">// do something . . . . . .  方法拦截前执行代码块</span><br>     <span class="hljs-title class_">Object</span> result = invocation. <span class="hljs-title function_">proceed</span>();<br>     <span class="hljs-comment">// do something . . . . . . . 方法拦截后执行代码块</span><br>     <span class="hljs-keyword">return</span> result;<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">plugin</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> target</span>) &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-title class_">Plugin</span>. <span class="hljs-title function_">wrap</span>(target, <span class="hljs-variable language_">this</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="十四、RabbitMQ"><a href="#十四、RabbitMQ" class="headerlink" title="十四、RabbitMQ"></a>十四、RabbitMQ</h1><h2 id="135-RabbitMQ-的使用场景有哪些？"><a href="#135-RabbitMQ-的使用场景有哪些？" class="headerlink" title="135.RabbitMQ 的使用场景有哪些？"></a>135.RabbitMQ 的使用场景有哪些？</h2><ul><li>抢购活动，进行流量削峰，防止系统崩溃</li><li>延迟信息处理，比如 10 分钟之后给下单未付款的用户发送短信提醒</li><li>解耦系统，对于新增的功能可以单独写模块扩展，比如用户确认评价之后，新增了给用户返积分的功能，这个时候不用在业务代码里添加新增积分的功能，只需要把新增积分的接口订阅，确认评价的消息队列即可，后面再添加任何功能只需要订阅对应的消息队列即可</li></ul><h2 id="136-RabbitMQ-有哪些重要的角色？"><a href="#136-RabbitMQ-有哪些重要的角色？" class="headerlink" title="136.RabbitMQ 有哪些重要的角色？"></a>136.RabbitMQ 有哪些重要的角色？</h2><p>RabbitMQ 中重要的角色有：生产者、消费者和代理</p><ul><li>生产者：消费的创建者，负责创建和推送数据到消息服务器</li><li>消费者：消息的接收方，用于处理数据和确认消息</li><li>代理：就是 RabbitMQ 本身，用于扮演 “快递” 的角色，本身不产生消息</li></ul><h2 id="137-RabbitMQ-有哪些重要的组件？"><a href="#137-RabbitMQ-有哪些重要的组件？" class="headerlink" title="137.RabbitMQ 有哪些重要的组件？"></a>137.RabbitMQ 有哪些重要的组件？</h2><ul><li>ConnectionFactory（连接管理器）：应用程序与 RabbitMQ 之间建立连接的管理器，程序代码中使用</li><li>Channel（信道）：消息推送使用的通道</li><li>Exchange（交换机）：用于接收、分配消息</li><li>Queue（队列）：用于存储生产者的消息</li><li>RoutingKey（路由键）：用于把生产者的数据分配到交换机上</li><li>BindingKey（绑定键）：用于把交换机的消息绑定到队列上</li></ul><h2 id="138-RabbitMQ-中-vhost-的作用是什么？"><a href="#138-RabbitMQ-中-vhost-的作用是什么？" class="headerlink" title="138.RabbitMQ 中 vhost 的作用是什么？"></a>138.RabbitMQ 中 vhost 的作用是什么？</h2><p>vhost：每个 MQ 都能创建很多 vhost，我们称之为虚拟主机，每个虚拟主机其实都是小型的 MQ，它拥有自己的队列，交换机和绑定，拥有自己的权限机制</p><h2 id="139-RabbitMQ-的消息是怎么发送的？"><a href="#139-RabbitMQ-的消息是怎么发送的？" class="headerlink" title="139.RabbitMQ 的消息是怎么发送的？"></a>139.RabbitMQ 的消息是怎么发送的？</h2><p>首先客户端必须连接到 RabbitMQ 服务器才能发送和消费消息，客户端和 rabbit 服务之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证，客户端和 MQ 就创建了一条 amqp 信道（channel），信道是创建在 tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的</p><h2 id="140-RabbitMQ-怎么保证消息的稳定性？"><a href="#140-RabbitMQ-怎么保证消息的稳定性？" class="headerlink" title="140.RabbitMQ 怎么保证消息的稳定性？"></a>140.RabbitMQ 怎么保证消息的稳定性？</h2><ul><li>提供了事务的功能</li><li>通过将 channel 设置为 confirm（确认）模式</li></ul><h2 id="141-RabbitMQ-怎么避免消息丢失？"><a href="#141-RabbitMQ-怎么避免消息丢失？" class="headerlink" title="141.RabbitMQ 怎么避免消息丢失？"></a>141.RabbitMQ 怎么避免消息丢失？</h2><ul><li>把消息持久化磁盘，保证服务器重启消息不丢失</li><li>每个集群中至少有一个物理磁盘，保证消息落入磁盘</li></ul><h2 id="142-要保证消息持久化成功的条件有哪些？"><a href="#142-要保证消息持久化成功的条件有哪些？" class="headerlink" title="142.要保证消息持久化成功的条件有哪些？"></a>142.要保证消息持久化成功的条件有哪些？</h2><ul><li>声明队列必须设置持久化 durable（肚儿bo）为 true</li><li>消息推送投递模式必须设置持久化，deliveryMode（肚来福瑞mo的）设置为 2</li><li>消息已经到达持久化交换器</li><li>消息已经到达持久化队列</li></ul><p>以上四个条件都满足才能保证消息持久化成功</p><h2 id="143-RabbitMQ-持久化有什么缺点？"><a href="#143-RabbitMQ-持久化有什么缺点？" class="headerlink" title="143.RabbitMQ 持久化有什么缺点？"></a>143.RabbitMQ 持久化有什么缺点？</h2><p>持久化的缺点就是降低了服务器的吞吐量，因为使用的是磁盘而不是内存存储</p><h2 id="144-RabbitMQ-有几种广播类型？"><a href="#144-RabbitMQ-有几种广播类型？" class="headerlink" title="144.RabbitMQ 有几种广播类型？"></a>144.RabbitMQ 有几种广播类型？</h2><ul><li>direct（的ruai可特）（默认方式）：最基础最简单的模式，发送方把消息发给订阅方，如果有多个订阅者，默认采用轮询的方式进行消息发送</li><li>headers：与 direct 类似，只是性能很差，这个类型几乎用不到</li><li>fanout：分发模式，把消息分发给所有订阅者</li><li>topic（掏皮可）：匹配订阅模式，使用正则匹配到消息队列，能匹配到的都能接收到</li></ul><h2 id="145-RabbitMQ-怎么实现延迟消息队列？"><a href="#145-RabbitMQ-怎么实现延迟消息队列？" class="headerlink" title="145.RabbitMQ 怎么实现延迟消息队列？"></a>145.RabbitMQ 怎么实现延迟消息队列？</h2><p>延迟队列的实现方式：</p><ul><li>通过消息过期后进入死信交换器，再由交换器转发到延迟队列，实现延迟功能</li><li>使用 RabbitMQ-delayed(的累特) message-exchange 插件实现延迟功能</li></ul><h2 id="146-RabbitMQ-集群有什么用？"><a href="#146-RabbitMQ-集群有什么用？" class="headerlink" title="146.RabbitMQ 集群有什么用？"></a>146.RabbitMQ 集群有什么用？</h2><p>集群主要有以下两个用途：</p><ul><li>高可用：某个服务器出现问题，整个 RabbitMQ 还可以继续使用</li><li>高容量：集群可以承载更多的消息量</li></ul><h2 id="147-RabbitMQ-节点的类型有哪些？"><a href="#147-RabbitMQ-节点的类型有哪些？" class="headerlink" title="147.RabbitMQ 节点的类型有哪些？"></a>147.RabbitMQ 节点的类型有哪些？</h2><ul><li>磁盘节点：消息会存储到磁盘</li><li>内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型</li></ul><h2 id="148-RabbitMQ-集群搭建需要注意哪些问题？"><a href="#148-RabbitMQ-集群搭建需要注意哪些问题？" class="headerlink" title="148.RabbitMQ 集群搭建需要注意哪些问题？"></a>148.RabbitMQ 集群搭建需要注意哪些问题？</h2><ul><li>各节点之间使用 “–link” 连接，这个属性不能忽略</li><li>各节点使用的 erlang cookie 值必须相同，这个值相当于一个密钥，用于各节点的认证</li><li>整个集群中必须包含一个磁盘节点</li></ul><h2 id="149-RabbitMQ-每个节点是其他节点的完成拷贝吗？为什么？"><a href="#149-RabbitMQ-每个节点是其他节点的完成拷贝吗？为什么？" class="headerlink" title="149.RabbitMQ 每个节点是其他节点的完成拷贝吗？为什么？"></a>149.RabbitMQ 每个节点是其他节点的完成拷贝吗？为什么？</h2><p>不是，原因有两个：</p><ul><li>存储空间的考虑：如果每个节点都拥有所有队列的完整拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据</li><li>性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至可能更糟</li></ul><h2 id="150-RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么情况？"><a href="#150-RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么情况？" class="headerlink" title="150.RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？"></a>150.RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？</h2><p>如果唯一磁盘的节点崩溃了，不能进行以下操作：</p><ul><li>不能创建队列</li><li>不能创建交换机</li><li>不能创建绑定</li><li>不能添加用户</li><li>不能更改权限</li><li>不能添加和删除集群节点</li></ul><p>唯一磁盘崩溃了，集群是可以保持运行的，但是不能改动任何东西</p><h2 id="151-RabbitMQ-对集群节点停止顺序有要求吗？"><a href="#151-RabbitMQ-对集群节点停止顺序有要求吗？" class="headerlink" title="151.RabbitMQ 对集群节点停止顺序有要求吗？"></a>151.RabbitMQ 对集群节点停止顺序有要求吗？</h2><p>RabbitMQ 对集群的停止的顺序是有要求的，应该先关闭内存节点，最后在关闭磁盘节点。如果顺序反了的话，可能会造成消息丢失</p><h1 id="十五、Kafka"><a href="#十五、Kafka" class="headerlink" title="十五、Kafka"></a>十五、Kafka</h1><h2 id="152-Kafka-可以脱离-zookeeper-单独使用吗？为什么？"><a href="#152-Kafka-可以脱离-zookeeper-单独使用吗？为什么？" class="headerlink" title="152.Kafka 可以脱离 zookeeper 单独使用吗？为什么？"></a>152.Kafka 可以脱离 zookeeper 单独使用吗？为什么？</h2><p>Kafka 不能脱离 zookeeper 单独使用，因为 Kafka 使用 zookeeper 管理和协调 Kafka 的节点服务器</p><h2 id="153-Kafka-有几种数据保留的策略？"><a href="#153-Kafka-有几种数据保留的策略？" class="headerlink" title="153.Kafka 有几种数据保留的策略？"></a>153.Kafka 有几种数据保留的策略？</h2><p>Kafka 有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留</p><h2 id="154-Kafka-同时设置了-7-天和-10G-清除数据，到第五天的时候消息到达了-10-G，这个时候-Kafka-将如何处理？"><a href="#154-Kafka-同时设置了-7-天和-10G-清除数据，到第五天的时候消息到达了-10-G，这个时候-Kafka-将如何处理？" class="headerlink" title="154.Kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息到达了 10 G，这个时候 Kafka 将如何处理？"></a>154.Kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息到达了 10 G，这个时候 Kafka 将如何处理？</h2><p>这个时候 Kafka 会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据</p><h2 id="155-什么情况会导致-Kafka-运行变慢？"><a href="#155-什么情况会导致-Kafka-运行变慢？" class="headerlink" title="155.什么情况会导致 Kafka 运行变慢？"></a>155.什么情况会导致 Kafka 运行变慢？</h2><ul><li>cpu 性能瓶颈</li><li>磁盘读写瓶颈</li><li>网络瓶颈</li></ul><h2 id="156-使用-Kafka-集群需要注意什么？"><a href="#156-使用-Kafka-集群需要注意什么？" class="headerlink" title="156.使用 Kafka 集群需要注意什么？"></a>156.使用 Kafka 集群需要注意什么？</h2><ul><li>集群的数量不是越多越好，最好不要超过 7 个，因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低</li><li>集群数量最好是单数，因为超过一半故障集群就不能用了，设置为单数容错率更高</li></ul><h1 id="十六、Zookeeper"><a href="#十六、Zookeeper" class="headerlink" title="十六、Zookeeper"></a>十六、Zookeeper</h1><h2 id="157-zookeeper-是什么？"><a href="#157-zookeeper-是什么？" class="headerlink" title="157.zookeeper 是什么？"></a>157.zookeeper 是什么？</h2><p>zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 Hadoop 和 hbase 的重要组件，它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等</p><h2 id="158-zookeeper-都有哪些功能？"><a href="#158-zookeeper-都有哪些功能？" class="headerlink" title="158.zookeeper 都有哪些功能？"></a>158.zookeeper 都有哪些功能？</h2><ul><li>集群管理：控制节点存活状态、运行请求等</li><li>主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮的选主，主节点选举说的就是这个选举的过程，使用zookeeper可以协助完成这个过程</li><li>分布式锁：zookeeper 提供两种锁：独占锁、共享锁，独占锁就是一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制</li><li>命名服务：在分布式系统中，通过使用命名规则，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息</li></ul><h2 id="159-zookeeper-有几种部署模式？"><a href="#159-zookeeper-有几种部署模式？" class="headerlink" title="159.zookeeper 有几种部署模式？"></a>159.zookeeper 有几种部署模式？</h2><p>zookeeper 有三种部署模式：</p><ul><li>单机部署：一台集群上运行</li><li>集群部署：多台集群运行</li><li>伪集群部署：一台集群启动多个 zookeeper 实例运行</li></ul><h2 id="160-zookeeper-怎么保证主从节点的状态同步？"><a href="#160-zookeeper-怎么保证主从节点的状态同步？" class="headerlink" title="160.zookeeper 怎么保证主从节点的状态同步？"></a>160.zookeeper 怎么保证主从节点的状态同步？</h2><p>zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态</p><h2 id="161-集群中为什么要有主节点？"><a href="#161-集群中为什么要有主节点？" class="headerlink" title="161.集群中为什么要有主节点？"></a>161.集群中为什么要有主节点？</h2><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点</p><h2 id="162-集群中有-3-台服务器，其中一个节点宕机，这个时候-zookeeper-还可以使用吗？"><a href="#162-集群中有-3-台服务器，其中一个节点宕机，这个时候-zookeeper-还可以使用吗？" class="headerlink" title="162.集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？"></a>162.集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？</h2><p>可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用</p><h2 id="163-说一下-zookeeper-的通知机制？"><a href="#163-说一下-zookeeper-的通知机制？" class="headerlink" title="163.说一下 zookeeper 的通知机制？"></a>163.说一下 zookeeper 的通知机制？</h2><p>客户端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变</p><h1 id="十七、MySQL"><a href="#十七、MySQL" class="headerlink" title="十七、MySQL"></a>十七、MySQL</h1><h2 id="164-数据库的三范式是什么？"><a href="#164-数据库的三范式是什么？" class="headerlink" title="164.数据库的三范式是什么？"></a>164.数据库的三范式是什么？</h2><ul><li>第一范式：强调的是列的原子性，就是数据库表的每一列都是不可分割的原子数据项</li><li>第二范式：每一行的数据只能与其中一列相关，即一行数据只做一件事。只要数据列中出现数据重复，就要把表拆分开来</li><li>第三范式：数据不能存在传递关系，就是每个属性都跟主键有直接关系而不是间接关系</li></ul><h2 id="165-一张自增表里总共有-7-条数据，删除了最后-2-条数据，重启-MySQL-数据库，又插入了一条数据，此时-id-是几？"><a href="#165-一张自增表里总共有-7-条数据，删除了最后-2-条数据，重启-MySQL-数据库，又插入了一条数据，此时-id-是几？" class="headerlink" title="165.一张自增表里总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？"></a>165.一张自增表里总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？</h2><ul><li>表类型如果是 MyISAM（mai ai sei 母），那 id 就是 8</li><li>表类型如果是 InnoDB，那 id 就是 6</li></ul><p>InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失</p><h2 id="166-如何获取当前数据库版本？"><a href="#166-如何获取当前数据库版本？" class="headerlink" title="166.如何获取当前数据库版本？"></a>166.如何获取当前数据库版本？</h2><p>使用 select version() 获取当前数据库版本</p><h2 id="167-说一下-ACID-是什么？"><a href="#167-说一下-ACID-是什么？" class="headerlink" title="167.说一下 ACID 是什么？"></a>167.说一下 ACID 是什么？</h2><ul><li>Atomicity（原子性）：一个事务中的操作要么全部成功，要么全部失败</li><li>Consistency（一致性）：数据库从一个一致性状态转换到另一个一致性的状态</li><li>Isolation（隔离性）：一个事务修改在最终提交之前，对其他事务不可见</li><li>Durability（持久化）：事务一旦提交，所做的修改就会永久保存在数据库中</li></ul><h2 id="168-char-和-varchar-的区别是什么？"><a href="#168-char-和-varchar-的区别是什么？" class="headerlink" title="168.char 和 varchar 的区别是什么？"></a>168.char 和 varchar 的区别是什么？</h2><ul><li>char(n)：固定长度类型，比如设定长度为10，输入了 “abc” 三个字符，他的占用空间还是 10，其他 7 个是空字节</li><li>varchar(n)：可变长度，存储的值是每个值占用的字节再加上一个用来记录长度的字节的长度，所以，从空间上考虑 varchar 比较合适，从效率上考虑 char 比较合适，二者使用需要权衡</li></ul><h2 id="169-float-和-double-的区别是什么？"><a href="#169-float-和-double-的区别是什么？" class="headerlink" title="169.float 和 double 的区别是什么？"></a>169.float 和 double 的区别是什么？</h2><ul><li>float 最多可以存储 8 位的十进制数，并在内存中占 4 字节</li><li>double 最多可以存储 16 位的十进制数，并在内存中占 8 字节</li></ul><h2 id="170-MySQL-的内连接、左连接、右连接有什么区别？"><a href="#170-MySQL-的内连接、左连接、右连接有什么区别？" class="headerlink" title="170.MySQL 的内连接、左连接、右连接有什么区别？"></a>170.MySQL 的内连接、左连接、右连接有什么区别？</h2><p>内连接是把匹配的关联数据显示出来</p><p>左连接是把左边的表的所有数据显示出来，右边的表显示出符合条件的数据，不符合的显示 null</p><p>右连接是把右边的表的所有数据显示出来，左边的表显示出符合条件的数据，不符合的显示 null</p><h2 id="171-MySQL-索引的基本原理？"><a href="#171-MySQL-索引的基本原理？" class="headerlink" title="171.MySQL 索引的基本原理？"></a>171.MySQL 索引的基本原理？</h2><ul><li>索引的底层是一个B+Tree结构，目的就是缩小扫描范围，避免全表扫描</li><li>首先像主键或者唯一约束的字段会自动加一个索引，表的每一条记录都会有一个存储编号</li><li>索引在不同的存储引擎中都是以B+Tree形式存在的</li><li>首先它会在底层进行排序，假如第一个 id 的索引是 100，那么就从 100 开始，第二个是 99，就放在二叉树的左边，第三个是120，就放在右边，遵循左小右大的原则排序</li><li>进行查找的时候，从 where 子句后如果字段有索引，就从二叉树中去匹配，匹配的时候会将字段等值转换为每一条记录的存储编号，可以快速定位到</li></ul><h2 id="172-怎么验证-MySQL-的索引是否满足需求？"><a href="#172-怎么验证-MySQL-的索引是否满足需求？" class="headerlink" title="172.怎么验证 MySQL 的索引是否满足需求？"></a>172.怎么验证 MySQL 的索引是否满足需求？</h2><p>使用 explain 查看 SQL 是怎么执行查询语句的，从而分析索引是否满足需求</p><p>explain 语法：explain select * from table where type = 1</p><h2 id="173-说一下数据库的事务隔离？"><a href="#173-说一下数据库的事务隔离？" class="headerlink" title="173.说一下数据库的事务隔离？"></a>173.说一下数据库的事务隔离？</h2><ul><li>READ-UNCOMMITTED（未提交读）：最低的隔离级别，事务为提交前，就可以被其他事务读取（会出现幻读、脏读、不可重复读）</li><li>READ-COMMITTED（提交读）：一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）</li><li>REPEATABLE-READ（可重复读）：默认级别，保证多次读取同一数据时，数据都和事务开始的时候的内容是一致的，禁止读取到别的事务未提交的数据（会造成幻读）</li><li>SERIALIZABLE（序列化）：代价最高但是最可靠的级别，这个隔离级别可以防止脏读、幻读、不可重复读</li></ul><p><strong>脏读：</strong>表示一个事务能够读取另一个事务中还未提交的数据，比如：某个事务尝试插入记录 A，这时候事务还没有提交，然后另一个事务尝试读取到了记录 A</p><p><strong>不可重复读：</strong>是指在一个事务内，多次读同一条数据</p><p><strong>幻读：</strong>指同一个事务内多次查返回的结果集不一样，比如同一个事务 A 第一次查询的时候有 10 条记录，但是第二次查询却有 11 条记录，发生幻读的原因也是另外一个事务新增或删除或修改了第一个事务结果集里面的数据</p><h2 id="174-说一下-MySQL-常用引擎？"><a href="#174-说一下-MySQL-常用引擎？" class="headerlink" title="174.说一下 MySQL 常用引擎？"></a>174.说一下 MySQL 常用引擎？</h2><ul><li>InnoDB：MySQL5.1 后默认的数据库引擎，提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲区，用于缓冲数据和索引。但是这个引擎是不支持全文搜索，同时启动也比较慢，它是不会保存表的行数的，所以当进行 <code>select count(*) from table</code> 指令的时候，需要进行全表扫描，由于锁的粒度小，写操作是不会锁定全表的，所以在并发度比较高的场景下使用会提升效率的</li><li>MyISAM：不提供事务的支持，也不支持行级锁和外键，因此当执行插入和更新数据时，即执行写操作需要锁定这个表，所以会导致效率降低。不过和 InnoDB 不同的是，MyISAM 引擎是保存了表的行数，当进行 <code>select count(*) from table</code> 语句时，可以直接读取已经保存的值不需要进行全表扫描。所以，如果表的读操作多于写操作时，并且不需要事务的支持，可以将 MySQL 作为数据库引擎的首选</li></ul><h2 id="175-说一下-MySQL-的行锁和表锁？"><a href="#175-说一下-MySQL-的行锁和表锁？" class="headerlink" title="175.说一下 MySQL 的行锁和表锁？"></a>175.说一下 MySQL 的行锁和表锁？</h2><p>MySQL 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁</p><ul><li>表锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低</li><li>行锁：开销大，加锁慢，会出现死锁。锁定粒度小，发生锁冲突的概率小，并发度最高</li></ul><h2 id="176-说一下乐观锁和悲观锁？"><a href="#176-说一下乐观锁和悲观锁？" class="headerlink" title="176.说一下乐观锁和悲观锁？"></a>176.说一下乐观锁和悲观锁？</h2><ul><li>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一个在此期间别人有没有去更新这个数据</li><li>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次拿数据的时候都会上锁，这样别人想那这个数据就会阻止，直到这个锁被释放</li></ul><p>数据库的乐观锁和悲观锁需要自己实现，在表里添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比以下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁</p><h2 id="177-MySQL-问题排查都有哪些手段？"><a href="#177-MySQL-问题排查都有哪些手段？" class="headerlink" title="177.MySQL 问题排查都有哪些手段？"></a>177.MySQL 问题排查都有哪些手段？</h2><ul><li>使用 show processlist 命令查看当前数据库的所有连接信息</li><li>使用 explain 命令查询 SQL 语句执行计划</li><li>开启慢查询日志，查看慢查询的 SQL</li></ul><h2 id="178-如何做-MySQL-的性能优化？"><a href="#178-如何做-MySQL-的性能优化？" class="headerlink" title="178.如何做 MySQL 的性能优化？"></a>178.如何做 MySQL 的性能优化？</h2><ul><li>为搜索字段创建索引</li><li>避免使用 select *，列出需要查询的字段</li><li>选择正确的存储引擎</li></ul><h2 id="附加：-5"><a href="#附加：-5" class="headerlink" title="附加："></a><del>附加：</del></h2><h3 id="索引适用场景"><a href="#索引适用场景" class="headerlink" title="索引适用场景"></a>索引适用场景</h3><ul><li>数据量大</li><li>经常出现在 where 后面的字段</li><li>该字段很少 DML（因为每次的增删改都会使索引重新排序）</li></ul><h3 id="索引失效的场景"><a href="#索引失效的场景" class="headerlink" title="索引失效的场景"></a>索引失效的场景</h3><ul><li>模糊查询时，百分号在前面 “%T”</li><li>or 条件拼接的时候，有一方的字段不是索引</li><li>复合索引，或者索引字段参与运算</li></ul><h3 id="ACID靠什么来保证"><a href="#ACID靠什么来保证" class="headerlink" title="ACID靠什么来保证"></a>ACID靠什么来保证</h3><ul><li>A原子性由 undo log 日志来保证，记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的 sql</li><li>C一致性由其他三大特性保证，程序代码保证业务上的一致性</li><li>I隔离性由 MVCC 来保证</li><li>D持久性是由 内存 + undo log 来保证的</li></ul><h3 id="简述-MyISAM-和-InnoDB-的区别"><a href="#简述-MyISAM-和-InnoDB-的区别" class="headerlink" title="简述 MyISAM 和 InnoDB 的区别"></a>简述 MyISAM 和 InnoDB 的区别</h3><ul><li>MyISAM ：不支持事务，每次查询都是原子的</li><li>InnoDB ：支持 ACID 事务</li></ul><h3 id="谈谈你对Mysql的MVCC的理解"><a href="#谈谈你对Mysql的MVCC的理解" class="headerlink" title="谈谈你对Mysql的MVCC的理解"></a>谈谈你对Mysql的MVCC的理解</h3><p>MVCC的实现，通过保存数据在某个时间点的快照来实现的。这意味着一个事务无论运行多长时间，在同一个事务里能够看到数据一致的视图。根据事务开始的时间不同，同时也意味着在同一个时刻不同事务看到的相同表里的数据可能是不同的。</p><h3 id="一个需求，按照-abc-三个字段进行查询，a-xxx-b-gt-xxx-c-xxx-怎么去建索引"><a href="#一个需求，按照-abc-三个字段进行查询，a-xxx-b-gt-xxx-c-xxx-怎么去建索引" class="headerlink" title="一个需求，按照 abc 三个字段进行查询，a=xxx,b&gt;xxx,c=xxx, 怎么去建索引"></a>一个需求，按照 abc 三个字段进行查询，a=xxx,b&gt;xxx,c=xxx, 怎么去建索引</h3><p>复合索引 acb</p><h3 id="数据库中索引分为哪几种？"><a href="#数据库中索引分为哪几种？" class="headerlink" title="数据库中索引分为哪几种？"></a>数据库中索引分为哪几种？</h3><ul><li>普通索引：仅加速查询</li><li>唯一索引：加速查询 + 列值唯一（可以有null）</li><li>主键索引：加速查询 + 列值唯一（可以有null） + 表中只有一个</li><li>复合 索引：多列值组成一个索引，专门用于组合搜索，效率大于索引合并</li><li>全文索引：对文本的内容进行分词，进行搜索</li></ul><h3 id="InnoDB-执行一条update更新语句的时候mysql会上一个什么锁？"><a href="#InnoDB-执行一条update更新语句的时候mysql会上一个什么锁？" class="headerlink" title="InnoDB 执行一条update更新语句的时候mysql会上一个什么锁？"></a>InnoDB 执行一条update更新语句的时候mysql会上一个什么锁？</h3><p>看看有没有添加索引，没有添加索引默认就是表锁，添加了索引就是行锁</p><h1 id="十八、Redis"><a href="#十八、Redis" class="headerlink" title="十八、Redis"></a>十八、Redis</h1><h2 id="179-Redis-是什么？都有哪些使用场景？"><a href="#179-Redis-是什么？都有哪些使用场景？" class="headerlink" title="179.Redis 是什么？都有哪些使用场景？"></a>179.Redis 是什么？都有哪些使用场景？</h2><p>Redis 是一个使用 C 语言开发的高速缓存数据库</p><p>Redis 使用场景：</p><ul><li>记录帖子点赞数、点击数、评论数</li><li>缓存近期的热帖</li><li>缓存文章详情信息</li><li>记录用户会话信息</li></ul><h2 id="180-Redis-有哪些功能？"><a href="#180-Redis-有哪些功能？" class="headerlink" title="180.Redis 有哪些功能？"></a>180.Redis 有哪些功能？</h2><ul><li>数据缓存功能</li><li>分布式锁功能</li><li>支持数据持久化</li><li>支持事务</li><li>支持消息队列</li></ul><h2 id="181-Redis-和-memcache-有什么区别？"><a href="#181-Redis-和-memcache-有什么区别？" class="headerlink" title="181.Redis 和 memcache 有什么区别？"></a>181.Redis 和 memcache 有什么区别？</h2><ul><li>存储方式不同：memcache 把数据全部存在内存中，断电之后会挂掉，数据不能超过内存大小；Redis 有部分在硬盘上，这样能保证数据的持久性</li><li>数据支持类型：memcache 对数据类型支持相对简单；Redis 有复杂的数据类型</li><li>使用底层模型不同：它们之间底层实现的方式，以及与客户端之间通信的应用协议不一样，Redis 自己构建了 vm 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求</li><li>value 值大小不同：Redis 最大可以达到 512mb；memcache 只有 1mb</li></ul><h2 id="182-Redis-为什么是单线程的？"><a href="#182-Redis-为什么是单线程的？" class="headerlink" title="182.Redis 为什么是单线程的？"></a>182.Redis 为什么是单线程的？</h2><p>因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最高有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了</p><p>关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求</p><p>而且单线程并不代表慢 nginx 和 nodejs 也都是高性能单线程的代表</p><h2 id="183-什么是缓存穿透？怎么解决？"><a href="#183-什么是缓存穿透？怎么解决？" class="headerlink" title="183.什么是缓存穿透？怎么解决？"></a>183.什么是缓存穿透？怎么解决？</h2><p>缓存穿透就是指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据就不写入缓存，这就导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透</p><p>解决方案：最简单粗暴的方法就是如果一个查询返回的数据为空，我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟</p><h2 id="184-Redis-支持的数据类型有哪些？"><a href="#184-Redis-支持的数据类型有哪些？" class="headerlink" title="184.Redis 支持的数据类型有哪些？"></a>184.Redis 支持的数据类型有哪些？</h2><p>Redis 支持的数据类型：string（字符串）、list（列表）、hash（字典）、set（集合）、zset（有序集合）</p><h2 id="185-Redis-支持的-Java-客户端都有哪些？"><a href="#185-Redis-支持的-Java-客户端都有哪些？" class="headerlink" title="185.Redis 支持的 Java 客户端都有哪些？"></a>185.Redis 支持的 Java 客户端都有哪些？</h2><p>支持的 Java 客户端有 Redisson、jedis、lettuce（来忒死）等</p><h2 id="186-jedis-和-Redisson-有哪些区别？"><a href="#186-jedis-和-Redisson-有哪些区别？" class="headerlink" title="186.jedis 和 Redisson 有哪些区别？"></a>186.jedis 和 Redisson 有哪些区别？</h2><ul><li>jedis：提供了比较全面的 Redis 命令的支持</li><li>Redisson：实现了分布式和可扩展的 Java 数据结构，与 jedis 相比 Redission 的功能相对简单，不支持排序、事务、管道、分区等 Redis 特性</li></ul><h2 id="187-怎么保证缓存和数据库数据的一致性？"><a href="#187-怎么保证缓存和数据库数据的一致性？" class="headerlink" title="187.怎么保证缓存和数据库数据的一致性？"></a>187.怎么保证缓存和数据库数据的一致性？</h2><ul><li>合理设置缓存的过期时间</li><li>新增、更改、删除数据库操作的同时更新 Redis，可以使用事务机制来保证数据的一致性</li></ul><h2 id="188-Redis-持久化有几种方式？"><a href="#188-Redis-持久化有几种方式？" class="headerlink" title="188.Redis 持久化有几种方式？"></a>188.Redis 持久化有几种方式？</h2><p>Redis 的持久化有两种方式，或者说有两种策略：</p><ul><li>RDB：指定的时间间隔能对你的数据进行快照存储</li><li>AOF：每一个收到的写命令都通过 write 函数追加到文件中‘</li></ul><h2 id="189-Redis-怎么实现分布式锁？"><a href="#189-Redis-怎么实现分布式锁？" class="headerlink" title="189.Redis 怎么实现分布式锁？"></a>189.Redis 怎么实现分布式锁？</h2><p>Redis 分布式锁其实就是在系统里面占一个坑，其他程序也要占坑的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试</p><p>占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁</p><h2 id="190-Redis-分布式锁有什么缺陷？"><a href="#190-Redis-分布式锁有什么缺陷？" class="headerlink" title="190.Redis 分布式锁有什么缺陷？"></a>190.Redis 分布式锁有什么缺陷？</h2><p>Redis 分布式锁不能解决超时问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题</p><h2 id="191-Redis-如何做内存优化？"><a href="#191-Redis-如何做内存优化？" class="headerlink" title="191.Redis 如何做内存优化？"></a>191.Redis 如何做内存优化？</h2><p>尽量使用 Redis 的散列表，把相关的信息放到散列表里面存储，而不是把每个字段单独存储，这样可以有效的减少内存使用，比如 web 系统的用户对象，应该放到散列表里面再整体存储到 Redis，而不是把用户的姓名、年龄、密码等字段分别设置 key 进行存储</p><h2 id="192-Redis-淘汰策略有哪些？"><a href="#192-Redis-淘汰策略有哪些？" class="headerlink" title="192.Redis 淘汰策略有哪些？"></a>192.Redis 淘汰策略有哪些？</h2><ul><li>volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</li><li>volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰</li><li>volatile-random：从已设置过期时间的数据集中任意选择数据淘汰</li><li>allkeys-lru：从数据集中挑选最近最少使用的数据淘汰</li><li>allkeys-random：从数据集中任意选择数据淘汰</li><li>no-enviction（驱逐）：禁止驱逐数据</li></ul><h2 id="193-Redis-常见的性能问题有哪些？该如何解决？"><a href="#193-Redis-常见的性能问题有哪些？该如何解决？" class="headerlink" title="193.Redis 常见的性能问题有哪些？该如何解决？"></a>193.Redis 常见的性能问题有哪些？该如何解决？</h2><ul><li>主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响比较大，会间断性暂停服务，所以主服务器最好不要写内存快照</li><li>Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内</li></ul><h2 id="附加：-6"><a href="#附加：-6" class="headerlink" title="附加："></a><del>附加：</del></h2><h3 id="AOF-和-RDB-的区别"><a href="#AOF-和-RDB-的区别" class="headerlink" title="AOF 和 RDB 的区别"></a>AOF 和 RDB 的区别</h3><p>无法承受数分钟以内的丢失，可用 AOF；能承受并且要求数据集的恢复速度，选用 RDB</p><p>区别：</p><ul><li>AOF 存储速度比 RDB 快</li><li>AOF 恢复速度比 RDB 要慢，因为 AOF 存的是过程，需要执行</li><li>安全性就得看 AOF 选用那种策略了，RDB 是一定会丢失数据的</li><li>AOF 资源消耗比 RDB 低</li><li>AOF 优先级大于 RDB</li></ul><h3 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h3><p>记录数据的过程（当数据需要恢复时，将过程重新执行一遍就行）</p><p>解决数据持久化的实时性（主流）</p><p><strong>AOF 写数据的过程</strong></p><ul><li>客户端发送指令，它不会立即执行，会先向指令存入缓冲区，生成一个 AOF 文件，到达一定阶段就会将指令同步到 AOF 文件中</li><li>至于什么时候同步提供了三个阶段<ul><li>alaways（每次）：每次都会同步进 AOF 文件，数据 0 误差，但是效率低</li><li>everysec（每秒）：每秒会同步一次，数据精确性高，但是也会丢失 1 秒的数据，性能较高</li><li>no（系统控制）：有操作系统控制的，整体不可控</li></ul></li><li>appendonly  yes|no：开启持久化配置（默认关闭）</li></ul><p><strong>AOF 写数据遇到的问题</strong></p><ul><li>如果同一个 key 设置多次，那么前几次是不是属于无效数据呢，就没必要执行</li><li>重写<ul><li>作用：提高持久化效率，数据恢复效率，磁盘利用率</li><li>规则<ul><li>进行内超时的数据就不写入 AOF 文件了</li><li>忽略无效指令，只保留最终数据的写入命令</li><li>对同一数据的多条写入命令，合并为一条</li></ul></li></ul></li></ul><p><strong>AOF 工作原理</strong></p><ul><li>eveysec开启重写的流程<ul><li>首先执行 set 指令，进入主进程开启一个子进程 fork</li><li>在存进缓存区的时候，会开出一个 AOF 重写的缓存区，它为重写提供数据</li><li>执行 bgrewriteaof 指令，进入主进程，开启一个子进程，它会发一段提示信息，表示正在执行</li><li>然后会创建一个重写后的 aof 文件，里面的数据是由之前的缓存区提供的</li><li>最后和执行 set 指令的那段子进程的 aof 文件进行替换</li></ul></li></ul><p><strong>RDB 持久化</strong></p><ul><li>存储量大，效率低</li><li>基于快照思想，bgsave 会开一个子进程</li><li>丢失数据，因为快照思想是记录某个时间点的数据</li></ul><p><strong>事务</strong></p><ul><li>事务的执行流程<ul><li>写一个指令 set，它会判断你在不在事务状态，怎么判断呢，他会识别你这个指令，因为你是 set 普通指令，所以直接执行，返回结果</li><li>如果说是 multi 开启事务，那么就不是一个普通指令了，它会创建一个队列，返回一个 ok，接下来你在输入一个 set 普通命令的话，他会把你这个放入队列中，返回一个 queued 已在队列的信息，直到你输入的是 exec 执行事务，才会将队列一起执行，然后返回结果</li><li>如果执行了 discard，取消事务，那么就会销毁这个队列，返回一个 ok</li></ul></li><li>事务的注意事项<ul><li>没有那个自动回滚，只能靠自己在代码中实现手动回滚，最好是不要敲错</li><li>基于特定条件的事务执行-锁<ul><li>watch 对 key 添加一个监视锁，在执行 exec 之前发生变换，就会终止这个事务执行</li></ul></li></ul></li></ul><p><strong>过期键的删除策略</strong></p><ul><li>惰性过期<ul><li>只有当访问一个 key 时，才会判断 key 是否已经过期，可能会出现大量过期 key 没有被访问，也不会被清理</li></ul></li><li>定期过期<ul><li>每隔一段时间会定期去清理那些过期的 key</li></ul></li></ul><h3 id="什么是缓存穿透？怎么解决？"><a href="#什么是缓存穿透？怎么解决？" class="headerlink" title="什么是缓存穿透？怎么解决？"></a>什么是缓存穿透？怎么解决？</h3><p>缓存穿透是指缓存中查询一个不存在的数据，需要去数据库中获取。如果数据库中也获取不到结果，就不会同步到缓存，导致这个不存在的数据每次请求都要到数据库查询，失去了缓存的意义</p><p>解决方案：</p><p>1、布隆过滤</p><p>将所有查询的参数都存储到一个 bitmap 中，在查询缓存之前，先在 bitmap 里进行验证。如果 bitmap 存在，就进行底层缓存的数据查询；如果 bitmap 不存在，就进行拦截，不再进行缓存的数据查询</p><p>2、缓存空对象</p><p>如果查询返回的数据为空，就把这个空结果进行缓存，那么再用相同的 key 获取数据的时候，即使不存在数据，缓存也可以直接返回空值，避免重复访问数据库</p><h3 id="什么是缓存雪崩？怎么解决？"><a href="#什么是缓存雪崩？怎么解决？" class="headerlink" title="什么是缓存雪崩？怎么解决？"></a>什么是缓存雪崩？怎么解决？</h3><p>在集中的一段时间内，有大量的缓存失效，导致大量的访问没有命中缓存，导致将所有查询进行数据库访问，数据库压力增大，从而造成缓存雪崩</p><p>比如说现在要做一个促销活动，我们把商品信息都刷新到缓存，过期时间统一为 30 分钟，那么在 30 分钟之后，这批商品全部过期，这时候这批商品的访问查询，都落到了数据库，对数据库而言，这一刻压力会非常大，从而造成系统整体性风险</p><p>解决方案：</p><p>1、分散失效时间</p><p>分析缓存数据的特点，尽量将热点缓存的失效时间均匀分布。比如说将相同类型的缓存的失效时间设置成一个在一定区间内的随机值，从而有效的分散失效时间</p><p>2、多级缓存设计</p><p>一级缓存为基础缓存，缓存失效的时间设置一个比较长的时间，二级缓存为应用缓存，失效时间正常设置，一般比较短。当二级缓存失效的时候，再从一级缓存里获取</p><h3 id="缓存的更新策略有几种？"><a href="#缓存的更新策略有几种？" class="headerlink" title="缓存的更新策略有几种？"></a>缓存的更新策略有几种？</h3><ol><li><p>先更新数据，在更新缓存</p><p>这种策略会导致线程安全问题，比如：线程1 更新了数据库，线程2 也更新了数据库，这时候由于某种原因，线程2 先更新了缓存，线程1 后续更新。这样就产生了脏数据。因为目前数据库中存储的是线程2 更新的数据，而缓存中存的是线程 1 更新的老数据</p></li><li><p><strong>先删除缓存，在更新数据库</strong></p><p>这种策略可能会导致数据不一致的问题，线程1 写数据删除缓存；这时候线程2 查询这个缓存，发现不存在，就去访问了数据库，得到旧值放入缓存，线程1 更新数据库，这时候就会出现数据不一致的问题，如果没有设置过期时间，这个脏数据就一直存在</p><p><del>解决方案：</del>在写数据库成功后，再淘汰缓存一次</p></li><li><p><strong>先更新数据库，再删除缓存</strong></p><p>可能会造成比较短暂的数据不一致，再更新完数据库，还没有删除缓存的时候，如果有缓存数据访问，就会造成数据不一致的情况，但这种如果数据同步机制，一般都会比较快，不一致的影响比较小</p></li></ol><h1 id="十九、JVM"><a href="#十九、JVM" class="headerlink" title="十九、JVM"></a>十九、JVM</h1><h2 id="194-说一下-JVM-的主要组成部分？及其作用？"><a href="#194-说一下-JVM-的主要组成部分？及其作用？" class="headerlink" title="194.说一下 JVM 的主要组成部分？及其作用？"></a>194.说一下 JVM 的主要组成部分？及其作用？</h2><ul><li>类加载器（ClassLoader）</li><li>运行时数据区（Runtime Data Area）</li><li>执行引擎（Execution Engine）</li><li>本地库接口（Native Interface）</li></ul><p><strong>组件的作用：</strong>首先通过类加载器会把 Java 代码转换成字节码，运行时数据区再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎，将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口来实现整个程序的功能</p><h2 id="195-说一下-JVM-运行时数据区？"><a href="#195-说一下-JVM-运行时数据区？" class="headerlink" title="195.说一下 JVM 运行时数据区？"></a>195.说一下 JVM 运行时数据区？</h2><p>不同虚拟机的运行时数据区可能略有不同，但都会遵从 Java 虚拟机规范，Java 虚拟机模范规定的区域分为以下 5 个部分</p><ul><li>程序计数器：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成</li><li>Java 虚拟机栈：用于存储局部变量表、操作数栈、动态链接、方法出口等信息</li><li>本地方法栈：与虚拟机栈的作用是不一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的</li><li>Java 堆：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存</li><li>方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据</li></ul><h2 id="196-说一下堆栈的区别？"><a href="#196-说一下堆栈的区别？" class="headerlink" title="196.说一下堆栈的区别？"></a>196.说一下堆栈的区别？</h2><ul><li>功能方面：堆是用来存放对象的，栈是用来执行程序的</li><li>共享性：堆是线程共享的，栈是线程私有的</li><li>空间大小：堆大小远远大于栈</li></ul><h2 id="197-队列和栈是什么？有什么区别？"><a href="#197-队列和栈是什么？有什么区别？" class="headerlink" title="197.队列和栈是什么？有什么区别？"></a>197.队列和栈是什么？有什么区别？</h2><p>队列和栈都是被用来预存储数据的</p><p>队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素</p><p>栈和队列很相似，但它运行对元素进行后进先出进行检索</p><h2 id="198-什么是双亲委派模型？"><a href="#198-什么是双亲委派模型？" class="headerlink" title="198.什么是双亲委派模型？"></a>198.什么是双亲委派模型？</h2><p>在介绍双亲委派模型之前先说一下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后在转化为 class 对象</p><p>类加载器分类：</p><ul><li>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载 Java_HOME/lib/ 目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库</li><li>其他类加载器<ul><li>扩展类加载器（Extension ClassLoader）：负责加载 \lib\ext 目录或者 Java. ext. dies 系统变量指定的路径中的所有类库</li><li>应用程序类加载器（Application ClassLoader）：负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器</li></ul></li></ul><p>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载都是这样，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载器无法完成加载时，子加载器才会尝试去加载类</p><h2 id="199-说一下类装载的执行过程？"><a href="#199-说一下类装载的执行过程？" class="headerlink" title="199.说一下类装载的执行过程？"></a>199.说一下类装载的执行过程？</h2><p>类装载分为以下 5 个步骤：</p><ul><li>加载：根据查找路径找到相应的 class 文件然后导入</li><li>检查：检查加载的 class 文件的正确性</li><li>准备：给类中的静态变量分配内存空间</li><li>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址</li><li>初始化：对静态变量和静态代码块执行初始化工作</li></ul><h2 id="200-怎么判断对象是否可以被回收"><a href="#200-怎么判断对象是否可以被回收" class="headerlink" title="200.怎么判断对象是否可以被回收"></a>200.怎么判断对象是否可以被回收</h2><p>一般有两种方法来判断：</p><ul><li>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。他有一个缺点不能解决循环引用的问题</li><li>可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径成为引用链。当一个对象到 GC Roots 没有任何引用链相连时，而证明此对象是可以被回收的</li></ul><h2 id="201-Java-中都有哪些引用类型？"><a href="#201-Java-中都有哪些引用类型？" class="headerlink" title="201.Java 中都有哪些引用类型？"></a>201.Java 中都有哪些引用类型？</h2><ul><li>强引用：发生 gc 的时候不会被回收</li><li>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收</li><li>弱引用：有用但不是必须的对象，在下一次 GC 时会被回收</li><li>虚引用：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知</li></ul><h2 id="202-说一下-JVM-有哪些垃圾回收算法？"><a href="#202-说一下-JVM-有哪些垃圾回收算法？" class="headerlink" title="202.说一下 JVM 有哪些垃圾回收算法？"></a>202.说一下 JVM 有哪些垃圾回收算法？</h2><ul><li>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率低，无法清除垃圾碎片</li><li>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存</li><li>复制算法：按照容量划分两个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半</li><li>分代算法：根据对象存货周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法</li></ul><h2 id="203-说一下-JVM-有哪些垃圾回收器？"><a href="#203-说一下-JVM-有哪些垃圾回收器？" class="headerlink" title="203.说一下 JVM 有哪些垃圾回收器？"></a>203.说一下 JVM 有哪些垃圾回收器？</h2><ul><li>Serial：最早的单线程串行垃圾回收器</li><li>Serial Old：垃圾回收器的老年版本，同意也是单线程的，可以作为 CMS 垃圾回收器的备选预案</li><li>ParNew：是 Serial 的多线程版本</li><li>Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量</li><li>Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内容回收算法，Parallel Old 使用的是标记-整理的内存回收算法</li><li>CMS：一种以获得最短停顿时间为目标的收集器，非常使用 B/S 系统</li><li>G1： 一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项</li></ul><h2 id="204-详细介绍一下-CMS-垃圾回收器？"><a href="#204-详细介绍一下-CMS-垃圾回收器？" class="headerlink" title="204.详细介绍一下 CMS 垃圾回收器？"></a>204.详细介绍一下 CMS 垃圾回收器？</h2><p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上 “-XX:+UseConcMarkSweepGC” 来指定使用 CMS 垃圾回收器</p><p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候会产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收期进行垃圾清除，此时的性能将会被降低</p><h2 id="205-新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？"><a href="#205-新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？" class="headerlink" title="205.新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？"></a>205.新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？</h2><ul><li>新生代回收期：Serial、ParNew、Parallel Scavenge</li><li>老年代回收器：Serial Old、Parallel Old、CMS</li><li>整堆回收器：G1</li></ul><p>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率高；老年代回收器一般采用的是标记-整理的算法进行垃圾回收</p><h2 id="206-简述分代垃圾回收器是怎么工作的？"><a href="#206-简述分代垃圾回收器是怎么工作的？" class="headerlink" title="206.简述分代垃圾回收器是怎么工作的？"></a>206.简述分代垃圾回收器是怎么工作的？</h2><p>分代回收器有两个分区，老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3</p><p>新生代使用的是复制算法，新生代里有 3 个分区，Eden、To Survivor、From Survivor，它们的默认占比是 8：1：1，它的执行流程如下：</p><ul><li>把 Eden + From Survivor 存活的对象放入 To Survivor 区</li><li>清空 Eden 和 From Survivor 分区</li><li>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor</li></ul><p>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15，升级为老生代。大对象也会直接进入老生代</p><p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整齐执行流程</p><h2 id="207-说一下-JVM-调优的工具？"><a href="#207-说一下-JVM-调优的工具？" class="headerlink" title="207.说一下 JVM 调优的工具？"></a>207.说一下 JVM 调优的工具？</h2><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款试图监控工具</p><ul><li>jconsole：用于对 JVM 中的内存、线程和类等进行监控</li><li>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等</li></ul><h2 id="208-常用的-JVM-调优的参数都有哪些？"><a href="#208-常用的-JVM-调优的参数都有哪些？" class="headerlink" title="208.常用的 JVM 调优的参数都有哪些？"></a>208.常用的 JVM 调优的参数都有哪些？</h2><ul><li>-Xms2g：初始化堆大小为 2g</li><li>-Xmx2g：堆最大内存为 2g</li><li>-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1：4</li><li>-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8：2</li><li>-XX:+UseParNewGC:指定使用 ParNew + Serial Old 垃圾回收器组合</li><li>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合</li><li>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合</li><li>-XX:+PrintGC：开启打印 gc 信息</li><li>-XX:+PrintGCDetails：打印 gc 详细信息</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建FastDFS服务器</title>
    <link href="/2022/05/07/%E6%90%AD%E5%BB%BAFastDFS%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2022/05/07/%E6%90%AD%E5%BB%BAFastDFS%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="FastDFS-安装【文件服务存储服务器】"><a href="#FastDFS-安装【文件服务存储服务器】" class="headerlink" title="FastDFS 安装【文件服务存储服务器】"></a>FastDFS 安装【文件服务存储服务器】</h1><p>安装 FastDFS 依赖</p><p>FastDFS 是 C 语言开发的应用。安装必须使用 make、cmake 和 gcc 编译器。</p><p><code># yum install -y make cmake gcc gcc-c++ perl</code></p><p>把FastDFS_v5.08.tar.gz和libfastcommon-master.zip进行上传到根目录下的/upload目录下</p><p>上传并解压 libfastcommon-master<br>上传 libfastcommon-master 到/upload目录下。libfastcommon 是从 FastDFS和 FastDHT 中提取出来的公共 C 函数库。</p><p>解压 libfastcommon-master.zip，由于是 zip 文件所以要使用 unzip 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cd</span> /upload</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">unzip libfastcommon-master.zip</span><br></code></pre></td></tr></table></figure><p>编译并安装：</p><p>libfastcommon 没有提供 make 命令安装文件。使用的是 shell 脚本执行编译 和安装。</p><p>shell 脚本为 make.sh。进入解压后的文件：</p><p><code># cd libfastcommon-master</code></p><p>编译 <code># ./make.sh</code></p><p>安装 <code># ./make.sh install</code></p><p>有固定的默认安装位置。在/usr/lib64 和/usr/include/fastcommon 两个目录中</p><p><img src="https://gitee.com/skaifeng/picgo/raw/master/img/202203242246667.png" alt="image-20220324224646595"></p><p>创建软连接</p><p>因为 FastDFS 主程序设置的 lib 目录是/usr/local/lib，所以需要创建软链接</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># ln -s <span class="hljs-regexp">/usr/</span>lib64<span class="hljs-regexp">/libfastcommon.so /u</span>sr<span class="hljs-regexp">/local/</span>lib/libfastcommon.so <br># ln -s <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/lib64/</span>libfdfsclient.so <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/lib/</span>libfdfsclient.so<br></code></pre></td></tr></table></figure><p>上传并解压 FastDFS 主程序</p><p>上传 FastDFS_v5.08.tar.gz 到/upload下后解压 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cd</span> /upload</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">tar zxvf FastDFS_v5.08.tar.gz</span><br></code></pre></td></tr></table></figure><p>编译并安装 FastDFS </p><p>进入到解压后的 FastDFS 文件中。</p><p><code># cd FastDFS</code></p><p>编译 <code># ./make.sh</code></p><p>安装 <code># ./make.sh install</code></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">安装后，FastDFS 主程序所在位置是： <br><span class="hljs-regexp">/usr/</span>bin 可执行文件所在位置。 <br><span class="hljs-regexp">/etc/</span>fdfs 配置文件所在位置。 <br><span class="hljs-regexp">/usr/</span>bin 主程序代码所在位置。 <br><span class="hljs-regexp">/usr/i</span>nclude/fastdfs 包含的一些插件组所在位置。<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/skaifeng/picgo/raw/master/img/202203242249390.png" alt="image-20220324224903335"></p><p>配置 tracker</p><p>进入到/etc/fdfs 中，把 tracker 配置文件复制一份</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cd</span> /etc/fdfs</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cp</span> tracker.conf.sample tracker.conf</span><br></code></pre></td></tr></table></figure><p>创建数据目录<br>创建放置 tracker 数据的目录 </p><p><code># mkdir -p /usr/local/fastdfs/tracker</code></p><p>修改配置文件</p><p>修改 tracker.conf，设置 tracker 内容存储目录。</p><p><code># vim tracker.conf</code></p><p>base_path = /usr/local/fastdfs/tracker</p><p><img src="https://gitee.com/skaifeng/picgo/raw/master/img/202203242250602.png" alt="image-20220324225010560"></p><p>默认端口 22122，不需要修改</p><p>启动服务</p><p>在目录/etc/fdfs下进行对trackerd进行启动</p><p><code># service fdfs_trackerd start</code></p><p>启动成功后，配置文件中 base_path 指向的目录中出现 FastDFS 服务相关数据目录（data 目录、logs 目录）</p><p>查看服务运行状态</p><p><code># service fdfs_trackerd status</code></p><p>如果显示 is running 表示正常运行</p><p>关闭防火墙</p><p><code># service firewalld stop </code></p><p><code># systemctl disable firewalld</code></p><p>配置 storage</p><p>storage 可以和 tracker 不在同一台服务器上。示例中把 storage 和 tracker 安 装在同一台服务器上了</p><p>复制配置文件</p><p>进入到/etc/fdfs , 把 storage 配置文件复制一份</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cd</span> /etc/fdfs</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cp</span> storage.conf.sample storage.conf</span><br></code></pre></td></tr></table></figure><p>创建目录<br>创建两个目录，base 用于存储基础数据内容和日志，store 用于存储上传数据</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># mkdir -p <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/fastdfs/</span>storage/base <br># mkdir -p <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/fastdfs/</span>storage/store<br></code></pre></td></tr></table></figure><p>修改配置文件</p><p>storage.conf 配置文件用于描述存储服务的行为，需要进行下述修改：</p><p><code># vim /etc/fdfs/storage.conf</code></p><p>配置内容如下：</p><p>base_path=/usr/local/fastdfs/storage/base</p><p>store_path0=/usr/local/fastdfs/storage/store</p><p>tracker_server=tracker 服务 IP:22122</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">base_path - 基础路径。用于保存 storage<span class="hljs-built_in"> server </span>基础数据内容和日志内容的 目录。<br> <br>store_path0 - 存储路径。是用于保存 FastDFS 中存储文件的目录，就是要创 建 256<span class="hljs-number">*256</span> 个子目录的位置。  <br> <br>base_path 和 store_path0 可以使用同一个目录。 <br><br>tracker_server - 跟踪服务器位置。就是跟踪服务器的<span class="hljs-built_in"> ip </span>和端口。<br></code></pre></td></tr></table></figure><p>启动服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cd</span> /etc/fdfs</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">service fdfs_storaged start</span><br></code></pre></td></tr></table></figure><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell">启动成功后，配置文件中 base_path 指向的目录中出现 <span class="hljs-type">FastDFS</span> 服务相关数 据目录（<span class="hljs-class"><span class="hljs-keyword">data</span> 目录、logs 目录），配置文件中的 store_path0 指向的目录中同样出 现 <span class="hljs-type">FastDFS</span> 存储相关数据录（<span class="hljs-keyword">data</span> 目录）。其中$store_path0/<span class="hljs-keyword">data</span>/目录中默认创 建若干子孙目录（两级目录层级总计 256*256 个目录），是用于存储具体文件数 据的。</span><br><span class="hljs-type">Storage</span> 服务器启动比较慢，因为第一次启动的时候，需要创建 <span class="hljs-number">256</span>*<span class="hljs-number">256</span> 个 目录。<br></code></pre></td></tr></table></figure><p>查看启动状态</p><p><code># service fdfs_storaged status</code></p><p>至此fastdfs安装成功!!!!</p><p>Nginx 安装</p><p>上传并安装 fastdfs-nginx-module<br>上传 01 资料/08 nignx 安装（包含 fastdfs 模块）/fastdfs-nginx-module_v1.16.tar.gz 到 /upload 中</p><p>进入upload目录</p><p><code># cd /upload</code></p><p>解压</p><p><code># tar zxvf fastdfs-nginx-module_v1.16.tar.gz</code></p><p>修改配置文件</p><p>进入解压目录中 src 目录</p><p><code># cd fastdfs-nginx-module/src</code></p><p>编辑 config 文件</p><p><code># vim config</code></p><p>修改配置文件中第四行，把路径中 local 去掉（一共有两个 local）。参数是用于配置安装 nginx 中的 FastDFS 组件的时候，在什么位置查找 FastDFS 核心代码。<br>修改结果如下</p><p><img src="https://gitee.com/skaifeng/picgo/raw/master/img/202203242258866.png" alt="image-20220324225807816"></p><p>安装 nginx 的依赖</p><p><code># yum install -y gcc gcc-c++ make automake autoconf libtool pcre pcre-devel zlib zlib-devel openssl openssl-devel</code></p><p>上传 Nginx 并解压</p><p>上传nginx-1.8.0.tar.gz 到/upload 中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cd</span> /upload</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">tar zxvf nginx-1.8.0.tar.gz</span><br></code></pre></td></tr></table></figure><p>修改 Nginx 配置</p><p>进入到 nginx 文件夹</p><p><code># cd nginx-1.8.0/</code></p><p>创建临时目录<br>修改配置文件中好多位置都使用了/var/temp/nginx 目录，但是默认不会自动创建这个目 录的，需要手动创建</p><p><code># mkdir -p /var/temp/nginx</code></p><p>修改配置文件参数：（直接复制执行）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">./configure \<br>--prefix=<span class="hljs-regexp">/usr/</span>local/nginx \<br>--pid-path=<span class="hljs-regexp">/var/</span>run<span class="hljs-regexp">/nginx/</span>nginx.pid \<br>--lock-path=<span class="hljs-regexp">/var/</span>lock/nginx.lock \<br>--error-log-path=<span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/nginx/</span>error.log \<br>--http-log-path=<span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/nginx/</span>access.log \<br>--with-http_gzip_static_module \<br>--http-client-body-temp-path=<span class="hljs-regexp">/var/</span>temp<span class="hljs-regexp">/nginx/</span>client \<br>--http-proxy-temp-path=<span class="hljs-regexp">/var/</span>temp<span class="hljs-regexp">/nginx/</span>proxy \<br>--http-fastcgi-temp-path=<span class="hljs-regexp">/var/</span>temp<span class="hljs-regexp">/nginx/</span>fastcgi \<br>--http-uwsgi-temp-path=<span class="hljs-regexp">/var/</span>temp<span class="hljs-regexp">/nginx/u</span>wsgi \<br>--http-scgi-temp-path=<span class="hljs-regexp">/var/</span>temp<span class="hljs-regexp">/nginx/</span>scgi \<br>--add-module=<span class="hljs-regexp">/upload/</span>fastdfs-nginx-module/src<br></code></pre></td></tr></table></figure><p>–add-module 必须定义，此配置信息是用于指定安装 Nginx 时需要加载的模块，如果未 指定，Nginx 安装过程不会加载 fastdfs-nginx-module 模块，后续功能无法实现。</p><p>编译并安装：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># make </span><br><span class="hljs-meta"># make install</span><br></code></pre></td></tr></table></figure><p>配置 fastdfs-nginx-module 模块配置文件：</p><p>复制配置文件 fastdfs-nginx-module/src/mod_fastdfs.conf 到/etc/fdfs 目录中</p><p><code># cp /upload/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs/</code></p><p>修改 mod_fastdfs.conf</p><p>进入/etc/fdfs</p><p><code># cd /etc/fdfs</code></p><p>编辑配置文件</p><p><code># vim mod_fastdfs.conf</code></p><p>文件内容修改</p><p>需要修改文件中四处内容，这四处内容的含义：</p><p>connect_timeout=2 #连接超时时间，单位秒</p><p>tracker_server=tracker:22122 #tracker 服务结点</p><p>url_have_group_name = false #URL 中是否包含 group 名称</p><p>store_path0=/home/yuqing/fastdfs # storage 服务结点的存储位置，与配置 storage 结点一致</p><p>修改结果如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">connect_timeout</span>=<span class="hljs-number">10</span> <br><span class="hljs-attr">tracker_server</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">9.136</span>:<span class="hljs-number">22122</span> <br><span class="hljs-attr">url_have_group_name</span> = <span class="hljs-literal">true</span> <br><span class="hljs-attr">store_path0</span>=/usr/local/fastdfs/storage/store<br></code></pre></td></tr></table></figure><p>提供 FastDFS 需要的 HTTP 配置文件</p><p>复制 FastDFS 安装包中的两个配置文件（http.conf 和 mime.types）到/etc/fdfs 目录中 </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># cp <span class="hljs-regexp">/upload/</span>FastDFS<span class="hljs-regexp">/conf/</span>http.conf <span class="hljs-regexp">/etc/</span>fdfs/ <br># cp <span class="hljs-regexp">/upload/</span>FastDFS<span class="hljs-regexp">/conf/mim</span>e.types <span class="hljs-regexp">/etc/</span>fdfs/<br></code></pre></td></tr></table></figure><p>创建网络访问存储服务的软连接:</p><p>在上传文件到 FastDFS 后，FastDFS 会返回 <strong>group1</strong>/M00/00/00/xxxxxxxxxx.xxx。其中 group1 是卷名，在 mod_fastdfs.conf 配置文件中已配置了 url_have_group_name，以保证 URL 解析 正确。而其中的 M00 是 FastDFS 保存数据时使用的虚拟目录，需要将这个虚拟目录定位到真 实数据目录上。</p><p><code># ln -s /usr/local/fastdfs/storage/store/data/ /usr/local/fastdfs/storage/store/data/M00</code></p><p>修改 nginx 配置文件:</p><p>进入到安装后 nginx 目录 </p><p>注意是安装目录，不是解压目录</p><p><code># cd /usr/local/nginx/conf</code></p><p>编辑配置文件</p><p><code># vim nginx.conf</code></p><p>修改内容 需要修改三处。</p><p>第一处:</p><p>user root; # Nginx 需要访问 linux 文件系统，必须有文件系统的权限。User root 代表 nginx 访问文件系统的权限是 root 用户权限。如果不开启权限，可能有 404 访问错误。</p><p><img src="https://gitee.com/skaifeng/picgo/raw/master/img/202203242302691.png" alt="image-20220324230250656"></p><p>修改后的效果：去掉注释，user 后面写上 root</p><p><img src="https://gitee.com/skaifeng/picgo/raw/master/img/202203242303349.png" alt="image-20220324230300317"></p><p>第二处:</p><p>修改文件的第九行，去掉 pid 前面的#注释，修改成下面效果。 如果不修改这个内容，第一次安装没问题，后面再次启动后会出现 nginx 无法启动问题</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">pid               <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>nginx.pid;<br></code></pre></td></tr></table></figure><p>第三处</p><p>找到 http 标记里面的 server，在 server 上面添加下面内容</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">server</span>&#123;<br><span class="hljs-keyword">listen</span> <span class="hljs-number">8888</span>;<br>server_name localhost;<br><span class="hljs-keyword">location</span> ~/<span class="hljs-keyword">group</span>([<span class="hljs-number">0</span><span class="hljs-number">-9</span>])/M00&#123;<br>ngx_fastdfs_module;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动 nginx</p><p>进入到 nginx 安装目录的 sbin 文件夹</p><p><code># cd /usr/local/nginx/sbin/</code></p><p><code># ./nginx</code></p><p>关闭 nginx</p><p><code># ./nginx -s quit</code></p><p>启动命令：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">service fdfs_trackerd <span class="hljs-literal">start</span><br><br>service fdfs_storaged <span class="hljs-literal">start</span><br><br>./nginx<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分法查找</title>
    <link href="/2022/05/07/%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE/"/>
    <url>/2022/05/07/%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>1、二分法查找的背景</p><p>2、二分法查找的介绍</p><p>3、二分法查找的算法思想</p><p>4、代码实现</p><figure class="highlight apache"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">4</span>.<span class="hljs-number">1</span> 利用循环的方式实现二分法查找<br><span class="hljs-attribute">4</span>.<span class="hljs-number">2</span> 利用递归的方式实现二分法查找<br></code></pre></td></tr></table></figure><h1 id="1、二分法查找的背景"><a href="#1、二分法查找的背景" class="headerlink" title="1、二分法查找的背景"></a>1、二分法查找的背景</h1><p>​        当数组或者集合中存放的元素数量非常多的时候，想要跟踪具体某个元素的位置或者是否存在，常规方式是循环每一个元素直到找到要查找的元素为止。这样的查找方式效率非常低下，这个时候需要使用二分法来实现，提高查找效率。</p><h1 id="2、二分法查找的介绍"><a href="#2、二分法查找的介绍" class="headerlink" title="2、二分法查找的介绍"></a>2、二分法查找的介绍</h1><p>二分法查找（折半查找），找指定数值所在的位置</p><p>百度百科是这样介绍二分法查找的：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/19/16f1da1cb93d30f1~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><h1 id="3、二分法查找的算法思想"><a href="#3、二分法查找的算法思想" class="headerlink" title="3、二分法查找的算法思想"></a>3、二分法查找的算法思想</h1><p>假设数组是按升序排序的，对于给定的目标值aim，从数组的中间位置开始查找：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">1.若查找数据与中间元素值正好相等，则返回中间元素值的索引；<br>2.若查找数值比中间值小，则以整个查找范围的前半部分作为新的查找范围；<br>3.若查找数值比中间值大，则以整个查找范围的后半部分作为新的查找范围；<br>注：查找成功返回索引，失败返回<span class="hljs-string">-1</span><br></code></pre></td></tr></table></figure><h1 id="4、代码实现"><a href="#4、代码实现" class="headerlink" title="4、代码实现"></a>4、代码实现</h1><h2 id="4-1-利用循环的方式实现二分法查找"><a href="#4-1-利用循环的方式实现二分法查找" class="headerlink" title="4.1 利用循环的方式实现二分法查找"></a>4.1 利用循环的方式实现二分法查找</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinarySearch</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 生成一个随机数组</span><br>        <span class="hljs-type">int</span>[] array = suiji();<br>        <span class="hljs-comment">// 对随机数组排序</span><br>        Arrays.sort(array);<br>        System.out.println(<span class="hljs-string">&quot;产生的随机数组为： &quot;</span> + Arrays.toString(array));<br><br>        System.out.println(<span class="hljs-string">&quot;要进行查找的值： &quot;</span>);<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-comment">// 进行查找的目标值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">aim</span> <span class="hljs-operator">=</span> input.nextInt();<br><br>        <span class="hljs-comment">// 使用二分法查找</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> binarySearch(array, aim);<br>        System.out.println(<span class="hljs-string">&quot;查找的值的索引位置： &quot;</span> + index);<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成一个随机数组</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回值，返回一个随机数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] suiji() &#123;<br>        <span class="hljs-comment">// random.nextInt(n)+m  返回m到m+n-1之间的随机数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">6</span>) + <span class="hljs-number">5</span>;<br>        <span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-comment">// 循环遍历为数组赋值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>            array[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">100</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 二分法查找  ---循环的方式实现</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> array 要查找的数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> aim 要查找的值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回值，成功返回索引，失败返回-1</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> aim)</span> &#123;<br>        <span class="hljs-comment">// 数组最小索引值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 数组最大索引值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> array.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> mid;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// 若查找数值比中间值小，则以整个查找范围的前半部分作为新的查找范围</span><br>            <span class="hljs-keyword">if</span> (aim &lt; array[mid]) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 若查找数值比中间值大，则以整个查找范围的后半部分作为新的查找范围</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (aim &gt; array[mid]) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 若查找数据与中间元素值正好相等，则放回中间元素值的索引</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码执行结果：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">产生的随机数组为： <span class="hljs-string">[16, 33, 40, 46, 57, 63, 65, 71, 85]</span><br>要进行查找的值： <br><span class="hljs-number">46</span><br>查找的值的索引位置： <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>若输入的值找不到，则返回-1</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">产生的随机数组为： <span class="hljs-string">[28, 41, 47, 56, 70, 81, 85, 88, 95]</span><br>要进行查找的值： <br><span class="hljs-number">66</span><br>查找的值的索引位置： -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="4-2-利用递归的方式实现二分法查找"><a href="#4-2-利用递归的方式实现二分法查找" class="headerlink" title="4.2 利用递归的方式实现二分法查找"></a>4.2 利用递归的方式实现二分法查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinarySearch2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 生成一个随机数组</span><br>        <span class="hljs-type">int</span>[] array = suiji();<br>        <span class="hljs-comment">// 对随机数组排序</span><br>        Arrays.sort(array);<br>        System.out.println(<span class="hljs-string">&quot;产生的随机数组为： &quot;</span> + Arrays.toString(array));<br><br>        System.out.println(<span class="hljs-string">&quot;要进行查找的值： &quot;</span>);<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-comment">// 进行查找的目标值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">aim</span> <span class="hljs-operator">=</span> input.nextInt();<br><br>        <span class="hljs-comment">// 使用二分法查找</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> binarySearch(array, aim, <span class="hljs-number">0</span>, array.length - <span class="hljs-number">1</span>);<br>        System.out.println(<span class="hljs-string">&quot;查找的值的索引位置： &quot;</span> + index);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成一个随机数组</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回值，返回一个随机数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] suiji() &#123;<br>        <span class="hljs-comment">// Random.nextInt(n)+m  返回m到m+n-1之间的随机数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">6</span>) + <span class="hljs-number">5</span>;<br>        <span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-comment">// 循环遍历为数组赋值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>            array[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">100</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 二分法查找 ---递归的方式</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> array 要查找的数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> aim   要查找的值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> left  左边最小值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> right 右边最大值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回值，成功返回索引，失败返回-1</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> aim, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (aim &lt; array[left] || aim &gt; array[right]) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 找中间值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (array[mid] == aim) &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (array[mid] &gt; aim) &#123;<br>            <span class="hljs-comment">//如果中间值大于要找的值则从左边一半继续递归</span><br>            <span class="hljs-keyword">return</span> binarySearch(array, aim, left, mid - <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//如果中间值小于要找的值则从右边一半继续递归</span><br>            <span class="hljs-keyword">return</span> binarySearch(array, aim, mid + <span class="hljs-number">1</span>, array.length-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GIT基本命令</title>
    <link href="/2022/05/07/GIT%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/05/07/GIT%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<ul><li>git clone xxxxx   克隆代码</li><li>git add .    将代码放到暂存区</li><li>git commit -m “提交信息”</li><li>git push -u origin master   将代码提交到远程仓库</li><li>git branch 查看当前分支</li><li>git branch zhangsan  创建新的分支zhangsan</li><li>git log 提交日志</li><li>git checkout zhangsan 切换为zhangsan分支</li><li>git pull origin master 拉取最新代码</li><li>git reset –hard HEAD^ 版本回退 <del>（^表示回退到上一个版本，^^表示回退到上上一个版本，以此类推）</del>，如果要回退到前100个版本，这种方法肯定行不通，可以使用 <del>git reset –hard HEAD~100</del></li><li>git merge 分支名  和某个分支进行合并</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hibernate</title>
    <link href="/2022/05/07/Hibernate/"/>
    <url>/2022/05/07/Hibernate/</url>
    
    <content type="html"><![CDATA[<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>1、导入相关依赖</p><p>2、创建 Hibernate 配置文件</p><p>3、创建实体类</p><p>4、创建实体类–关系映射文件</p><p>5、调用 Hibernate API 完成操作</p><h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><h3 id="1、创建Maven工程，pom-xml"><a href="#1、创建Maven工程，pom-xml" class="headerlink" title="1、创建Maven工程，pom.xml"></a>1、创建Maven工程，pom.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--MySQL--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.48<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--Hibernate--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hibernate<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hibernate-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.4.10.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2、创建配置文件-hibernate-cfg-xml"><a href="#2、创建配置文件-hibernate-cfg-xml" class="headerlink" title="2、创建配置文件  hibernate.cfg.xml"></a>2、创建配置文件  hibernate.cfg.xml</h3><p>核心配置：session-factory</p><p>SessionFactory：针对单个数据库映射经过编译的内存镜像文件，将数据库转化为一个java可以是别的镜像文件</p><p>构建SessionFactory非常耗费资源，所以通常一个工厂只需要创建一个SessionFactory。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">hibernate-configuration</span> <span class="hljs-keyword">PUBLIC</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hibernate-configuration</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">session-factory</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--数据源配置--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;connection.username&quot;</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;connection.password&quot;</span>&gt;</span>123.com<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;connection.driver_class&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;connection.url&quot;</span>&gt;</span>jdbc:mysql://localhost:3307/bdqn?useUnicode=true<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf-8<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--连接池 C3P0 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.c3p0.acquire_increment&quot;</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.c3p0.idle_test_period&quot;</span>&gt;</span>10000<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.c3p0.timeout&quot;</span>&gt;</span>5000<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.c3p0.max_size&quot;</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.c3p0.min_size&quot;</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.c3p0.max_statements&quot;</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--数据库方言 MySQL--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.dialect&quot;</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--打印sql语句--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;show_sql&quot;</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--格式化sql--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;format_sql&quot;</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--是否自动生成数据表--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.hbm2ddl.auto&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">session-factory</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">hibernate-configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3、创建实体类"><a href="#3、创建实体类" class="headerlink" title="3、创建实体类"></a>3、创建实体类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kai.pojo;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Set&lt;Orders&gt; orders;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kai.pojo;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Orders</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Customer customer;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、创建实体关系映射文件-xxx-hbm-xml"><a href="#4、创建实体关系映射文件-xxx-hbm-xml" class="headerlink" title="4、创建实体关系映射文件  xxx.hbm.xml"></a>4、创建实体关系映射文件  xxx.hbm.xml</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kai.pojo;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Double money;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/skaifeng/picgo/raw/master/img/202111041149864.png" alt="image-20211012100034839"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">hibernate-mapping</span> <span class="hljs-keyword">PUBLIC</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;-//Hibernate/Hibernate Mapping DTD//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hibernate-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">class</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.kai.pojo.People&quot;</span> <span class="hljs-attr">table</span>=<span class="hljs-string">&quot;people&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--主键映射--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">column</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">column</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--自增--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">generator</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;identity&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">generator</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">column</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">column</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;money&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.Double&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">column</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;money&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">column</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">hibernate-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="5、实体关系映射文件需要注册到-Hibernate-配置文件中"><a href="#5、实体关系映射文件需要注册到-Hibernate-配置文件中" class="headerlink" title="5、实体关系映射文件需要注册到 Hibernate 配置文件中"></a>5、实体关系映射文件需要注册到 Hibernate 配置文件中</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--注册实体关系映射文件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/kai/pojo/People.hbm.xml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="6、使用-Hibernate-API-完成数据操作"><a href="#6、使用-Hibernate-API-完成数据操作" class="headerlink" title="6、使用 Hibernate API 完成数据操作"></a>6、使用 Hibernate API 完成数据操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kai.test;<br><br><span class="hljs-keyword">import</span> com.kai.pojo.People;<br><span class="hljs-keyword">import</span> org.hibernate.Session;<br><span class="hljs-keyword">import</span> org.hibernate.SessionFactory;<br><span class="hljs-keyword">import</span> org.hibernate.cfg.Configuration;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建Configuration</span><br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>().configure();<br>        <span class="hljs-comment">// 获取sessionFactory</span><br>        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> configuration.buildSessionFactory();<br>        <span class="hljs-comment">// 获取Session对象</span><br>        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();<br>        <span class="hljs-type">People</span> <span class="hljs-variable">people</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>();<br>        people.setName(<span class="hljs-string">&quot;张三&quot;</span>);<br>        people.setMoney(<span class="hljs-number">1000.0</span>);<br>        session.save(people);<br>        session.beginTransaction().commit();<br>        session.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7、pom-xml中需要配置resource"><a href="#7、pom-xml中需要配置resource" class="headerlink" title="7、pom.xml中需要配置resource"></a>7、pom.xml中需要配置resource</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Hibernate级联操作"><a href="#Hibernate级联操作" class="headerlink" title="Hibernate级联操作"></a>Hibernate级联操作</h2><p><strong>1、一对多关系</strong></p><p>客户和订单：每个客户可以生成多个订单，但是一个订单只能属于一个客户，客户是一，订单是多</p><p><img src="https://gitee.com/skaifeng/picgo/raw/master/img/202111041150885.png" alt="image-20211012102207503"></p><p>数据库中一的一方是主表，多的一方是从表，通过主外键关系来维护</p><p><strong>2、多对多关系</strong></p><p>学生选课：一门课程可以被多个学生选择，一个学生可以选择多门课程，学生是多，课程也是多。</p><p>数据库中是通过两个一对多关系来维护的，学生和课程都是主表，额外增加一张中间表作为从表，两张主表和中间表都是一对多关系</p><p><img src="https://gitee.com/skaifeng/picgo/raw/master/img/202111041150707.png" alt="image-20211012102824457"></p><p>Java和数据库对于这两种关系的体现完全是两种不同的方式，Hibernate 框架的作用就是将这两种方式进行转换和映射。</p><h3 id="Hibernate-实现一对多"><a href="#Hibernate-实现一对多" class="headerlink" title="Hibernate 实现一对多"></a>Hibernate 实现一对多</h3><p><strong>Customer</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">hibernate-mapping</span> <span class="hljs-keyword">PUBLIC</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;-//Hibernate/Hibernate Mapping DTD//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hibernate-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">class</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.kai.pojo.Customer&quot;</span> <span class="hljs-attr">table</span>=<span class="hljs-string">&quot;customer&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--主键映射--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">column</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">column</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--自增--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">generator</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;identity&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">generator</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">column</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">column</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;orders&quot;</span> <span class="hljs-attr">table</span>=<span class="hljs-string">&quot;orders&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;cid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">one-to-many</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kai.pojo.Orders&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">one-to-many</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">hibernate-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>set 标签来配置实体类中的集合属性 orders</li><li>name 实体类中的属性名</li><li>table 表名</li><li>key 外键</li><li>one-to-many 与集合泛型的实体类对应</li></ul><p><strong>Orders</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">hibernate-mapping</span> <span class="hljs-keyword">PUBLIC</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;-//Hibernate/Hibernate Mapping DTD//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hibernate-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">class</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.kai.pojo.Orders&quot;</span> <span class="hljs-attr">table</span>=<span class="hljs-string">&quot;orders&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--主键映射--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">column</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">column</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--自增--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">generator</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;identity&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">generator</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">column</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">column</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">many-to-one</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;customer&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kai.pojo.Customer&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;cid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">many-to-one</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">hibernate-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>many-to-one  配置实体类对应的对象属性</li><li>name  属性名</li><li>class  属性对应的类</li><li>column  外键</li></ul><p><strong>需要在 Hibernate 配置文件中进行注册</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--注册实体关系映射文件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/kai/pojo/Customer.hbm.xml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapping</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/kai/pojo/Orders.hbm.xml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>Hibernate API 调用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kai.test;<br><br><span class="hljs-keyword">import</span> com.kai.pojo.Customer;<br><span class="hljs-keyword">import</span> com.kai.pojo.Orders;<br><span class="hljs-keyword">import</span> org.hibernate.Session;<br><span class="hljs-keyword">import</span> org.hibernate.SessionFactory;<br><span class="hljs-keyword">import</span> org.hibernate.cfg.Configuration;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建Configuration</span><br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>().configure();<br>        <span class="hljs-comment">// 获取SessionFactory</span><br>        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> configuration.buildSessionFactory();<br>        <span class="hljs-comment">// 获取Session</span><br>        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();<br>        <span class="hljs-comment">// 创建Customer对象</span><br>        <span class="hljs-type">Customer</span> <span class="hljs-variable">customer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Customer</span>();<br>        customer.setName(<span class="hljs-string">&quot;张三&quot;</span>);<br><br>        <span class="hljs-comment">//创建Orders对象</span><br>        <span class="hljs-type">Orders</span> <span class="hljs-variable">orders</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orders</span>();<br>        orders.setName(<span class="hljs-string">&quot;订单1&quot;</span>);<br><br>        <span class="hljs-comment">//建立关联关系</span><br>        orders.setCustomer(customer);<br><br>        <span class="hljs-comment">//保存</span><br>        session.save(customer);<br>        session.save(orders);<br>        <span class="hljs-comment">//提交事务</span><br>        session.beginTransaction().commit();<br>        session.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Hibernate-实现多对多"><a href="#Hibernate-实现多对多" class="headerlink" title="Hibernate 实现多对多"></a>Hibernate 实现多对多</h3><p><strong>Account</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">hibernate-mapping</span> <span class="hljs-keyword">PUBLIC</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;-//Hibernate/Hibernate Mapping DTD//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hibernate-mapping</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">class</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.kai.pojo.Account&quot;</span> <span class="hljs-attr">table</span>=<span class="hljs-string">&quot;t_account&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--主键映射--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">column</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">column</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--自增--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">generator</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;identity&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">generator</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">column</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">column</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;courses&quot;</span> <span class="hljs-attr">table</span>=<span class="hljs-string">&quot;account_course&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;aid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">many-to-many</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kai.pojo.Course&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;cid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">many-to-many</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">class</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">hibernate-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>Course</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">hibernate-mapping</span> <span class="hljs-keyword">PUBLIC</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;-//Hibernate/Hibernate Mapping DTD//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hibernate-mapping</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">class</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.kai.pojo.Course&quot;</span> <span class="hljs-attr">table</span>=<span class="hljs-string">&quot;t_course&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--主键映射--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">column</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">column</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--自增--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">generator</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;identity&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">generator</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">column</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">column</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;accounts&quot;</span> <span class="hljs-attr">table</span>=<span class="hljs-string">&quot;account_course&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;cid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">many-to-many</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kai.pojo.Account&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;aid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">many-to-many</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">class</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">hibernate-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>name  实体类对应的集合属性名</li><li>table  中间表名</li><li>key  外键</li><li>many-to-many  集合泛型的实体类对应</li><li>column  属性与中间表的外键字段名对应</li></ul><p><strong>注册到 Hibernate 配置文件中</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--注册实体关系映射文件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/kai/pojo/Account.hbm.xml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapping</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/kai/pojo/Course.hbm.xml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>Hibernate API 调用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kai.test;<br><br><span class="hljs-keyword">import</span> com.kai.pojo.Account;<br><span class="hljs-keyword">import</span> com.kai.pojo.Course;<br><span class="hljs-keyword">import</span> org.hibernate.Session;<br><span class="hljs-keyword">import</span> org.hibernate.SessionFactory;<br><span class="hljs-keyword">import</span> org.hibernate.cfg.Configuration;<br><br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建Configuration</span><br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>().configure();<br>        <span class="hljs-comment">// 获取SessionFactory</span><br>        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> configuration.buildSessionFactory();<br>        <span class="hljs-comment">// 获取Session</span><br>        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();<br><br>        <span class="hljs-type">Course</span> <span class="hljs-variable">course</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Course</span>();<br>        course.setName(<span class="hljs-string">&quot;Java&quot;</span>);<br>        <span class="hljs-type">Account</span> <span class="hljs-variable">account</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>();<br>        account.setName(<span class="hljs-string">&quot;张三&quot;</span>);<br><br>        <span class="hljs-comment">//建立关联关系</span><br>        Set&lt;Course&gt; courses = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Course&gt;();<br>        courses.add(course);<br><br>        account.setCourses(courses);<br><br>        session.save(course);<br>        session.save(account);<br>        session.beginTransaction().commit();<br>        session.close();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Hibernate-延迟加载"><a href="#Hibernate-延迟加载" class="headerlink" title="Hibernate 延迟加载"></a>Hibernate 延迟加载</h2><p>延迟加载、惰性加载、懒加载</p><p>使用延迟加载可以提高程序的运行效率，Java程序与数据库的交互频次越低，程序运行的效率越高，所以我们应该尽量减少Java程序与数据库的交互次数，Hibernate  延迟加载就很好的做到了这一点。</p><p>客户和订单，当我们查询客户对象的时候，因为有级联设置，所以会将对应的订单信息一并查出，这样的话就需要发送两条SQL语句，分别查询客户信息和订单信息。</p><p>延迟加载的思路是：当我们查询客户的时候，如果没有访问订单数据的话，那么就只发送一条SQL语句，来查询客户信息，如果需要访问订单数据的时候，则发送两条SQL。</p><p>延迟加载可以看做是一种优化机制，根据具体的需求，自动选择SQL语句数量。</p><h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><p>1、查询 Customer，对 Orders 进行延迟加载设置，在 Customer.hbm.xml 中进行设置，延迟加载默认开启。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;orders&quot;</span> <span class="hljs-attr">table</span>=<span class="hljs-string">&quot;orders&quot;</span> <span class="hljs-attr">lazy</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;cid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">one-to-many</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kai.pojo.Orders&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">one-to-many</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、查询 Customer</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/181/202205071614703.png" alt="image-20211012115423449"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kai.test;<br><br><span class="hljs-keyword">import</span> com.kai.pojo.Customer;<br><span class="hljs-keyword">import</span> org.hibernate.Session;<br><span class="hljs-keyword">import</span> org.hibernate.SessionFactory;<br><span class="hljs-keyword">import</span> org.hibernate.cfg.Configuration;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test4</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建Configuration</span><br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>().configure();<br>        <span class="hljs-comment">// 获取SessionFactory</span><br>        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> configuration.buildSessionFactory();<br>        <span class="hljs-comment">// 获取Session</span><br>        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();<br><br>        <span class="hljs-type">Customer</span> <span class="hljs-variable">customer</span> <span class="hljs-operator">=</span> session.get(Customer.class,<span class="hljs-number">5</span>);<br>        System.out.println(customer);<br>        session.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、查询 Orders</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/181/202205071614722.png" alt="image-20211012115505902"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kai.test;<br><br><span class="hljs-keyword">import</span> com.kai.pojo.Customer;<br><span class="hljs-keyword">import</span> org.hibernate.Session;<br><span class="hljs-keyword">import</span> org.hibernate.SessionFactory;<br><span class="hljs-keyword">import</span> org.hibernate.cfg.Configuration;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test4</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建Configuration</span><br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>().configure();<br>        <span class="hljs-comment">// 获取SessionFactory</span><br>        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> configuration.buildSessionFactory();<br>        <span class="hljs-comment">// 获取Session</span><br>        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();<br><br>        <span class="hljs-type">Customer</span> <span class="hljs-variable">customer</span> <span class="hljs-operator">=</span> session.get(Customer.class,<span class="hljs-number">5</span>);<br>        System.out.println(customer.getOrders());<br>        session.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><del>lazy除了可以设置 true 和 false 之外，还可以设置 extra，extra 是比 true 更加懒惰的一种加载方式，或者说是更加智能的一种加载方式，通过例子看区别：</del></p><p>查询 customer 对象，打印该对象对应的 orders 集合的长度  </p><p><strong>使用 true</strong></p><p><img src="https://gitee.com/skaifeng/picgo/raw/master/img/202111041151221.png" alt="image-20211104115132145"></p><p><strong>使用 extra</strong></p><p>使用聚合函数 count 来统计，不需要封装成对象，再把对象装到集合里，在获取集合 size</p><p><img src="https://gitee.com/skaifeng/picgo/raw/master/img/202111041151892.png" alt="image-20211012120341277"></p><p><strong>也可以通过 Orders 来设置 Customer 的延迟加载，Orders.hbm.xml 中设置，lazy 默认 false</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">many-to-one</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;customer&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kai.pojo.Customer&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;cid&quot;</span> <span class="hljs-attr">lazy</span>=<span class="hljs-string">&quot;proxy&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">many-to-one</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kai.test;<br><br><span class="hljs-keyword">import</span> com.kai.pojo.Customer;<br><span class="hljs-keyword">import</span> com.kai.pojo.Orders;<br><span class="hljs-keyword">import</span> org.hibernate.Session;<br><span class="hljs-keyword">import</span> org.hibernate.SessionFactory;<br><span class="hljs-keyword">import</span> org.hibernate.cfg.Configuration;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test5</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建Configuration</span><br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>().configure();<br>        <span class="hljs-comment">// 获取SessionFactory</span><br>        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> configuration.buildSessionFactory();<br>        <span class="hljs-comment">// 获取Session</span><br>        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();<br><br>        <span class="hljs-type">Orders</span> <span class="hljs-variable">orders</span> <span class="hljs-operator">=</span> session.get(Orders.class,<span class="hljs-number">8</span>);<br>        System.out.println(orders);<br>        session.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/skaifeng/picgo/raw/master/img/202111041151248.png" alt="image-20211012121548416"></p><ul><li>No-proxy : 当调用方法需要访问 customer 成员变量时，发送 SQL 语句查询Customer，否则不查询</li><li>proxy ： 无论调用的方法是否需要访问 customer 的成员变量，都会发送 SQL 语句去查询 customer </li></ul><h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>查询 Course，加载对应的Account，默认延迟加载开启</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kai.test;<br><br><span class="hljs-keyword">import</span> com.kai.pojo.Course;<br><span class="hljs-keyword">import</span> com.kai.pojo.Orders;<br><span class="hljs-keyword">import</span> org.hibernate.Session;<br><span class="hljs-keyword">import</span> org.hibernate.SessionFactory;<br><span class="hljs-keyword">import</span> org.hibernate.cfg.Configuration;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test6</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建Configuration</span><br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>().configure();<br>        <span class="hljs-comment">// 获取SessionFactory</span><br>        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> configuration.buildSessionFactory();<br>        <span class="hljs-comment">// 获取Session</span><br>        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();<br><br>        <span class="hljs-type">Course</span> <span class="hljs-variable">course</span> <span class="hljs-operator">=</span> session.get(Course.class,<span class="hljs-number">4</span>);<br>        System.out.println(course);<br>        session.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kai.test;<br><br><span class="hljs-keyword">import</span> com.kai.pojo.Course;<br><span class="hljs-keyword">import</span> com.kai.pojo.Orders;<br><span class="hljs-keyword">import</span> org.hibernate.Session;<br><span class="hljs-keyword">import</span> org.hibernate.SessionFactory;<br><span class="hljs-keyword">import</span> org.hibernate.cfg.Configuration;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test6</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建Configuration</span><br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>().configure();<br>        <span class="hljs-comment">// 获取SessionFactory</span><br>        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> configuration.buildSessionFactory();<br>        <span class="hljs-comment">// 获取Session</span><br>        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();<br><br>        <span class="hljs-type">Course</span> <span class="hljs-variable">course</span> <span class="hljs-operator">=</span> session.get(Course.class,<span class="hljs-number">4</span>);<br>        System.out.println(course.getAccounts());<br>        session.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/skaifeng/picgo/raw/master/img/202111041151189.png" alt="image-20211012152738079"></p><h2 id="Hibernate-配置文件"><a href="#Hibernate-配置文件" class="headerlink" title="Hibernate 配置文件"></a>Hibernate 配置文件</h2><ul><li><p><strong>hibernate.cfg.xml</strong></p><ul><li><p>配置 Hibernate 的全局环境</p></li><li><p>1、数据库的基本信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--数据源配置--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;connection.username&quot;</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;connection.password&quot;</span>&gt;</span>123.com<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;connection.driver_class&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;connection.url&quot;</span>&gt;</span>jdbc:mysql://localhost:3307/bdqn?useUnicode=true<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf-8<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>2、集成 C3P0，设置数据库连接池信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--连接池 C3P0 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.c3p0.acquire_increment&quot;</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.c3p0.idle_test_period&quot;</span>&gt;</span>10000<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.c3p0.timeout&quot;</span>&gt;</span>5000<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.c3p0.max_size&quot;</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.c3p0.min_size&quot;</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.c3p0.max_statements&quot;</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>3、Hibernate 基本信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-comment">&lt;!--数据库方言 MySQL--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.dialect&quot;</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!--打印sql语句--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;show_sql&quot;</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!--格式化sql--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;format_sql&quot;</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!--是否自动生成数据表--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hibernate.hbm2ddl.auto&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br></code></pre></td></tr></table></figure><ul><li>update：动态创建表，如果表存在，则直接适用，如果不存在，则创建。</li><li>create：无论表是否存在，都会重新创建。</li><li>create-drop：初始化创建表，程序结束时删除表。</li><li>validate：效验实体关系映射文件和数据表是否对应，不能对应直接报错。</li></ul></li><li><p>4、注册实体关系映射文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--注册实体关系映射文件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/kai/pojo/People.hbm.xml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapping</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/kai/pojo/Customer.hbm.xml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapping</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/kai/pojo/Orders.hbm.xml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapping</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/kai/pojo/Account.hbm.xml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapping</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/kai/pojo/Course.hbm.xml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapping</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>hbm.xml    实体关系映射文件</strong></p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">hibernate-mapping</span> <span class="hljs-keyword">PUBLIC</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;-//Hibernate/Hibernate Mapping DTD//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hibernate-mapping</span> <span class="hljs-attr">package</span>=<span class="hljs-string">&quot;com.kai.pojo&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">class</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Course&quot;</span> <span class="hljs-attr">table</span>=<span class="hljs-string">&quot;t_course&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--主键映射--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">column</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">column</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--自增--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">generator</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;identity&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">generator</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">column</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">column</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;accounts&quot;</span> <span class="hljs-attr">table</span>=<span class="hljs-string">&quot;account_course&quot;</span> <span class="hljs-attr">lazy</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;cid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">many-to-many</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;Account&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;aid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">many-to-many</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">class</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">hibernate-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="hibernate-mapping-属性"><a href="#hibernate-mapping-属性" class="headerlink" title="hibernate-mapping 属性"></a>hibernate-mapping 属性</h3><ul><li><p>package：给 class 节点对应的实体类统一设置包名，此处设置了包名，class 的 name 属性就可以省略包名</p></li><li><p>schema：数据库 schema 的名称</p></li><li><p>catalog：数据库 catalog 的名称</p></li><li><p>default-cascade：默认的级联关系，默认为 none</p></li><li><p>default-access：Hibernate 用来访问属性的策略</p></li><li><p>default-lazy：指定了未明确注明 lazy 属性的 Java 属性和集合类，Hibernate 会采用什么样的加载风格，默认为 True</p></li><li><p>auto-import：指定我们是否可以在查询语句中使用非全限定类名，默认为 True，如果项目中有两个同名的持久化类，最好在两个类的对应映射文件中配置为 false</p></li></ul><h3 id="class-属性"><a href="#class-属性" class="headerlink" title="class 属性"></a>class 属性</h3><ul><li>name：实体类名</li><li>table：数据表名</li><li>schema：数据库 schema 的名称，会覆盖 hibernate-mapping 的 schema</li><li>catalog：数据库 catalog 的名称，会覆盖 hibernate-mapping 的 catalog </li><li>proxy：指定一个接口，在延迟加载时作为代理使用</li><li>dynamic-update：动态更新</li><li>dynamic-insert：动态添加</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kai.test;<br><br><span class="hljs-keyword">import</span> com.kai.pojo.People;<br><span class="hljs-keyword">import</span> org.hibernate.Session;<br><span class="hljs-keyword">import</span> org.hibernate.SessionFactory;<br><span class="hljs-keyword">import</span> org.hibernate.cfg.Configuration;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test7</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建Configuration</span><br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>().configure();<br>        <span class="hljs-comment">// 获取SessionFactory</span><br>        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> configuration.buildSessionFactory();<br>        <span class="hljs-comment">// 获取Session</span><br>        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();<br><br>        <span class="hljs-type">People</span> <span class="hljs-variable">people</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>();<br>        people.setName(<span class="hljs-string">&quot;张三&quot;</span>);<br><br>        session.save(people);<br>        session.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/skaifeng/picgo/raw/master/img/202111041152738.png" alt="image-20211012184048229"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">class</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.kai.pojo.People&quot;</span> <span class="hljs-attr">table</span>=<span class="hljs-string">&quot;people&quot;</span> <span class="hljs-attr">dynamic-insert</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/skaifeng/picgo/raw/master/img/202111041152960.png" alt="image-20211012184234361"></p><p>动态修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kai.test;<br><br><span class="hljs-keyword">import</span> com.kai.pojo.People;<br><span class="hljs-keyword">import</span> org.hibernate.Session;<br><span class="hljs-keyword">import</span> org.hibernate.SessionFactory;<br><span class="hljs-keyword">import</span> org.hibernate.cfg.Configuration;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test7</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建Configuration</span><br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>().configure();<br>        <span class="hljs-comment">// 获取SessionFactory</span><br>        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> configuration.buildSessionFactory();<br>        <span class="hljs-comment">// 获取Session</span><br>        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();<br><br>        <span class="hljs-type">People</span> <span class="hljs-variable">people</span> <span class="hljs-operator">=</span> session.get(People.class,<span class="hljs-number">3</span>);<br>        people.setMoney(<span class="hljs-number">2000.0</span>);<br><br>        session.saveOrUpdate(people);<br>        session.beginTransaction().commit();<br>        session.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/skaifeng/picgo/raw/master/img/202111041152157.png" alt="image-20211012185028700"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">class</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.kai.pojo.People&quot;</span> <span class="hljs-attr">table</span>=<span class="hljs-string">&quot;people&quot;</span> <span class="hljs-attr">dynamic-insert</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">dynamic-update</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/skaifeng/picgo/raw/master/img/202111041152112.png" alt="image-20211012185156623"></p><ul><li>where：查询时给 SQL 语句添加 where 条件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kai.test;<br><br><span class="hljs-keyword">import</span> com.kai.pojo.People;<br><span class="hljs-keyword">import</span> org.hibernate.Session;<br><span class="hljs-keyword">import</span> org.hibernate.SessionFactory;<br><span class="hljs-keyword">import</span> org.hibernate.cfg.Configuration;<br><span class="hljs-keyword">import</span> org.hibernate.query.Query;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test7</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建Configuration</span><br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>().configure();<br>        <span class="hljs-comment">// 获取SessionFactory</span><br>        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> configuration.buildSessionFactory();<br>        <span class="hljs-comment">// 获取Session</span><br>        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">hql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;from People&quot;</span>;<br>        <span class="hljs-type">Query</span> <span class="hljs-variable">query</span> <span class="hljs-operator">=</span> session.createQuery(hql);<br>        List&lt;People&gt; list = query.list();<br>        <span class="hljs-keyword">for</span> (People people: list)&#123;<br>            System.out.println(people);<br>        &#125;<br><br>        session.beginTransaction().commit();<br>        session.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/skaifeng/picgo/raw/master/img/202111041152316.png" alt="image-20211012190030025"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">class</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.kai.pojo.People&quot;</span> <span class="hljs-attr">table</span>=<span class="hljs-string">&quot;people&quot;</span> <span class="hljs-attr">dynamic-insert</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">dynamic-update</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">where</span>=<span class="hljs-string">&quot;id = 1&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/skaifeng/picgo/raw/master/img/202111041152939.png" alt="image-20211012190140330"></p><h3 id="id-属性"><a href="#id-属性" class="headerlink" title="id 属性"></a>id 属性</h3><ul><li>name：实体类的属性名</li><li>type：实体类属性的数据类型</li></ul><p>此处可以设置两种类型的数据：Java数据类型 或者 Hibernate 映射类型</p><p>实体类的属性数据类型必须与数据表对应的字段数据类型一致：</p><p>int 对应 int，String 对应 varchar</p><p>如何进行映射？</p><p>Java数据类型映射到 hibernate 映射类型，再由 hibernate 映射类型映射到 SQL 的数据类型</p><p>Java —》 Hibernate —》 SQL</p><ul><li>column：数据表的主键字段名</li><li>generator：主键的生成策略<ol><li>hilo 算法</li><li>increment：Hibernate 自增</li><li>identity：数据库自增</li><li>native：本地策略，根据底层数据库自动选择主键的生成策略</li><li>uuid.hex 算法</li><li>select 算法</li></ol></li></ul><h3 id="property-属性"><a href="#property-属性" class="headerlink" title="property 属性"></a>property 属性</h3><ul><li>name：实体类的属性名</li><li>column：数据表的字段名</li><li>type：数据类型</li><li>update：该字段是否可以修改，默认为 true</li><li>insert：该字段是否可以添加，默认为 true</li><li>lazy：延迟加载策略</li></ul><h3 id="实体关系映射文件属性"><a href="#实体关系映射文件属性" class="headerlink" title="实体关系映射文件属性"></a>实体关系映射文件属性</h3><ul><li><p>inverse</p><ul><li><p>Customer 和 Orders 是一对多的关系，一个Customer 对应多个 Orders，实体类当中用一个集合来表示对应的 Orders</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kai.pojo;<br><br><span class="hljs-keyword">import</span> lombok.Getter;<br><span class="hljs-keyword">import</span> lombok.Setter;<br><br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Set&lt;Orders&gt; orders;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Customer&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Customer.hbm.xml 中使用 set 标签来配置映射关系</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">hibernate-mapping</span> <span class="hljs-keyword">PUBLIC</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;-//Hibernate/Hibernate Mapping DTD//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hibernate-mapping</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">class</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.kai.pojo.Customer&quot;</span> <span class="hljs-attr">table</span>=<span class="hljs-string">&quot;customer&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--主键映射--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">column</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">column</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--自增--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">generator</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;identity&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">generator</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">column</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">column</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;orders&quot;</span> <span class="hljs-attr">table</span>=<span class="hljs-string">&quot;orders&quot;</span> <span class="hljs-attr">lazy</span>=<span class="hljs-string">&quot;extra&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;cid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">one-to-many</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kai.pojo.Orders&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">one-to-many</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">class</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">hibernate-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kai.pojo;<br><br><span class="hljs-keyword">import</span> lombok.Getter;<br><span class="hljs-keyword">import</span> lombok.Setter;<br><br><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Orders</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Customer customer;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Orders&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">hibernate-mapping</span> <span class="hljs-keyword">PUBLIC</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;-//Hibernate/Hibernate Mapping DTD//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hibernate-mapping</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">class</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.kai.pojo.Orders&quot;</span> <span class="hljs-attr">table</span>=<span class="hljs-string">&quot;orders&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--主键映射--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">column</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">column</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--自增--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">generator</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;identity&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">generator</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">column</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">column</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">many-to-one</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;customer&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kai.pojo.Customer&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;cid&quot;</span> <span class="hljs-attr">lazy</span>=<span class="hljs-string">&quot;proxy&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">many-to-one</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">class</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">hibernate-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kai.test;<br><br><span class="hljs-keyword">import</span> com.kai.pojo.Customer;<br><span class="hljs-keyword">import</span> com.kai.pojo.Orders;<br><span class="hljs-keyword">import</span> org.hibernate.Session;<br><span class="hljs-keyword">import</span> org.hibernate.SessionFactory;<br><span class="hljs-keyword">import</span> org.hibernate.cfg.Configuration;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test8</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建Configuration</span><br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>().configure();<br>        <span class="hljs-comment">// 获取SessionFactory</span><br>        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> configuration.buildSessionFactory();<br>        <span class="hljs-comment">// 获取Session</span><br>        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();<br><br>        <span class="hljs-type">Customer</span> <span class="hljs-variable">customer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Customer</span>();<br>        customer.setName(<span class="hljs-string">&quot;李四&quot;</span>);<br><br>        <span class="hljs-type">Orders</span> <span class="hljs-variable">orders1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orders</span>();<br>        orders1.setName(<span class="hljs-string">&quot;订单2&quot;</span>);<br>        orders1.setCustomer(customer);<br><br>        <span class="hljs-type">Orders</span> <span class="hljs-variable">orders2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orders</span>();<br>        orders2.setName(<span class="hljs-string">&quot;订单2&quot;</span>);<br>        orders2.setCustomer(customer);<br><br>        session.save(customer);<br>        session.save(orders1);<br>        session.save(orders2);<br><br>        session.beginTransaction().commit();<br>        session.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/skaifeng/picgo/raw/master/img/202111041152957.png" alt="image-20211012192041227"></p><p><del>===================================================================================</del></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kai.test;<br><br><span class="hljs-keyword">import</span> com.kai.pojo.Customer;<br><span class="hljs-keyword">import</span> com.kai.pojo.Orders;<br><span class="hljs-keyword">import</span> org.hibernate.Session;<br><span class="hljs-keyword">import</span> org.hibernate.SessionFactory;<br><span class="hljs-keyword">import</span> org.hibernate.cfg.Configuration;<br><br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test8</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建Configuration</span><br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>().configure();<br>        <span class="hljs-comment">// 获取SessionFactory</span><br>        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> configuration.buildSessionFactory();<br>        <span class="hljs-comment">// 获取Session</span><br>        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();<br><br>        <span class="hljs-type">Customer</span> <span class="hljs-variable">customer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Customer</span>();<br>        customer.setName(<span class="hljs-string">&quot;李四&quot;</span>);<br><br>        <span class="hljs-type">Orders</span> <span class="hljs-variable">orders1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orders</span>();<br>        orders1.setName(<span class="hljs-string">&quot;订单2&quot;</span>);<br>        orders1.setCustomer(customer);<br><br>        <span class="hljs-type">Orders</span> <span class="hljs-variable">orders2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orders</span>();<br>        orders2.setName(<span class="hljs-string">&quot;订单2&quot;</span>);<br>        orders2.setCustomer(customer);<br><br>        Set&lt;Orders&gt; orders = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Orders&gt;();<br>        orders.add(orders1);<br>        orders.add(orders2);<br>        customer.setOrders(orders);<br><br>        session.save(customer);<br>        session.save(orders1);<br>        session.save(orders2);<br><br>        session.beginTransaction().commit();<br>        session.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/skaifeng/picgo/raw/master/img/202111041153628.png" alt="image-20211012192435650"></p><p><img src="https://gitee.com/skaifeng/picgo/raw/master/img/202111041153772.png" alt="image-20211012192450916"></p><p><del>因为 Customer 和 Orders 都在维护一对多的关系，所以会重复设置主外建约束关系</del></p><p>如何避免这种情况？</p><ol><li>在Java代码中去掉一方维护关系代码</li><li>通过配置来解决</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- inverse=&quot;true&quot; 放弃维护--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;orders&quot;</span> <span class="hljs-attr">table</span>=<span class="hljs-string">&quot;orders&quot;</span> <span class="hljs-attr">lazy</span>=<span class="hljs-string">&quot;extra&quot;</span> <span class="hljs-attr">inverse</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;cid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">one-to-many</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kai.pojo.Orders&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">one-to-many</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br></code></pre></td></tr></table></figure><p>inverse 属性是用来设置是否将维护权交给对方，默认是 false，不交出维护权，双方都在维护，将它设置为 true，表示 Customer  放弃维护。</p><p><img src="https://gitee.com/skaifeng/picgo/raw/master/img/202111041153723.png" alt="image-20211012192844758"></p><h3 id="cascade：用来设置级联操作"><a href="#cascade：用来设置级联操作" class="headerlink" title="cascade：用来设置级联操作"></a>cascade：用来设置级联操作</h3><p>实体关系映射文件中设置 cascade 值完成级联删除</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--cascade=&quot;delete&quot; 级联删除--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;orders&quot;</span> <span class="hljs-attr">table</span>=<span class="hljs-string">&quot;orders&quot;</span> <span class="hljs-attr">lazy</span>=<span class="hljs-string">&quot;extra&quot;</span> <span class="hljs-attr">inverse</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">cascade</span>=<span class="hljs-string">&quot;delete&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;cid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">one-to-many</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kai.pojo.Orders&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">one-to-many</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Hibernate-HQL"><a href="#Hibernate-HQL" class="headerlink" title="Hibernate HQL"></a>Hibernate HQL</h2><p>HQL: Hibernate Query Language，是 Hibernate框架提供的一种查询机制，它和SQL类似，不同的是HQL是面向对象的查询语句，让开发者能够以面向对象的思想来编写查询语句，对Java编程是一种很友好的方式。</p><p>HQL 不能直接参与数据库的交互，中间层语言</p><p>Java –》HQL –》hibernate –》SQL –》DB</p><p>HQL 只能完成查询、修改、删除，新增是无法操作的</p><h3 id="1、查询对象"><a href="#1、查询对象" class="headerlink" title="1、查询对象"></a>1、查询对象</h3><p>查询表中所有数据，自动完成对象的封装，返回List集合</p><p>HQL 进行查询，from 关键字后面不能有表名，必须写表对应的实体类名</p><p>from People</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kai.test;<br><br><span class="hljs-keyword">import</span> com.kai.pojo.Customer;<br><span class="hljs-keyword">import</span> com.kai.pojo.Orders;<br><span class="hljs-keyword">import</span> com.kai.pojo.People;<br><span class="hljs-keyword">import</span> org.hibernate.Session;<br><span class="hljs-keyword">import</span> org.hibernate.SessionFactory;<br><span class="hljs-keyword">import</span> org.hibernate.cfg.Configuration;<br><span class="hljs-keyword">import</span> org.hibernate.query.Query;<br><br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test9</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建Configuration</span><br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>().configure();<br>        <span class="hljs-comment">// 获取SessionFactory</span><br>        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> configuration.buildSessionFactory();<br>        <span class="hljs-comment">// 获取Session</span><br>        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();<br><br>       <span class="hljs-type">String</span> <span class="hljs-variable">hql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;from People&quot;</span>;<br>        <span class="hljs-type">Query</span> <span class="hljs-variable">query</span> <span class="hljs-operator">=</span> session.createQuery(hql);<br>        List&lt;People&gt; list = query.list();<br>        <span class="hljs-keyword">for</span>(People people:list)&#123;<br>            System.out.println(people);<br>        &#125;<br><br>        session.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/skaifeng/picgo/raw/master/img/202111041153036.png" alt="image-20211012211643636"></p><h3 id="2、分页查询"><a href="#2、分页查询" class="headerlink" title="2、分页查询"></a>2、分页查询</h3><p>HQL 分页查询可以通过调用query的方法来完成。</p><ol><li>setFirstResult()     设置起始下标</li><li>setMaxResult()     设置截取长度</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kai.test;<br><br><span class="hljs-keyword">import</span> com.kai.pojo.Customer;<br><span class="hljs-keyword">import</span> com.kai.pojo.Orders;<br><span class="hljs-keyword">import</span> com.kai.pojo.People;<br><span class="hljs-keyword">import</span> org.hibernate.Session;<br><span class="hljs-keyword">import</span> org.hibernate.SessionFactory;<br><span class="hljs-keyword">import</span> org.hibernate.cfg.Configuration;<br><span class="hljs-keyword">import</span> org.hibernate.query.Query;<br><br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test9</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建Configuration</span><br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>().configure();<br>        <span class="hljs-comment">// 获取SessionFactory</span><br>        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> configuration.buildSessionFactory();<br>        <span class="hljs-comment">// 获取Session</span><br>        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();<br><br>       <span class="hljs-type">String</span> <span class="hljs-variable">hql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;from People&quot;</span>;<br>        <span class="hljs-type">Query</span> <span class="hljs-variable">query</span> <span class="hljs-operator">=</span> session.createQuery(hql);<br>        query.setFirstResult(<span class="hljs-number">1</span>);<br>        query.setMaxResults(<span class="hljs-number">2</span>);<br>        List&lt;People&gt; list = query.list();<br>        <span class="hljs-keyword">for</span>(People people:list)&#123;<br>            System.out.println(people);<br>        &#125;<br><br>        session.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、where-条件查询"><a href="#3、where-条件查询" class="headerlink" title="3、where 条件查询"></a>3、where 条件查询</h3><p>HQL 直接追加 where 关键字作为条件查询，与 SQL 没有区别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kai.test;<br><br><span class="hljs-keyword">import</span> com.kai.pojo.Customer;<br><span class="hljs-keyword">import</span> com.kai.pojo.Orders;<br><span class="hljs-keyword">import</span> com.kai.pojo.People;<br><span class="hljs-keyword">import</span> org.hibernate.Session;<br><span class="hljs-keyword">import</span> org.hibernate.SessionFactory;<br><span class="hljs-keyword">import</span> org.hibernate.cfg.Configuration;<br><span class="hljs-keyword">import</span> org.hibernate.query.Query;<br><br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test9</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建Configuration</span><br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>().configure();<br>        <span class="hljs-comment">// 获取SessionFactory</span><br>        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> configuration.buildSessionFactory();<br>        <span class="hljs-comment">// 获取Session</span><br>        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">hql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;from People where id = 1&quot;</span>;<br>        <span class="hljs-type">Query</span> <span class="hljs-variable">query</span> <span class="hljs-operator">=</span> session.createQuery(hql);<br>        <span class="hljs-type">People</span> <span class="hljs-variable">people</span> <span class="hljs-operator">=</span> (People) query.list().get(<span class="hljs-number">0</span>);<br>        System.out.println(people);<br><br>        session.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">query.list<span class="hljs-comment">()</span>返回一个集合，通过.get<span class="hljs-comment">(0)</span> 取出结果<br></code></pre></td></tr></table></figure><h3 id="4、模糊查询"><a href="#4、模糊查询" class="headerlink" title="4、模糊查询"></a>4、模糊查询</h3><p>查询名称包含三的记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kai.test;<br><br><span class="hljs-keyword">import</span> com.kai.pojo.Customer;<br><span class="hljs-keyword">import</span> com.kai.pojo.Orders;<br><span class="hljs-keyword">import</span> com.kai.pojo.People;<br><span class="hljs-keyword">import</span> org.hibernate.Session;<br><span class="hljs-keyword">import</span> org.hibernate.SessionFactory;<br><span class="hljs-keyword">import</span> org.hibernate.cfg.Configuration;<br><span class="hljs-keyword">import</span> org.hibernate.query.Query;<br><br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test9</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建Configuration</span><br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>().configure();<br>        <span class="hljs-comment">// 获取SessionFactory</span><br>        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> configuration.buildSessionFactory();<br>        <span class="hljs-comment">// 获取Session</span><br>        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">hql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;from People where name like &#x27;%三%&#x27;&quot;</span>;<br>        <span class="hljs-type">Query</span> <span class="hljs-variable">query</span> <span class="hljs-operator">=</span> session.createQuery(hql);<br>        List&lt;People&gt; list = query.list();<br>        <span class="hljs-keyword">for</span>(People people:list)&#123;<br>            System.out.println(people);<br>        &#125;<br><br>        session.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/skaifeng/picgo/raw/master/img/202111041153049.png" alt="image-20211012212537295"></p><h3 id="5、order-by"><a href="#5、order-by" class="headerlink" title="5、order by"></a>5、order by</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kai.test;<br><br><span class="hljs-keyword">import</span> com.kai.pojo.Customer;<br><span class="hljs-keyword">import</span> com.kai.pojo.Orders;<br><span class="hljs-keyword">import</span> com.kai.pojo.People;<br><span class="hljs-keyword">import</span> org.hibernate.Session;<br><span class="hljs-keyword">import</span> org.hibernate.SessionFactory;<br><span class="hljs-keyword">import</span> org.hibernate.cfg.Configuration;<br><span class="hljs-keyword">import</span> org.hibernate.query.Query;<br><br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test9</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建Configuration</span><br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>().configure();<br>        <span class="hljs-comment">// 获取SessionFactory</span><br>        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> configuration.buildSessionFactory();<br>        <span class="hljs-comment">// 获取Session</span><br>        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">hql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;from People order by id desc&quot;</span>;<br>        <span class="hljs-type">Query</span> <span class="hljs-variable">query</span> <span class="hljs-operator">=</span> session.createQuery(hql);<br>        List&lt;People&gt; list = query.list();<br>        <span class="hljs-keyword">for</span>(People people:list)&#123;<br>            System.out.println(people);<br>        &#125;<br><br>        session.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/skaifeng/picgo/raw/master/img/202111041153226.png" alt="image-20211012212708496"></p><h3 id="6、查询实体对象的属性"><a href="#6、查询实体对象的属性" class="headerlink" title="6、查询实体对象的属性"></a>6、查询实体对象的属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kai.test;<br><br><span class="hljs-keyword">import</span> com.kai.pojo.Customer;<br><span class="hljs-keyword">import</span> com.kai.pojo.Orders;<br><span class="hljs-keyword">import</span> com.kai.pojo.People;<br><span class="hljs-keyword">import</span> org.hibernate.Session;<br><span class="hljs-keyword">import</span> org.hibernate.SessionFactory;<br><span class="hljs-keyword">import</span> org.hibernate.cfg.Configuration;<br><span class="hljs-keyword">import</span> org.hibernate.query.Query;<br><br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test9</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建Configuration</span><br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>().configure();<br>        <span class="hljs-comment">// 获取SessionFactory</span><br>        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> configuration.buildSessionFactory();<br>        <span class="hljs-comment">// 获取Session</span><br>        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">hql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select name from People where id = 1&quot;</span>;<br>        <span class="hljs-type">Query</span> <span class="hljs-variable">query</span> <span class="hljs-operator">=</span> session.createQuery(hql);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> (String)query.uniqueResult();<br>        System.out.println(name);<br><br>        session.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/skaifeng/picgo/raw/master/img/202111041153980.png" alt="image-20211012212851050"></p><h3 id="7、占位符"><a href="#7、占位符" class="headerlink" title="7、占位符"></a>7、占位符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kai.test;<br><br><span class="hljs-keyword">import</span> com.kai.pojo.Customer;<br><span class="hljs-keyword">import</span> com.kai.pojo.Orders;<br><span class="hljs-keyword">import</span> com.kai.pojo.People;<br><span class="hljs-keyword">import</span> org.hibernate.Session;<br><span class="hljs-keyword">import</span> org.hibernate.SessionFactory;<br><span class="hljs-keyword">import</span> org.hibernate.cfg.Configuration;<br><span class="hljs-keyword">import</span> org.hibernate.query.Query;<br><br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test9</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建Configuration</span><br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>().configure();<br>        <span class="hljs-comment">// 获取SessionFactory</span><br>        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> configuration.buildSessionFactory();<br>        <span class="hljs-comment">// 获取Session</span><br>        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">hql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;from People where name = :name&quot;</span>;<br>        <span class="hljs-type">Query</span> <span class="hljs-variable">query</span> <span class="hljs-operator">=</span> session.createQuery(hql);<br>        query.setString(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;张三&quot;</span>);<br>        List&lt;People&gt; list = query.list();<br>        <span class="hljs-keyword">for</span>(People people:list)&#123;<br>            System.out.println(list);<br>        &#125;<br><br>        session.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/skaifeng/picgo/raw/master/img/202111041154740.png" alt="image-20211012213049755"></p><h3 id="8、级联查询"><a href="#8、级联查询" class="headerlink" title="8、级联查询"></a>8、级联查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kai.test;<br><br><span class="hljs-keyword">import</span> com.kai.pojo.Customer;<br><span class="hljs-keyword">import</span> com.kai.pojo.Orders;<br><span class="hljs-keyword">import</span> com.kai.pojo.People;<br><span class="hljs-keyword">import</span> org.hibernate.Session;<br><span class="hljs-keyword">import</span> org.hibernate.SessionFactory;<br><span class="hljs-keyword">import</span> org.hibernate.cfg.Configuration;<br><span class="hljs-keyword">import</span> org.hibernate.query.Query;<br><br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test9</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建Configuration</span><br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>().configure();<br>        <span class="hljs-comment">// 获取SessionFactory</span><br>        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> configuration.buildSessionFactory();<br>        <span class="hljs-comment">// 获取Session</span><br>        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">hql1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;from Customer where name = :name&quot;</span>;<br>        <span class="hljs-type">Query</span> <span class="hljs-variable">query1</span> <span class="hljs-operator">=</span> session.createQuery(hql1);<br>        query1.setString(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;张三&quot;</span>);<br>        <span class="hljs-type">Customer</span> <span class="hljs-variable">customer</span> <span class="hljs-operator">=</span> (Customer)query1.uniqueResult();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">hql2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;from Orders where customer = :customer&quot;</span>;<br>        <span class="hljs-type">Query</span> <span class="hljs-variable">query2</span> <span class="hljs-operator">=</span> session.createQuery(hql2);<br>        query2.setEntity(<span class="hljs-string">&quot;customer&quot;</span>,customer);<br>        List&lt;Orders&gt; list = query2.list();<br>        <span class="hljs-keyword">for</span>(Orders orders:list)&#123;<br>            System.out.println(orders);<br>        &#125;<br><br>        session.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/skaifeng/picgo/raw/master/img/202111041154769.png" alt="image-20211012213448036"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
